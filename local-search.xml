<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/11/06/CS231n-notes-Lecture1/"/>
    <url>/2022/11/06/CS231n-notes-Lecture1/</url>
    
    <content type="html"><![CDATA[<h1 id="CS231n-notes-Lecture1"><a href="#CS231n-notes-Lecture1" class="headerlink" title="CS231n-notes-Lecture1"></a>CS231n-notes-Lecture1</h1><h2 id="links"><a href="#links" class="headerlink" title="links"></a>links</h2><p><a href="https://www.youtube.com/watch?v=vT1JzLTH4G4&amp;list=PLC1qU-LWwrF64f4QKQT-Vg5Wr4qEE1Zxk">videos</a></p><p><a href="http://cs231n.stanford.edu/">website</a></p><h2 id="word-list"><a href="#word-list" class="headerlink" title="word list"></a>word list</h2><div class="table-container"><table><thead><tr><th>word</th><th>expression</th></tr></thead><tbody><tr><td>chill</td><td>寒意，寒冷</td></tr><tr><td>manipulate</td><td>操纵</td></tr><tr><td>holistic</td><td>整体的</td></tr><tr><td>primitive</td><td>原始</td></tr><tr><td>audacious</td><td>大胆的</td></tr><tr><td>occlusion</td><td>遮挡</td></tr><tr><td>diagnostic</td><td>诊断</td></tr><tr><td>momentum</td><td>势头</td></tr><tr><td>benchmark</td><td>基准</td></tr><tr><td>gigantic</td><td>巨大的</td></tr><tr><td>restrictive or artificial setup</td><td>限制性或人为性设置</td></tr><tr><td>hierarchical</td><td>分层的</td></tr><tr><td>tweak</td><td>调整</td></tr><tr><td>advent</td><td>到来</td></tr><tr><td>crunch</td><td>紧缩</td></tr><tr><td>tackle</td><td>处理</td></tr><tr><td>exemplify</td><td>例证</td></tr><tr><td>requisites</td><td>要求</td></tr></tbody></table></div><h2 id="Lecture-1"><a href="#Lecture-1" class="headerlink" title="Lecture 1"></a>Lecture 1</h2><h3 id="History-of-computer-vision"><a href="#History-of-computer-vision" class="headerlink" title="History of computer vision"></a>History of computer vision</h3><h4 id="history"><a href="#history" class="headerlink" title="history"></a>history</h4><pre><code class=" mermaid">graph TD;生物视觉:EvolutionBigBang--&gt;暗箱相机模型:CameraObsura;暗箱相机模型:CameraObsura--&gt;通过基本单元构建:GeneralizedCylinder\PictorialStructure;</code></pre><span id="more"></span><h4 id="topics"><a href="#topics" class="headerlink" title="topics"></a>topics</h4><blockquote><p>基本都是介绍！以后遇到了再回来学吧</p></blockquote><h5 id="image-segmentation"><a href="#image-segmentation" class="headerlink" title="image segmentation"></a>image segmentation</h5><p><img src="CS231n-notes-Lecture1.assets/1630629187859.3ocla3bj7gs0.webp" alt="1630629187859"></p><p><img src="CS231n-notes-Lecture1.assets/1280px-Polarlicht_2.65n1owwrsh00.webp" alt="1280px-Polarlicht_2"></p><center>origin picture</center><p><img src="CS231n-notes-Lecture1.assets/1280px-Polarlicht_2_kmeans_16_large.66iggaogfjg0.webp" alt="1280px-Polarlicht_2_kmeans_16_large"></p><center>processed image</center><h5 id="face-detection"><a href="#face-detection" class="headerlink" title="face detection"></a>face detection</h5><p><img src="CS231n-notes-Lecture1.assets/face_contours.1m9hvn6fcv6o.webp" alt="face_contours"></p><h5 id="SIFT"><a href="#SIFT" class="headerlink" title="SIFT"></a>SIFT</h5><blockquote><p>STFT: The scale-invariant feature transform (SIFT，尺度不变特征变换) is a computer vision algorithm to detect, describe, and match local features in images, invented by David Lowe in 1999.</p><p>Applications include object recognition, robotic mapping and navigation, image stitching, 3D modeling, gesture recognition, video tracking, individual identification of wildlife and match moving.</p></blockquote><p>Ref:<a href="https://zhuanlan.zhihu.com/p/70385018">【动手学计算机视觉】第七讲：传统目标检测之SIFT特征- 知乎</a></p><h5 id="object-recognition"><a href="#object-recognition" class="headerlink" title="object recognition"></a>object recognition</h5><blockquote><p>Object recognition is a computer vision technique for detecting + classifying objects in images or videos.</p></blockquote><p><img src="CS231n-notes-Lecture1.assets/task-0000000738-5910777f.5fau6vn83xg0.webp" alt="task-0000000738-5910777f"></p><h5 id="Spatial-Pyramid-Matching"><a href="#Spatial-Pyramid-Matching" class="headerlink" title="Spatial Pyramid Matching"></a>Spatial Pyramid Matching</h5><p>空间金字塔匹配算法</p><p><img src="CS231n-notes-Lecture1.assets/image-20221106221152096.1co6lnlbxa00.webp" alt="image-20221106221152096"></p><h3 id="CS231n-overview"><a href="#CS231n-overview" class="headerlink" title="CS231n overview"></a>CS231n overview</h3><h3 id="visual-recognition-problems"><a href="#visual-recognition-problems" class="headerlink" title="visual recognition problems"></a>visual recognition problems</h3><p><strong>image classification</strong> - the most important problems of visual recognition</p><p>related: </p><ul><li>object recognition</li><li>image captioning </li></ul><blockquote><p><strong>Image Captioning</strong> is the task of describing the content of an image in words. </p></blockquote><p>目前距离达到与人类相同的水平还很远。</p><ul><li>action classification</li></ul><p><strong>CNN</strong> - important tool</p><p>Fun topics: DeepDream…(Novelai?)</p><h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><div class="table-container"><table><thead><tr><th>时间</th><th>记录</th></tr></thead><tbody><tr><td>2022.11.6</td><td>看完第一遍；写完笔记初稿</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>CS231n-notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/31/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA/"/>
    <url>/2022/10/31/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="名词汇总"><a href="#名词汇总" class="headerlink" title="名词汇总"></a>名词汇总</h1><div class="table-container"><table><thead><tr><th>名词</th><th style="text-align:left">说明</th><th>举例（写法）</th></tr></thead><tbody><tr><td>training data set</td><td style="text-align:left"></td><td></td></tr><tr><td>sample(data point, data instance数据样本)</td><td style="text-align:left"></td><td>$\bold{x}^{(i)}=[x_1^{(i)}+x_2^{(i)}]^T$</td></tr><tr><td>label(target)</td><td style="text-align:left">试图预测的目标</td><td>$y^{(i)}$</td></tr><tr><td>features(covariates协变量)</td><td style="text-align:left">预测时依据的自变量</td><td></td></tr><tr><td>batch size</td><td style="text-align:left">小批量样本数</td><td></td></tr><tr><td>learning rate</td><td style="text-align:left"></td><td></td></tr><tr><td>hyperparameter</td><td style="text-align:left">超参数</td><td></td></tr><tr><td>hyperparameter tuning</td><td style="text-align:left">调参</td><td></td></tr><tr><td>validation data set</td><td style="text-align:left">验证数据集</td><td></td></tr><tr><td>likelihood</td><td style="text-align:left">可能性</td></tr></tbody></table></div><h1 id="线性回归基本概念"><a href="#线性回归基本概念" class="headerlink" title="线性回归基本概念"></a>线性回归基本概念</h1><h2 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h2><ul><li>x和y之间呈线性关系</li><li>噪声正态分布</li></ul><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>例如$y=w_1x_1+w_2x_2+b$，可称之为<strong>仿射变换(affine transformation)</strong></p><blockquote><p>通过加权和特征进行线性变换，并通过偏置项进行平移</p></blockquote><p>写成向量形式</p><script type="math/tex; mode=display">\hat{y}=\bold{w}^Tx+b</script><p>记X为特征集合，<strong>每行代表一个样本，每列代表一个特征</strong>，线性模型为</p><script type="math/tex; mode=display">\hat{y}=Xw+b</script><span id="more"></span><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>给定训练数据特征X、已知标签y，求权重向量w和偏置b，当给定<strong>从X同分布中取样的新样本特征</strong>时，使得新样本预测标签的误差尽可能小。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><h3 id="平方误差"><a href="#平方误差" class="headerlink" title="平方误差"></a>平方误差</h3><p>常用平方误差：</p><script type="math/tex; mode=display">l^{(i)}(\bold{w},b)=\frac{1}{2}(\hat{y}^{(i)}-y^{(i)})^2</script><blockquote><p>系数1/2是为了求导之后系数变为1，无特殊含义</p></blockquote><p>一般计算训练集n个样本上的损失均值</p><script type="math/tex; mode=display">L(\bold{w},b)=\frac{1}{n}\sum_{i=1}^nl^{(i)}(\bold{w},b)=\frac{1}{n}\sum_{i=1}^n\frac{1}{2}(\bold{w}^Tx^{(i)}+b-y^{(i)})^2</script><h3 id="与正态分布的联系"><a href="#与正态分布的联系" class="headerlink" title="与正态分布的联系"></a>与正态分布的联系</h3><blockquote><p>正态分布随机变量x具有均值$\mu$和标准差$\sigma$,概率密度函数为</p><script type="math/tex; mode=display">p(x)=\frac{1}{\sqrt{2\pi \sigma^2}}exp(-\frac{1}{2\sigma^2}(x-\mu)^2)</script></blockquote><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/Snipaste_2022-10-13_21-26-37.4fkp9j2zaj60.webp" alt="Snipaste_2022-10-13_21-26-37"></p><p>总结：<strong>最小化目标函数等价于执行最大似然估计</strong></p><h2 id="解析解"><a href="#解析解" class="headerlink" title="解析解"></a>解析解</h2><p>线性回归问题可以表示为</p><script type="math/tex; mode=display">\bold{w}^*,b^*=\operatorname{argmin}_{\bold{w},b}L(\bold{w},b)</script><p>存在解析解【但是还不会算】</p><h2 id="Minibatch-stochastic-gradient-descent-小批量随机梯度下降"><a href="#Minibatch-stochastic-gradient-descent-小批量随机梯度下降" class="headerlink" title="Minibatch stochastic gradient descent(小批量随机梯度下降)"></a>Minibatch stochastic gradient descent(小批量随机梯度下降)</h2><p>梯度下降：计算<strong>损失函数</strong>关于<strong>模型参数</strong>的<strong>导数(梯度)</strong></p><p>每次计算更新时随机抽取一小批样本$\Beta$：<strong><em>Minibatch stochastic gradient descent</em></strong></p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul><li>初始化模型参数</li><li>随机抽取小批量样本，在负梯度方向更新参数</li><li>不断迭代</li></ul><script type="math/tex; mode=display">\bold{w} \leftarrow \bold{w}-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}\partial_{\bold{w}}l^{(i)}(\bold{w},b)=\bold{w}-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}\bold{x}^{(i)}(\bold{w}^Tx^{(i)}+b-y^{(i)}),\\b \leftarrow b-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}\partial_{b}l^{(i)}(\bold{w},b)=b-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}(\bold{w}^Tx^{(i)}+b-y^{(i)})</script><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li>$|\Beta|$表示每个小批量的<strong>样本数(batch size)</strong></li><li>$\eta$表示<strong>学习率(learning rate)</strong></li></ul><p>这些参数通常预先指定，可以调整，但不在训练过程中更新，称为<strong>超参数(hyperparameter)</strong>，选择超参数的过程称为<strong>调参(hyperparameter tuning)</strong></p><h2 id="矢量化加速"><a href="#矢量化加速" class="headerlink" title="矢量化加速"></a>矢量化加速</h2><p>利用线性代数库矢量化代码，可以实现对运算数量级的速度提升。</p><h2 id="与神经网络的联系"><a href="#与神经网络的联系" class="headerlink" title="与神经网络的联系"></a>与神经网络的联系</h2><p>线性回归模型可视为单个人工神经元组成的网络(<strong>单层神经网络</strong>)</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/Snipaste_2022-10-13_21-31-37.5kgfyh56fcg0.webp" alt="Snipaste_2022-10-13_21-31-37"></p><h2 id="调用API版本"><a href="#调用API版本" class="headerlink" title="调用API版本"></a>调用API版本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">synthesis_data</span>(<span class="hljs-params">w, b, number</span>):<br>    X = torch.rand(number, <span class="hljs-built_in">len</span>(w))<br>    noise = torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, size=(number, <span class="hljs-number">1</span>))<br>    y = torch.matmul(X, w) + noise<br>    y += b<br>    <span class="hljs-keyword">return</span> X, y<br><br><span class="hljs-comment"># dataloader 还不理解</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_array</span>(<span class="hljs-params">data_array, batch_size, is_train=<span class="hljs-literal">True</span></span>):<br>    dataset = data.TensorDataset(*data_array)<br>    <span class="hljs-keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)<br><br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 生成数据集</span><br>    w_true = torch.tensor([<span class="hljs-number">2</span>, -<span class="hljs-number">3.4</span>]).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>    b_true = <span class="hljs-number">4.2</span><br>    n = <span class="hljs-number">1000</span><br>    features, labels = synthesis_data(w_true, b_true, n)<br><br>    batch_size = <span class="hljs-number">10</span><br>    data_iter = load_array((features, labels), batch_size)<br>    <span class="hljs-comment"># print(next(iter(data_iter)))</span><br><br>    net = nn.Sequential(nn.Linear(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>))<br>    net[<span class="hljs-number">0</span>].weight.data.normal_(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>)<br>    net[<span class="hljs-number">0</span>].bias.data.fill_(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment"># print(net[0])</span><br><br>    loss = nn.MSELoss()<br>    trainer = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.03</span>)<br><br>    num_epochs = <span class="hljs-number">30</span><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, num_epochs+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter:<br>            l = loss(net(X), y)<br>            trainer.zero_grad()<br>            l.backward()<br>            trainer.step()<br>        l = loss(net(features), labels)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;epoch<span class="hljs-subst">&#123;epoch&#125;</span>, loss<span class="hljs-subst">&#123;l:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br><br>    w = net[<span class="hljs-number">0</span>].weight.data<br>    b = net[<span class="hljs-number">0</span>].bias.data<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;error of w= <span class="hljs-subst">&#123;w-w_true&#125;</span>&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;error of b= <span class="hljs-subst">&#123;b-b_true&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>其中还有不少不理解的地方，等待后续补充</p><h3 id="【不理解的地方】"><a href="#【不理解的地方】" class="headerlink" title="【不理解的地方】"></a>【不理解的地方】</h3>]]></content>
    
    
    <categories>
      
      <category>DL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/31/Re%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%89%8B%E5%86%99%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <url>/2022/10/31/Re%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%89%8B%E5%86%99%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="Re-从0开始的手写线性回归"><a href="#Re-从0开始的手写线性回归" class="headerlink" title="Re:从0开始的手写线性回归"></a>Re:从0开始的手写线性回归</h1><p>只使用<strong>tensor</strong>和<strong>autograd</strong>完成简单的线性回归全过程。</p><h2 id="一些小细节"><a href="#一些小细节" class="headerlink" title="一些小细节"></a>一些小细节</h2><ul><li>pycharm要求函数之间空两行</li><li>函数内部变量尽量不要与外部重名，参考：</li></ul><p><a href="https://www.cnblogs.com/shengulong/p/10171386.html">https://www.cnblogs.com/shengulong/p/10171386.html</a></p><p><a href="https://www.twle.cn/t/649">https://www.twle.cn/t/649</a></p><p>【目前还不完全理解，以及不确定是否需要解决】</p><h2 id="代码注解"><a href="#代码注解" class="headerlink" title="代码注解"></a>代码注解</h2><h3 id="生成数据集"><a href="#生成数据集" class="headerlink" title="生成数据集"></a>生成数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">synthesis_data</span>(<span class="hljs-params">w, b, number</span>):<br>    X = torch.rand(number, <span class="hljs-built_in">len</span>(w))<br>    noise = torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, size=(number, <span class="hljs-number">1</span>))<br>    y = torch.matmul(X, w) + noise<br>    y += b<br>    <span class="hljs-keyword">return</span> X, y<br></code></pre></td></tr></table></figure><ul><li><h4 id="y-b一句需要单独成行，否则会出错"><a href="#y-b一句需要单独成行，否则会出错" class="headerlink" title="y+=b一句需要单独成行，否则会出错"></a><code>y+=b</code>一句需要单独成行，否则会出错</h4></li><li><p>采用<code>reshape(x, y)</code>可以改变tensor的大小，如果参数选择-1则可以仅输入行或者列，自动计算另一个参数。书中使用的<code>reshape(-1, 1)</code>可以确定列数为1，自动计算行数。</p></li></ul><p>生成后画出特征的两个维度和标签的三维散点图：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/Figure_1.jdj9vymy5t4.webp" alt="Figure_1"></p><span id="more"></span><h3 id="随机读取小批量数据"><a href="#随机读取小批量数据" class="headerlink" title="随机读取小批量数据"></a>随机读取小批量数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># iter:迭代器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_iter</span>(<span class="hljs-params">batch_size, features, labels</span>):<br>    total_number = <span class="hljs-built_in">len</span>(labels)<br>    indices = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(total_number))<br>    random.shuffle(indices)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, total_number-batch_size, batch_size):<br>        batch_indices = indices[i:i+batch_size-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">yield</span> features[batch_indices, :], labels[batch_indices]<br></code></pre></td></tr></table></figure><ul><li>学习这种随机取出小批量数据的方法！</li><li>合理大小的小批量可以利⽤GPU硬件的优势，每个样本都可以并行地进行模型计算、损失函数计算、梯度计算。结果是GPU可以在处理几百个样本时，所花费的时间不比处理⼀个样本时多太多。</li><li>实际上深度学习内置的iter效率高得多</li></ul><h3 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h3><p>在这里模型参数指权重w和偏置b。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">initialize_parameter</span>(<span class="hljs-params">mu, sigma</span>):<br>    w = torch.normal(mu, sigma, size=(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), requires_grad=<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># w = torch.zeros(size=(2, 1), requires_grad=True)</span><br>    b = torch.zeros(<span class="hljs-number">1</span>, requires_grad=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> w, b<br></code></pre></td></tr></table></figure><ul><li>参数w使用了正态分布进行初始化，其实也可以直接以0作为初始值【那为什么要指定初始值啊】</li><li>注意不要漏掉<code>requires_grad=True</code></li></ul><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_regression</span>(<span class="hljs-params">w, b, X</span>):<br>    <span class="hljs-keyword">return</span> torch.matmul(X, w) + b<br></code></pre></td></tr></table></figure><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">squared_loss</span>(<span class="hljs-params">labels, targets</span>):<br>    <span class="hljs-comment"># return 0.5 * (labels - targets) ** 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span> * (labels - targets.reshape(labels.shape)) ** <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ul><li>这里使用了<code>reshape()</code>，是一种安全且规范的写法，保证了两个向量确实是按我们期望的方式都作为列项链进行相减。<strong>值得认可！</strong></li></ul><h3 id="优化算法-小批量随机梯度下降"><a href="#优化算法-小批量随机梯度下降" class="headerlink" title="优化算法(小批量随机梯度下降)"></a>优化算法(小批量随机梯度下降)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sgd</span>(<span class="hljs-params">params, learning_rate, batch_size</span>):<br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:<br>            param -= learning_rate * param.grad / batch_size<br>            param.grad.zero_()<br></code></pre></td></tr></table></figure><p>【关于自动求导的部分待填坑】</p><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 初始化模型参数</span><br>w, b = initialize_parameter(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>)<br>learning_rate = <span class="hljs-number">0.03</span><br>batch_size = <span class="hljs-number">10</span><br>net = linear_regression<br>num_epochs = <span class="hljs-number">30</span><br>loss = squared_loss<br></code></pre></td></tr></table></figure><ul><li><p>注意这两句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">net = linear_regression<br>loss = squared_loss<br></code></pre></td></tr></table></figure><p>是一种规范的写法，<strong>值得认可！</strong></p></li></ul><h4 id="训练过程-1"><a href="#训练过程-1" class="headerlink" title="训练过程"></a>训练过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    <span class="hljs-keyword">for</span> features_sample, labels_sample <span class="hljs-keyword">in</span> data_iter(batch_size, features, labels):<br>        loss_list = loss(net(w, b, features_sample), labels_sample)<br>        loss_list.<span class="hljs-built_in">sum</span>().backward()<br>        sgd([w, b], learning_rate, batch_size)<br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        train_loss = loss(net(w, b, features), labels)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;epoch <span class="hljs-subst">&#123;epoch + <span class="hljs-number">1</span>&#125;</span>, loss <span class="hljs-subst">&#123;<span class="hljs-built_in">float</span>(train_loss.mean()):f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>整个算法步骤按上一节所述如下：</p><ul><li>初始化模型参数</li><li>随机抽取小批量样本，在负梯度方向更新参数</li><li>不断迭代</li></ul><script type="math/tex; mode=display">\bold{w} \leftarrow \bold{w}-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}\partial_{\bold{w}}l^{(i)}(\bold{w},b)=\bold{w}-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}\bold{x}^{(i)}(\bold{w}^Tx^{(i)}+b-y^{(i)}),\\b \leftarrow b-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}\partial_{b}l^{(i)}(\bold{w},b)=b-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}(\bold{w}^Tx^{(i)}+b-y^{(i)})</script><p>【关于自动求导的部分待填坑】</p><h3 id="训练效果"><a href="#训练效果" class="headerlink" title="训练效果"></a>训练效果</h3><p>这里如果<code>num_epochs</code>设为3，我的代码效果不好，因此增大到30了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">epoch <span class="hljs-number">1</span>, loss <span class="hljs-number">0.602139</span><br>epoch <span class="hljs-number">2</span>, loss <span class="hljs-number">0.400999</span><br>epoch <span class="hljs-number">3</span>, loss <span class="hljs-number">0.274957</span><br>epoch <span class="hljs-number">4</span>, loss <span class="hljs-number">0.188473</span><br>epoch <span class="hljs-number">5</span>, loss <span class="hljs-number">0.130619</span><br>epoch <span class="hljs-number">6</span>, loss <span class="hljs-number">0.091479</span><br>epoch <span class="hljs-number">7</span>, loss <span class="hljs-number">0.064301</span><br>epoch <span class="hljs-number">8</span>, loss <span class="hljs-number">0.045488</span><br>epoch <span class="hljs-number">9</span>, loss <span class="hljs-number">0.032430</span><br>epoch <span class="hljs-number">10</span>, loss <span class="hljs-number">0.023281</span><br>epoch <span class="hljs-number">11</span>, loss <span class="hljs-number">0.016996</span><br>epoch <span class="hljs-number">12</span>, loss <span class="hljs-number">0.012337</span><br>epoch <span class="hljs-number">13</span>, loss <span class="hljs-number">0.009028</span><br>epoch <span class="hljs-number">14</span>, loss <span class="hljs-number">0.006587</span><br>epoch <span class="hljs-number">15</span>, loss <span class="hljs-number">0.004879</span><br>epoch <span class="hljs-number">16</span>, loss <span class="hljs-number">0.003635</span><br>epoch <span class="hljs-number">17</span>, loss <span class="hljs-number">0.002709</span><br>epoch <span class="hljs-number">18</span>, loss <span class="hljs-number">0.002028</span><br>epoch <span class="hljs-number">19</span>, loss <span class="hljs-number">0.001535</span><br>epoch <span class="hljs-number">20</span>, loss <span class="hljs-number">0.001165</span><br>epoch <span class="hljs-number">21</span>, loss <span class="hljs-number">0.000886</span><br>epoch <span class="hljs-number">22</span>, loss <span class="hljs-number">0.000677</span><br>epoch <span class="hljs-number">23</span>, loss <span class="hljs-number">0.000522</span><br>epoch <span class="hljs-number">24</span>, loss <span class="hljs-number">0.000404</span><br>epoch <span class="hljs-number">25</span>, loss <span class="hljs-number">0.000316</span><br>epoch <span class="hljs-number">26</span>, loss <span class="hljs-number">0.000250</span><br>epoch <span class="hljs-number">27</span>, loss <span class="hljs-number">0.000202</span><br>epoch <span class="hljs-number">28</span>, loss <span class="hljs-number">0.000164</span><br>epoch <span class="hljs-number">29</span>, loss <span class="hljs-number">0.000136</span><br>epoch <span class="hljs-number">30</span>, loss <span class="hljs-number">0.000114</span><br>loss of w: tensor([[-<span class="hljs-number">0.0262</span>], [-<span class="hljs-number">0.0319</span>]], grad_fn=&lt;SubBackward0&gt;)<br>loss of b: tensor([<span class="hljs-number">0.0309</span>], grad_fn=&lt;RsubBackward1&gt;)<br></code></pre></td></tr></table></figure><p>训练效果：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/训练效果.26wsulhzy5j4.webp" alt="训练效果"></p><h2 id="调API的线性回归"><a href="#调API的线性回归" class="headerlink" title="调API的线性回归"></a>调API的线性回归</h2><p>思想与上面完全一致，但是代码精简很多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">synthesis_data</span>(<span class="hljs-params">w, b, number</span>):<br>    X = torch.rand(number, <span class="hljs-built_in">len</span>(w))<br>    noise = torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, size=(number, <span class="hljs-number">1</span>))<br>    y = torch.matmul(X, w) + noise<br>    y += b<br>    <span class="hljs-keyword">return</span> X, y<br><br><span class="hljs-comment"># dataloader 还不理解</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_array</span>(<span class="hljs-params">data_array, batch_size, is_train=<span class="hljs-literal">True</span></span>):<br>    dataset = data.TensorDataset(*data_array)<br>    <span class="hljs-keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)<br><br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 生成数据集</span><br>    w_true = torch.tensor([<span class="hljs-number">2</span>, -<span class="hljs-number">3.4</span>]).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>    b_true = <span class="hljs-number">4.2</span><br>    n = <span class="hljs-number">1000</span><br>    features, labels = synthesis_data(w_true, b_true, n)<br><br>    batch_size = <span class="hljs-number">10</span><br>    data_iter = load_array((features, labels), batch_size)<br>    <span class="hljs-comment"># print(next(iter(data_iter)))</span><br><br>    net = nn.Sequential(nn.Linear(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>))<br>    net[<span class="hljs-number">0</span>].weight.data.normal_(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>)<br>    net[<span class="hljs-number">0</span>].bias.data.fill_(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment"># print(net[0])</span><br><br>    loss = nn.MSELoss()<br>    trainer = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.03</span>)<br><br>    num_epochs = <span class="hljs-number">30</span><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, num_epochs+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter:<br>            l = loss(net(X), y)<br>            trainer.zero_grad()<br>            l.backward()<br>            trainer.step()<br>        l = loss(net(features), labels)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;epoch<span class="hljs-subst">&#123;epoch&#125;</span>, loss<span class="hljs-subst">&#123;l:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br><br>    w = net[<span class="hljs-number">0</span>].weight.data<br>    b = net[<span class="hljs-number">0</span>].bias.data<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;error of w= <span class="hljs-subst">&#123;w-w_true&#125;</span>&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;error of b= <span class="hljs-subst">&#123;b-b_true&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>仍然有一样的问题，书中训练3个epoch效果就很好，我需要训练到10个左右才能达到相同效果</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>DL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/10/31/softmax%E5%9B%9E%E5%BD%92(%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA)/"/>
    <url>/2022/10/31/softmax%E5%9B%9E%E5%BD%92(%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA)/</url>
    
    <content type="html"><![CDATA[<h1 id="softmax回归"><a href="#softmax回归" class="headerlink" title="softmax回归"></a>softmax回归</h1><h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li>电子邮件是否属于垃圾邮件文件夹</li><li>用户是否注册服务</li><li>图像描述的内容是狗、猫还是只因</li><li>韩梅梅接下来可能看那部电影</li></ul><h3 id="硬性类别-软性类别"><a href="#硬性类别-软性类别" class="headerlink" title="硬性类别/软性类别"></a>硬性类别/软性类别</h3><div class="table-container"><table><thead><tr><th>类别</th><th>说明</th></tr></thead><tbody><tr><td>硬性类别</td><td>属于哪个类别</td></tr><tr><td>软性类别</td><td>属于每个类别的概率</td></tr></tbody></table></div><h3 id="one-hot-encoding-独热编码"><a href="#one-hot-encoding-独热编码" class="headerlink" title="one-hot encoding(独热编码)"></a>one-hot encoding(独热编码)</h3><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.cnblogs.com/zongfa/p/9305657.html">https://www.cnblogs.com/zongfa/p/9305657.html</a></p><h2 id="softmax模型"><a href="#softmax模型" class="headerlink" title="softmax模型"></a>softmax模型</h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>线性模型的分类问题需要<strong>afffine function(仿射函数)</strong>，</p><p>向量形式表达为：</p><script type="math/tex; mode=display">\bold{o=Wx+b}</script><p>全连接网络结构：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/1.6vw7b1ngrgc0.webp" alt="1"></p><span id="more"></span><h4 id="关于全连接网络的参数开销"><a href="#关于全连接网络的参数开销" class="headerlink" title="关于全连接网络的参数开销"></a>关于全连接网络的参数开销</h4><p>目前设计的全连接网络在有d个输入和q个输出的情况下参数开销为$O(dq)$，可能是过高的。</p><p>在指定超参数n后成本可以降低到$O(\frac{dq}{n})$</p><p>【但这部分只是提及一下，后面补充细节】</p><h3 id="softmax运算"><a href="#softmax运算" class="headerlink" title="softmax运算"></a>softmax运算</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>希望模型的输出$\hat{y_j}$可以被看作属于类别j的概率，则预测结果就是具有最大输出值的类别$argmax_jy_j$</p><h4 id="calibration-校准"><a href="#calibration-校准" class="headerlink" title="calibration(校准)"></a>calibration(校准)</h4><p>为达到这个目的引入softmax函数，希望能够将<strong>未归一化的预测</strong>变换为<strong>非负且总和为1</strong>、<strong>且模型可导</strong></p><script type="math/tex; mode=display">\hat{y}=softmax(\bold(o)), where\space \hat{y_j}=\frac{exp(o_j)}{\sum_k exp(o_k)}</script><p>softmax运算不改变原本预测结果o之间的顺序，因此仍然是一个线性模型，仍然可以通过</p><script type="math/tex; mode=display">\operatorname{argmax}_j\hat{y_j}=\operatorname{argmax}_j\hat{o_j}</script><h4 id="小批量计算过程"><a href="#小批量计算过程" class="headerlink" title="小批量计算过程"></a>小批量计算过程</h4><p>读取批量样本X，输入维度d，批量大小n，输出q个类别，即</p><script type="math/tex; mode=display">X\in \mathbb{R}^{n\times d},W\in \mathbb{R}^{d\times q},b\in \mathbb{R}^{1\times q}</script><p>矢量计算表达式为</p><script type="math/tex; mode=display">\bold{O=XW+b} \\\bold{\hat{Y}}=softmax(\bold{O})</script><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><h3 id="对数似然"><a href="#对数似然" class="headerlink" title="对数似然"></a>对数似然</h3><p>【不懂】</p><h2 id="信息论基础"><a href="#信息论基础" class="headerlink" title="信息论基础"></a>信息论基础</h2><p>【不懂】</p>]]></content>
    
    
    <categories>
      
      <category>DL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/09/25/Bitonic-Sort%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/2022/09/25/Bitonic-Sort%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="分段双调排序-解题报告"><a href="#分段双调排序-解题报告" class="headerlink" title="分段双调排序-解题报告"></a>分段双调排序-解题报告</h1><p>同济大学电子与信息工程学院  操铄</p><h2 id="a-算法描述"><a href="#a-算法描述" class="headerlink" title="a)算法描述"></a>a)算法描述</h2><h3 id="0-定义"><a href="#0-定义" class="headerlink" title="0.定义"></a>0.定义</h3><p>双调排序是一种并行排序算法，它同时也被用于排序网络的构建。</p><h3 id="1-双调序列"><a href="#1-双调序列" class="headerlink" title="1.双调序列"></a>1.双调序列</h3><p>双调序列是一个先单调递增后单调递减（或者先单调递减后单调递增）的序列。</p><p>即序列表示为</p><script type="math/tex; mode=display">x_0 \leq \ldots \leq x_k \geq \ldots \geq x_{n-1}(0 \leq k  \leq n)</script><h3 id="2-Batcher定理"><a href="#2-Batcher定理" class="headerlink" title="2.Batcher定理"></a>2.Batcher定理</h3><p>将任意一个长为<code>2n</code>的双调序列分为等长的两半<code>X</code>和<code>Y</code>，将<code>X</code>中的元素与<code>Y</code>中的元素按原顺序比较，即对于所有的<code>0&lt;=i&lt;n</code>，比较<code>a[i]</code>与<code>a[i+n]</code>，将较大者放入<code>MAX</code>序列，较小者放入<code>MIN</code>序列。</p><p>定理指出，经过这一操作后得到的<code>MAX</code>和<code>MIN</code>序列仍然是双调序列，并且<code>MAX</code>序列中的任意一个元素不小于<code>MIN</code>序列中的任意一个元素。</p><p>这一操作对应代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n;i++) <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>(i)&gt;<span class="hljs-built_in">get</span>(i+n)) <span class="hljs-built_in">exchange</span>(i,i+n);<br></code></pre></td></tr></table></figure><h3 id="3-双调排序"><a href="#3-双调排序" class="headerlink" title="3.双调排序"></a><strong>3.双调排序</strong></h3><p>假设有一个双调序列，根据Batcher定理，将该序列划分成2个双调序列，然后继续对每个双调序列递归划分，得到更短的双调序列，直到得到的子序列长度为1为止，于是得到了一个按单调递增顺序排列的输出序列。</p><p>具体方法是，把一个序列<code>(1…n)</code>对半分，假设<code>n=2^k</code>，然后<code>1</code>和<code>n/2+1</code>比较，小的放上，接下来<code>2</code>和<code>n/2+2</code>比较，小的放上，以此类推；然后看成两个<code>(n/2)</code>长度的序列，因为他们都是双调序列，所以可以重复上面的过程；总共重复<code>k</code>轮，即最后一轮已经是长度是<code>2</code>的序列比较了，就可得到最终的排序结果。</p><p><img src="https://img-blog.csdn.net/20170730230343427?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGJpbndvcmxk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="双调排序示意图"></p><p>（图片来源：<a href="https://blog.csdn.net/xbinworld/article/details/76408595">三十分钟理解：双调排序Bitonic Sort，适合并行计算的排序算法</a>）</p><p>上图为这组元素进行升序双调排序的示意图。可以看到第一轮比较中，只有<code>20</code>和<code>0</code>发生了交换；第二轮比较中，<code>9</code>和<code>0</code>、<code>95</code>和<code>35</code>、<code>90</code>和<code>23</code>、<code>60</code>和<code>18</code>、<code>40</code>和<code>20</code>发生了交换，由于序列长度为<code>16</code>，递归到第四轮时得到了正确的升序结果。</p><h3 id="4-任意序列生成双调序列"><a href="#4-任意序列生成双调序列" class="headerlink" title="4.任意序列生成双调序列"></a><strong>4.任意序列生成双调序列</strong></h3><p>前面所述为双调序列的排序方法，现在讨论如何将任意序列变成一个双调序列。</p><p>这个过程和前面排序的思路相反，基本想法是：如果已经有两个相邻、长度为<code>n</code>的、单调性相反的序列， 就可以连接得到一个长度为<code>2n</code>的双调序列，然后对这个<code>2n</code>的序列进行一次双调排序变成有序。</p><p>以16个元素的array为例，具体步骤如下：</p><p><img src="https://img-blog.csdn.net/20170730231529532?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQveGJpbndvcmxk/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="生成双调序列示意图"></p><p>（图片来源：<a href="https://blog.csdn.net/xbinworld/article/details/76408595">三十分钟理解：双调排序Bitonic Sort，适合并行计算的排序算法</a>）</p><ol><li>相邻两个元素合并形成8个单调性相反的单调序列</li><li>两两序列合并，形成4个双调序列，分别按相反单调性排序</li><li>4个长度为4的相反单调性单调序列，相邻两个合并，生成两个长度为8的双调序列，分别按相反单调性排序</li><li>2个长度为8的相反单调性单调序列，相邻两个合并，生成1个长度为16的双调序列，排序</li></ol><h3 id="5-非2的幂次长度序列双调排序"><a href="#5-非2的幂次长度序列双调排序" class="headerlink" title="5.非2的幂次长度序列双调排序"></a><strong>5.非2的幂次长度序列双调排序</strong></h3><p>以上讨论的双调排序算法只适合于<code>n</code>为<code>2</code>的幂次的情况。为了适合于任意长度的数组，可以用一个定义的最大或者最小者来填充数组，让数组的大小填充到<code>2</code>的幂长度，再进行排序，最后过滤掉那些最大（最小）值即可。</p><p>本次解题中使用的就是这种方式，但是在数组长度较大的时候可能会造成比较大的空间浪费，可以在以后的学习工作中学习更好的解决方案。</p><h2 id="b-尝试过和完成了的加分挑战"><a href="#b-尝试过和完成了的加分挑战" class="headerlink" title="b)尝试过和完成了的加分挑战"></a>b)尝试过和完成了的加分挑战</h2><p>所有的加分挑战都已完成，下面分别叙述：</p><h3 id="1-不递归"><a href="#1-不递归" class="headerlink" title="1.不递归"></a>1.不递归</h3><p><code>segmentedBitonicSort</code>函数及其所调用的任何其他函数在程序中都没有进行形式的递归。</p><h3 id="2-不调用函数"><a href="#2-不调用函数" class="headerlink" title="2.不调用函数"></a>2.不调用函数</h3><p><code>segmentedBitonicSort</code>函数内未调用除标准库以外的其他任何函数。</p><h3 id="3-内存高效"><a href="#3-内存高效" class="headerlink" title="3.内存高效"></a>3.内存高效</h3><p><code>segmentedBitonicSort</code>及其所调用的任何其他函数都没有进行任何形式的动态内存分配。</p><h3 id="4-可并行"><a href="#4-可并行" class="headerlink" title="4.可并行"></a>4.可并行</h3><p><code>segmentedBitonicSort</code>涉及到的所有时间复杂度O(n)以上的代码都写在for循环中，而且每个这样的for循环内部的循环顺序可以任意改变，不影响程序结果。</p><h3 id="5-不需内存"><a href="#5-不需内存" class="headerlink" title="5.不需内存"></a>5.不需内存</h3><p><code>segmentedBitonicSort</code>不调用任何函数（包括C/C++标准库函数，不使用全局变量，所有局部变量都是<code>int</code>、<code>float</code>或指针类型，C++程序不使用new关键字。</p><h3 id="6-绝对鲁棒"><a href="#6-绝对鲁棒" class="headerlink" title="6.绝对鲁棒"></a>6.绝对鲁棒</h3><p>包含<code>NaN</code>时（例如<code>sqrt(-1.f)</code>），保证除<code>NaN</code>以外的数据正确排序，<code>NaN</code>的个数保持不变。</p><p>本代码中利用<code>var != var</code>判定是否是<code>NAN</code>，若是<code>NAN</code>则在比较的时候当作极小值。</p><h2 id="c-可以独立运行的源代码"><a href="#c-可以独立运行的源代码" class="headerlink" title="c)可以独立运行的源代码"></a>c)可以独立运行的源代码</h2><p><strong>源文件:</strong><code>BitonicSort.cpp</code></p><p>见附件。</p><h2 id="d-测试数据"><a href="#d-测试数据" class="headerlink" title="d)测试数据"></a>d)测试数据</h2><p>测试数据1：样例输入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> data[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">0.8</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.5</span> &#125;;<br><span class="hljs-type">int</span> seg_id[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span> &#125;;<br><span class="hljs-type">int</span> seg_start[<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span> &#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> m = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/res1.48o6fht4dd80.webp" alt="res1"></p><p>测试数据2：加入<code>sqrt(-1.f)</code>测试鲁棒性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> data[<span class="hljs-number">12</span>] = &#123; <span class="hljs-number">0.1</span>, <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>), <span class="hljs-number">0.5</span> ,<span class="hljs-number">0.7</span>,<span class="hljs-number">0.9</span>,<span class="hljs-number">0.8</span>,<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>),<span class="hljs-number">0.2</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.6</span>,<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>),<span class="hljs-number">0.0</span> &#125;;<br><span class="hljs-type">int</span> seg_id[<span class="hljs-number">12</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-type">int</span> seg_start[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span> &#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-number">12</span>;<br><span class="hljs-type">int</span> m = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/res2.4hfnnum033i0.webp" alt="res2"></p><p>测试数据3：大部分为<code>NAN</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> data[<span class="hljs-number">8</span>] = &#123; <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>),<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>),<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>),<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>),<span class="hljs-number">0.1</span>,<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>),<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>),<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>) &#125;;<br><span class="hljs-type">int</span> seg_id[<span class="hljs-number">8</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-type">int</span> seg_start[<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span> &#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> m = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/res3.6nlnrg4p8nc0.webp" alt="res3"></p><h2 id="e-性能分析"><a href="#e-性能分析" class="headerlink" title="e)性能分析"></a>e)性能分析</h2><p>具有<code>2^n</code>长度数据的双调排序的时间复杂度为<code>O(n(logn)^2)</code>。</p><p>当数组长度<code>n</code>为任意数字时需要补齐到<code>2</code>的幂次方，这个对于任意<code>n</code>的新排序网络可以嵌入原始的对于<code>2^k</code>的双调排序网络。因此，它仍有 <code>log(n)*(log(n)+1)/2</code> 层，每层最多比较<code>n/2</code>次，结果仍然是一个复杂度为<code>O(nlog(n)^2)</code>的比较器，跟原始的双调排序网络无区别。</p><p>此外由于已经具备了可并行性，引入<code>openmp</code>等并行框架可以提升执行效率，在此由于时间原因未加入。</p><h2 id="f-测试的起始和完成时间以及实际使用的时间"><a href="#f-测试的起始和完成时间以及实际使用的时间" class="headerlink" title="f)测试的起始和完成时间以及实际使用的时间"></a>f)测试的起始和完成时间以及实际使用的时间</h2><p>起始时间：<code>2022-9-9 15:40</code></p><p>完成时间：<code>2022-9-9 23:50</code></p><p>期间除去吃饭、洗澡等事务实际使用的时间约为8小时，花费了约5小时进行算法学习、资料查找、加分挑战实现以及调试等，约3小时进行解题报告文档撰写。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://blog.csdn.net/xbinworld/article/details/76408595">三十分钟理解：双调排序Bitonic Sort，适合并行计算的排序算法</a></p><p>主要参考了其中内容进行了算法理解和描述。</p></li><li><p><a href="https://en.wikipedia.org/wiki/Bitonic_sorter">Wiki pedia: Bitonic sorter</a></p><p>主要参考了其中的算法描述和并行结构写法。</p></li><li><p><a href="http://www.tools-of-computing.com/tc/CS/Sorts/bitonic_sort.htm">Bitonic Sort</a></p><p>主要参考其中对于算法并行化改进的描述以及并行结构写法。</p></li><li><p><a href="https://blog.huangjunqin.com/2017/08/19/segmentedBitonicSort/">分段双调排序算法 - 黄俊钦</a></p><p>是曾经做过这项测试的同学的解题博客，在基本完成代码编写后参考了其中的文档结构，并补充了合法性检查以及数组边界设置。</p></li><li><p>各类有关并行计算和位运算的资料若干</p></li></ul><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://github.com/thunderbolt215/Bitonic-Sort">https://github.com/thunderbolt215/Bitonic-Sort</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>降维观测器</title>
    <link href="/2022/04/06/%E9%99%8D%E7%BB%B4%E8%A7%82%E6%B5%8B%E5%99%A8/"/>
    <url>/2022/04/06/%E9%99%8D%E7%BB%B4%E8%A7%82%E6%B5%8B%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="降维观测器简介"><a href="#降维观测器简介" class="headerlink" title="降维观测器简介"></a>降维观测器简介</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>对于系统</p><script type="math/tex; mode=display">\dot{x}=Ax+Bu \\y=Cx</script><p>假设其中x的维数为n，y的维数为m。</p><p>全维观测器对全部变量x进行重构。但是如果状态的某些线性组合可以直接作为输出被测量出来(这由矩阵C决定)，就不需要进行估计，则可以降低其维数，仅需要额外获得n-m个维度的信息，之后配合观测得到的m个维度的信息，通过线性组合，就可以获得状态x的信息，由此引入降维观测器。</p><p>若C矩阵秩为m，则只需要重构余下的n-m个状态分量。</p><span id="more"></span><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给定线性系统$\sum(A,B,C):$</p><script type="math/tex; mode=display">\dot{x}=Ax+Bu \\y=Cx</script><p>其中C为$m\times n$矩阵，假定$rank(C)=m$，则一定存在线性变换</p><script type="math/tex; mode=display">\overline{x}=Tx,where\space T=[D\space C]^T</script><p>其中D为使得$T^{-1}$存在的任意$(n-m)\times n$阵。</p><p>通过这一线性变换，系统变换为：</p><script type="math/tex; mode=display">\dot{\overline{x} }=TAT^{-1}\overline{x}+TBu \\y=CT^{-1}\overline{x}=[0\space I_m][\overline{x}_1\space \overline{x}_2]^T=\overline{x}_2</script><p>其中$\overline{x}_2$为m维，可以直接量测，因此只需要观测$(n-m)$维状态变量$\overline{x}_1$。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>为避免输出量的微分，重新定义观测器的状态</p><script type="math/tex; mode=display">令W=\hat{x}_1+M_1\dot{y} \\=(A_{11}+M_1A_{21})w+(B_1+M_1B_2)u+ \\ (A_{12}+M_1A{22}-(A_{11}+M_1A_{21})M_1)y \\=(A_{11}+M_1A_{21})w+B_0u+Ey \\其中 \\B_0=B_1+M_1B_2 \\E=A_{12}+M_1A_{22}-(A_{11}+M_1A_{21})M_1 \\</script><p>上述称为Luenberger观测器。</p><p>由此得到原系统的状态重构：</p><script type="math/tex; mode=display">\hat{x}=\left[\matrix{  \hat{x} \\  y \\}\right]=\left[\matrix{  w-M_1 y \\  y \\}\right]=\left[\matrix{  I \\  0 \\}\right]w+\left[\matrix{  -M_1 \\  I \\}\right]y</script><h2 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h2><p>降维观测器的测量值y通过$M_1$直接反映在状态$\hat{x}_1$上，如图所示：</p><p><img src="https://s2.loli.net/2022/04/06/A2aGVTJFpSro4bB.png" alt="image-20220406100227560"></p><p>这样会将测量噪声带入，使得$M_1$的误差直接影响到$\hat{x}_1$稳态值，在全维观测器中则不存在这种误差。</p>]]></content>
    
    
    <categories>
      
      <category>Control</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Control</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kalman Filter</title>
    <link href="/2022/04/01/Kalman-Filter/"/>
    <url>/2022/04/01/Kalman-Filter/</url>
    
    <content type="html"><![CDATA[<h1 id="Kalman滤波算法简介"><a href="#Kalman滤波算法简介" class="headerlink" title="Kalman滤波算法简介"></a>Kalman滤波算法简介</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>卡尔曼滤波（也称为线性二次型估计），是一种最优化自回归数据处理算法，它的主要功能是：从一系列不完全且包含噪声的数据测量值序列中，估计出动态系统的状态。由于其效率高且所占空间较小，在雷达、计算机视觉、机器人导航等很多工程应用领域中都有应用。</p><p>卡尔曼滤波的一个典型实例是：现在有一组有限时间内、包含噪声的数据，记录了物体运动中若干时刻的位置和速度，通过卡尔曼滤波算法可以根据这些数据预测出物体不同时刻的位置以及速度。</p><p><img src="https://s2.loli.net/2022/04/01/VrKt98wXmGWlsJi.png" alt="image-20220401212609431"></p><span id="more"></span><h2 id="约定及说明"><a href="#约定及说明" class="headerlink" title="约定及说明"></a>约定及说明</h2><h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><p>卡尔曼滤波适合于<strong>线性系统</strong>，且要求误差满足<strong>高斯分布</strong>。</p><h3 id="状态空间表达式"><a href="#状态空间表达式" class="headerlink" title="状态空间表达式"></a>状态空间表达式</h3><p>本文中状态空间方程定义如下：</p><h4 id="状态方程"><a href="#状态方程" class="headerlink" title="状态方程"></a>状态方程</h4><script type="math/tex; mode=display">x_k=Ax_{k-1}+Bu_k+w_k</script><p>表示了由上一状态到当前状态的转移关系。其中$x_k$表示当前时刻状态量，$u_k$表示当前时刻输入量，A,B均为系数矩阵，$w_k$为<strong>过程噪声</strong>(即真实的运动与理论方程所不相符的部分)。</p><h4 id="观测方程"><a href="#观测方程" class="headerlink" title="观测方程"></a>观测方程</h4><script type="math/tex; mode=display">y_k=Cx_k+v_k</script><p>表示了当前时刻观测量的计算方式。其中$y_k$表示当前时刻的观测量，C为系数矩阵，$x_k$含义不变，$v_k$表示<strong>观测噪声</strong>(即由于观测仪器引起的噪声，如传感器带来的误差波动)。</p><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>上述噪声$w_k$和$v_k$均符合高斯分布，为高斯白噪声，即</p><script type="math/tex; mode=display">w_k \sim N(0;Q_k) \\v_k \sim N(0;R_k)</script><p><img src="https://s2.loli.net/2022/04/01/9KyuJGZdsEcfeNR.png" alt="image-20220401214819864"></p><p>约定：</p><script type="math/tex; mode=display">\hat{x}_{k}代表最优估计值 \\\hat{x}_{k}^-先验估计值(预测值) \\x_k观测值</script><h2 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h2><h3 id="宏观理解"><a href="#宏观理解" class="headerlink" title="宏观理解"></a>宏观理解</h3><p>卡尔曼滤波算法的实现过程是：使用上一次的最优结果（即先验估计值）预测当前的值，同时使用观测值（如通过传感器获得的数据）修正当前值，得到最优结果。</p><p>图解：</p><p><img src="https://s2.loli.net/2022/04/01/JnDyqAz5bcldRhs.png" alt="image-20220401215455064"></p><h3 id="具体公式"><a href="#具体公式" class="headerlink" title="具体公式"></a>具体公式</h3><p>本部分先逐个介绍各个公式的含义，最后再统一说明他们之间的关系。</p><h4 id="预测部分"><a href="#预测部分" class="headerlink" title="预测部分"></a>预测部分</h4><h5 id="先验估计"><a href="#先验估计" class="headerlink" title="先验估计"></a>先验估计</h5><script type="math/tex; mode=display">\hat{x}_t^- = F\hat{x-1} + Bu_{t-1}</script><p>仍考虑第一部分中提到的小车的例子，假定小车做匀加速直线运动：</p><p><img src="https://s2.loli.net/2022/04/01/G2Of8FBMZResJou.png" alt="image-20220401220002938">        预测模型可以写成</p><script type="math/tex; mode=display">P_i=P_{i-1}+v_{i-1}\Delta t+\frac{a}{2}\Delta t^2 \\v_i=v_{i-1}+a\Delta t</script><p>写成矩阵形式为</p><script type="math/tex; mode=display">\left[\matrix{  p_i  \\  v_i   }\right]=\left[\matrix{  1 & \Delta t \\  0 & 1  }\right]\left[\matrix{  p_{i-1}  \\  v_{i-1}   }\right]+\left[\matrix{  \frac{1}{2}\Delta t^2  \\  \Delta t  }\right]a_i</script><p>则已经化成了上面先验估计方程的形式。</p><h5 id="先验估计协方差"><a href="#先验估计协方差" class="headerlink" title="先验估计协方差"></a>先验估计协方差</h5><script type="math/tex; mode=display">P_t^-=FP_{t-1}F^T+Q</script><p>可根据先验估计方程推导，如下：</p><script type="math/tex; mode=display">根据协方差计算公式： \\cov(Ax+k,Ax+k)=Acov(x,x)A^T \\先验过程中补上过程噪声：\\\hat{x}_t^-=F\hat{x}_{t-1}+Bu_{t-1}+w_t \\\begin{align*}\Rightarrow P_t^- &=cov(\hat{x}_t^-,\hat{x}_t^-) \\&= cov(F\hat{x}_{t-1}+Bu_{t-1}+w_t,F\hat{x}_{t-1}+Bu_{t-1}+w_t) \\&= Fcov(\hat{x}_{t-1},\hat{x}_{t-1})F^T+cov(w_t,w_t) \\&= FP_{t-1}F^T+Q\end{align*}</script><h5 id="测量方程"><a href="#测量方程" class="headerlink" title="测量方程"></a>测量方程</h5><script type="math/tex; mode=display">z_t=Hx_t+V</script><p>沿用上面小车的例子，这里的测量方程可以写为</p><script type="math/tex; mode=display">z_P=P_t+\Delta P_t \\z_v=0 \\\Rightarrow\left[\matrix{  z_P  \\  z_v   }\right]=\left[\matrix{  1 & 0   }\right]\left[\matrix{  p_t  \\  v_t  }\right]+\left[\matrix{  1 & 0   }\right]\left[\matrix{  \Delta p_t  \\  \Delta v_t  }\right]</script><p>注意：<strong>$z_t$的维数未必与$\hat{x}_t$相同</strong></p><h4 id="状态更新部分"><a href="#状态更新部分" class="headerlink" title="状态更新部分"></a>状态更新部分</h4><h5 id="修正估计"><a href="#修正估计" class="headerlink" title="修正估计"></a>修正估计</h5><script type="math/tex; mode=display">\hat{x}_t=\hat{x}_t^-+K_t(z_t-H\hat{x}_t^-)</script><p>可以根据需求调整$K_t$的大小（如：更信任观测值还是估计值）</p><h5 id="卡尔曼增益"><a href="#卡尔曼增益" class="headerlink" title="卡尔曼增益"></a>卡尔曼增益</h5><script type="math/tex; mode=display">K_t=\frac{P_t^-H^T}{HP_t^-H^T+R}</script><p>一维情况下(F=1,H=1)可以化简为</p><script type="math/tex; mode=display">K_t=\frac{P_{t-1}+Q}{P_{t-1}+Q+R}</script><h5 id="更新后验估计协方差"><a href="#更新后验估计协方差" class="headerlink" title="更新后验估计协方差"></a>更新后验估计协方差</h5><script type="math/tex; mode=display">P_t=(I-K_tH)P_t^-</script><h4 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h4><p><img src="https://s2.loli.net/2022/04/01/6fPISNbgkZMAnuF.png" alt="image-20220401221540966"></p><h3 id="信号流图（转载）"><a href="#信号流图（转载）" class="headerlink" title="信号流图（转载）"></a>信号流图（转载）</h3><p><img src="https://s2.loli.net/2022/04/01/fpDdjO3LmWPV19X.jpg" alt="img"></p><h2 id="实例：小车匀加速运动"><a href="#实例：小车匀加速运动" class="headerlink" title="实例：小车匀加速运动"></a>实例：小车匀加速运动</h2><p>我们将上面所述的实例代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 说明</span><br><span class="hljs-comment">% 模型：匀加速运动</span><br><span class="hljs-comment">% x_optimal 最优估计值</span><br><span class="hljs-comment">% x_observe 观测值</span><br><span class="hljs-comment">% x_predict 先验估计值（预测值）</span><br><br>total = <span class="hljs-number">300</span>;<br>delta = <span class="hljs-number">0.1</span>;<br>x_observe(<span class="hljs-number">1</span>) = <span class="hljs-number">0</span>;<br>w = <span class="hljs-built_in">randn</span>(<span class="hljs-number">1</span>, total);<br>Q = (std(w)).^<span class="hljs-number">2</span>;<br>v = <span class="hljs-built_in">randn</span>(<span class="hljs-number">1</span>, total);<br>R = (std(v)).^<span class="hljs-number">2</span>;<br>a = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span> n = <span class="hljs-number">2</span>:total<br>    REF(n) = <span class="hljs-number">1</span>/<span class="hljs-number">2</span>*a*(n*delta).^<span class="hljs-number">2</span>;<br>    x_observe(n) = x_observe(n<span class="hljs-number">-1</span>) + a*(n<span class="hljs-number">-1</span>/<span class="hljs-number">2</span>)*delta.^<span class="hljs-number">2</span>  + w(n);<br>    y(n) = x_observe(n) + v(n);<br><span class="hljs-keyword">end</span><br><br>p_observe(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span>;  <br>x_optimal(<span class="hljs-number">1</span>) = <span class="hljs-number">0</span>;  <br><span class="hljs-keyword">for</span> n = <span class="hljs-number">2</span>:total<br>    <span class="hljs-comment">% 预测</span><br>    x_predict(n) = x_optimal(n<span class="hljs-number">-1</span>) + a*(n<span class="hljs-number">-1</span>/<span class="hljs-number">2</span>)*delta.^<span class="hljs-number">2</span>;<br>    p_predict(n) = p_observe(n<span class="hljs-number">-1</span>) + Q;<br>    <span class="hljs-comment">% 更新</span><br>    k(n) = p_predict(n) / (p_predict(n) + R);<br>    x_optimal(n) = x_predict(n) + k(n) * (y(n) - x_predict(n))<br>    p_observe(n) = (<span class="hljs-number">1</span> - k(n))*p_predict(n); <br><span class="hljs-keyword">end</span><br><br>n = <span class="hljs-number">1</span>:total;<br><span class="hljs-built_in">plot</span>(n, x_optimal, <span class="hljs-string">&#x27;r&#x27;</span>, n ,y, <span class="hljs-string">&#x27;g&#x27;</span>, n, REF, <span class="hljs-string">&#x27;b&#x27;</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;最优估计值&#x27;</span>, <span class="hljs-string">&#x27;实际观测值&#x27;</span>, <span class="hljs-string">&quot;理论值&quot;</span>)<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://s2.loli.net/2022/04/02/7OUPCQlzW6dREhg.jpg" alt=""></p><p><img src="https://s2.loli.net/2022/04/02/HuKPfpjh6TkEXwA.jpg" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Control</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Control</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPMV L4 Camera Calibration</title>
    <link href="/2022/03/27/IPMV-L4-Camera-Calibration/"/>
    <url>/2022/03/27/IPMV-L4-Camera-Calibration/</url>
    
    <content type="html"><![CDATA[<h1 id="04-Camera-Calibration"><a href="#04-Camera-Calibration" class="headerlink" title="04. Camera Calibration"></a>04. Camera Calibration</h1><h2 id="WCS-CCS-IPCS-PCS"><a href="#WCS-CCS-IPCS-PCS" class="headerlink" title="WCS. CCS. IPCS. PCS"></a>WCS. CCS. IPCS. PCS</h2><h3 id="坐标系变换关系汇总"><a href="#坐标系变换关系汇总" class="headerlink" title="坐标系变换关系汇总"></a>坐标系变换关系汇总</h3><p>WCS: World Coordinate System$(X^W,Y^W,Z^W)$</p><p>CCS: Camera Coordinate System$(X^C,Y^C,Z^C)$</p><p>IPCS/FCS: Image Plane Coordinate System/Film Coordinate System $(x,y)$</p><p>PCS: Pixel Coordinate System$(u,v)$</p><script type="math/tex; mode=display">WCS\leftrightarrow CCS\leftrightarrow IPCS\leftrightarrow PCS</script><span id="more"></span><p><img src="https://s2.loli.net/2022/03/27/vWAy7DkO9FI8lRN.png" alt="image-20220327215625379"></p><p><img src="https://s2.loli.net/2022/03/27/VcITkGpqD6OYjex.png" alt="image-20220327220812537"></p><h3 id="补充1：不同旋转平移方式"><a href="#补充1：不同旋转平移方式" class="headerlink" title="补充1：不同旋转平移方式"></a>补充1：不同旋转平移方式</h3><p><img src="https://s2.loli.net/2022/03/27/Uf9QO8XVSogTzFk.png" alt="image-20220327220020765"></p><h3 id="补充2：偏斜系数-skew-coefficient"><a href="#补充2：偏斜系数-skew-coefficient" class="headerlink" title="补充2：偏斜系数(skew coefficient)"></a>补充2：偏斜系数(skew coefficient)</h3><p><img src="https://s2.loli.net/2022/03/27/5yuzcZKhnESseCB.png" alt="image-20220327221019507"></p><h2 id="Affine-transformation"><a href="#Affine-transformation" class="headerlink" title="Affine transformation"></a>Affine transformation</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>通俗解释及动画演示参考：<a href="https://www.matongxue.com/madocs/244/">https://www.matongxue.com/madocs/244/</a></p><p><strong>Affine transformation = Linear transformation + Translation</strong></p><p>Linear transformation:</p><ul><li>变换前是直线的，变换后依然是直线</li><li>直线比例保持不变</li><li>变换前是原点的，变换后依然是原点</li></ul><p>Affine translation:</p><ul><li>变换前是直线的，变换后依然是直线</li><li>直线比例保持不变</li></ul><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p><img src="https://s2.loli.net/2022/03/27/k1ZGfj9FhzcAQiS.png" alt="image-20220327222707615"></p><p><img src="https://s2.loli.net/2022/03/27/Czxt7oNIHdKwYka.png" alt="image-20220327222833156"></p><p><img src="https://s2.loli.net/2022/03/27/nMoYiRHgPJ8leGd.png" alt="image-20220327222735348"></p><p><img src="https://s2.loli.net/2022/03/27/6caKyoe52UASF8h.png" alt="image-20220327222803966"></p><p><img src="https://s2.loli.net/2022/03/27/EtlY7dZcxVf51Lm.png" alt="image-20220327222812465"></p><h2 id="Homogeneous-Coordinates进一步理解"><a href="#Homogeneous-Coordinates进一步理解" class="headerlink" title="Homogeneous Coordinates进一步理解"></a>Homogeneous Coordinates进一步理解</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><strong>Homogeneous coordinates</strong>(Projective coordinates)$\leftrightarrow$<strong>Projective Geometry</strong></p><p>(类比:<strong>Cartesian coordinates</strong>$\leftrightarrow$<strong>Euclidean Geometry</strong>)</p><p>齐次坐标空间与普通坐标空间不同！</p><p><strong>Advantages</strong>: coordinates of points(including$\infty$) can be represented using finite coordinates</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p>Determine the line passing through a(2,0) and b(1,3).</p><p>转化为齐次坐标，作外积得到的向量三个分量即为直线方程的系数A,B,C.</p><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><p><img src="https://s2.loli.net/2022/03/27/O5PJGtvLVsFMR93.png" alt="image-20220327224923394"></p><h2 id="Vanishing-Point-消失点"><a href="#Vanishing-Point-消失点" class="headerlink" title="Vanishing Point(消失点)"></a>Vanishing Point(消失点)</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><p>2D perspective projections of mutually parallel in 3D space appear to converge.</p><p><img src="https://s2.loli.net/2022/03/27/PxYCygLRlX5eUam.png" alt="image-20220327225133290"></p><h3 id="Example1"><a href="#Example1" class="headerlink" title="Example1"></a>Example1</h3><p><img src="https://s2.loli.net/2022/03/27/vFHR8kPdDYBlhVO.png" alt="image-20220327230026540"></p><h3 id="Example-2-1"><a href="#Example-2-1" class="headerlink" title="Example 2"></a>Example 2</h3><p>How many vanishing points are there in the picture?</p><p><img src="https://s2.loli.net/2022/03/27/8I6jMyWYzCbPLwJ.png" alt="image-20220327230112716"></p><p>Ans: $\infty$</p><p><img src="https://s2.loli.net/2022/03/27/cAMYwS2fZ4kqC65.png" alt="image-20220327230243681"></p><h2 id="Lens-distortion"><a href="#Lens-distortion" class="headerlink" title="Lens distortion"></a>Lens distortion</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Deform the physically straight lines and makes them appear as curves in the images.</p><h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><h4 id="1-Radial-distortion-径向"><a href="#1-Radial-distortion-径向" class="headerlink" title="1. Radial distortion(径向)"></a>1. Radial distortion(径向)</h4><p>Reason: <strong>Lens’ geometric shape</strong> affects the straight line transformation.</p><p><img src="https://s2.loli.net/2022/03/27/zYVEoIcu3XjSnmf.png" alt="image-20220327231433108"></p><h4 id="2-Tangential-distortion-横向"><a href="#2-Tangential-distortion-横向" class="headerlink" title="2. Tangential distortion(横向)"></a>2. Tangential distortion(横向)</h4><p>Reason: Lens installed in front of the camera is not perfectly parallel to the image plane.</p><p>In practical experiments, the image geometry is affected to a much higher extent with <strong>radial distortion</strong> than with tangential distortion(<strong>sometimes neglected</strong>).</p><h3 id="Radial-distortion"><a href="#Radial-distortion" class="headerlink" title="Radial distortion"></a>Radial distortion</h3><h4 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h4><p><img src="https://s2.loli.net/2022/03/27/zCj1sncUGVgOPKZ.png" alt="image-20220327232506152"></p><h4 id="Calculation"><a href="#Calculation" class="headerlink" title="Calculation"></a>Calculation</h4><script type="math/tex; mode=display">x_{undist}=x_{dist}(1+k_1r^2+k_2r^4+k_3r^6) \\y_{undist}=y_{dist}(1+k_1r^2+k_2r^4+k_3r^6) \\where \\x_{dist}=\frac{x_c}{z_c}=\frac{u-u_o}{f_x} \\y_{dist}=\frac{y_c}{z_c}=\frac{v-v_o}{f_y} \\r^2=x_{dist}^2+y_{dist}^2 \\</script><p>​                                            $k_1,k_2,k_3$ are 3 intrinsic parameters used for radial distortion correction.</p><script type="math/tex; mode=display">P_{dist}=[x_{dist},y_{dist}]^T\rightarrow P_{undist}=[x_{undist},y_{undist}]^T</script><h3 id="Tangential-Distortion"><a href="#Tangential-Distortion" class="headerlink" title="Tangential Distortion"></a>Tangential Distortion</h3><p><img src="https://s2.loli.net/2022/03/28/wcLnq6eAzblNxvM.png" alt="image-20220328092312774"></p><h2 id="Camera-Calibration"><a href="#Camera-Calibration" class="headerlink" title="Camera Calibration"></a>Camera Calibration</h2><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p>Process of <strong>estimating camera parameters</strong> by <strong>using images that contain a calibration pattern</strong>. </p><p>Camera parameters includes:</p><ul><li>Intrinsic matrix</li><li>Distortion coefficients</li><li>Extrinsic matrix</li></ul><p>Applications:</p><ul><li>Remove lens distortion</li><li>Measure planar objects</li><li>Reconstruct 3D scenes from multiple cameras</li></ul><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><h4 id="Step-1-Define-real-world-coordinates-with-checkerboard-pattern"><a href="#Step-1-Define-real-world-coordinates-with-checkerboard-pattern" class="headerlink" title="Step 1. Define real world coordinates with checkerboard pattern."></a>Step 1. Define real world coordinates with checkerboard pattern.</h4><p><img src="https://s2.loli.net/2022/03/28/MV1zRuhYBs8GHS3.png" alt="image-20220328093327268"></p><h4 id="Step-2-Capture-multiple-images-of-the-checkerboard-from-different-viewpoints"><a href="#Step-2-Capture-multiple-images-of-the-checkerboard-from-different-viewpoints" class="headerlink" title="Step 2. Capture multiple images of the checkerboard from different viewpoints."></a>Step 2. Capture multiple images of the checkerboard from different viewpoints.</h4><p><img src="https://s2.loli.net/2022/03/28/fU5CAMmRslitGgp.png" alt="image-20220328093441682"></p><h4 id="Step-3-Find-2D-coordinates-of-the-checkerboard"><a href="#Step-3-Find-2D-coordinates-of-the-checkerboard" class="headerlink" title="Step 3. Find 2D coordinates of the checkerboard."></a>Step 3. Find 2D coordinates of the checkerboard.</h4><p><img src="https://s2.loli.net/2022/03/28/dsTGpbL1Ofz5rj8.png" alt="image-20220328093533228"></p><h4 id="Step-4-Calibrate-the-camera"><a href="#Step-4-Calibrate-the-camera" class="headerlink" title="Step 4. Calibrate the camera."></a>Step 4. Calibrate the camera.</h4><p><img src="https://s2.loli.net/2022/03/28/ZCIYJsixmn67Azt.png" alt="image-20220328093610674"></p><center>Left: Camera-centric</center><center>Right: Pattern-centric </center><h4 id="Step-5-Compute-the-re-projection-error-and-refine-精制，提炼-the-calibration"><a href="#Step-5-Compute-the-re-projection-error-and-refine-精制，提炼-the-calibration" class="headerlink" title="Step 5. Compute the re-projection error and refine(精制，提炼) the calibration."></a>Step 5. Compute the re-projection error and refine(精制，提炼) the calibration.</h4><p><img src="https://s2.loli.net/2022/03/28/eOqPHZUGk4CIasm.png" alt="image-20220328093812637"></p><h3 id="Re-projection-error"><a href="#Re-projection-error" class="headerlink" title="Re-projection error"></a>Re-projection error</h3><p><img src="https://s2.loli.net/2022/03/28/dWki3y89ojaAIhm.png" alt="image-20220328094401951"></p><p><img src="https://s2.loli.net/2022/03/28/LoSGP5Kz4yAaVhc.png" alt="image-20220328094451821"></p>]]></content>
    
    
    <categories>
      
      <category>IPMV courses</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPMV lecture3 Perspective Transformation</title>
    <link href="/2022/03/08/IPMV-L3-Perspective-Transformation/"/>
    <url>/2022/03/08/IPMV-L3-Perspective-Transformation/</url>
    
    <content type="html"><![CDATA[<h1 id="03-Perspective-Transformation"><a href="#03-Perspective-Transformation" class="headerlink" title="03. Perspective Transformation"></a>03. Perspective Transformation</h1><h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><h3 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h3><h4 id="l-p-Norm-p范数"><a href="#l-p-Norm-p范数" class="headerlink" title="$l_p$-Norm (p范数)"></a>$l_p$-Norm (p范数)</h4><script type="math/tex; mode=display">||a||_p=(\sum_{k=1}^n |a_k|^p)^\frac{1}{p}</script><h4 id="Infinity-Norm-无穷范数"><a href="#Infinity-Norm-无穷范数" class="headerlink" title="Infinity Norm (无穷范数)"></a>Infinity Norm (无穷范数)</h4><script type="math/tex; mode=display">||a||_{+\infty}=\max_i |x_i| \\||a||_{-\infty}=\min_i |x_i|</script><span id="more"></span><p>证明：令</p><script type="math/tex; mode=display">a_{max}=max(|x_1|,|x_2|,...,|x_n|) \\\Rightarrow ||a||_p=a_{max}(\sum_{k=1}^n (\frac{|a_k|}{a_{max}})^p)^\frac{1}{p}</script><p>又</p><script type="math/tex; mode=display">1\leq \sum_{k=1}^n(\frac{|a_k|}{a_{max}})^p\leq n \\\Rightarrow 1^{\frac{1}{p}}\leq (\sum_{k=1}^n(\frac{|a_k|}{a_{max}})^p)^{\frac{1}{p}}\leq n^{\frac{1}{p}}</script><p>根据夹逼定理(Squeeze Theorem)</p><script type="math/tex; mode=display">\lim_{p\rightarrow\infty}||a||_p=\lim_{p\rightarrow\infty} a_{max}(\sum_{k=1}^n (\frac{|a_k|}{a_{max}})^p)^\frac{1}{p}=a_{max}</script><p>Q.E.D.</p><h3 id="斜对称矩阵-skew-symmetric-matrix"><a href="#斜对称矩阵-skew-symmetric-matrix" class="headerlink" title="斜对称矩阵(skew-symmetric matrix)"></a>斜对称矩阵(skew-symmetric matrix)</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>如果一个矩阵A是方阵，并且满足</p><script type="math/tex; mode=display">A^T=-A</script><p>则为斜对称矩阵。</p><p>例如：</p><script type="math/tex; mode=display">a=\left[\matrix{  a_1  \\  a_2  \\  a_3 }\right]</script><p>的斜对称矩阵为</p><script type="math/tex; mode=display">[a]_X=\left[\matrix{0 & -a_3 & a_2 \\a_3 & 0 & -a_1 \\-a_2 & a_1 & 0}\right]</script><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>1.基于定义</p><script type="math/tex; mode=display">[a]_X=-[a]_X^T</script><p>2.<strong>消消乐性质</strong>(自己和自己的外积=0)</p><script type="math/tex; mode=display">a^T[a]_X=0^T \\ [a]_Xa=0</script><p>3.叉积</p><script type="math/tex; mode=display">a\crossproduct b=[a]_Xb=-[b]_Xa</script><p>4.【还不会证明】</p><script type="math/tex; mode=display">det([a]_X^T)=(-1)^n det{[a]_X}</script><h3 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h3><h4 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h4><p>沿着三根轴旋转的旋转矩阵依次为</p><script type="math/tex; mode=display">[R]_\theta=\left[\matrix{cos\theta & sin\theta & 0 \\-sin\theta & cos\theta & 0 \\0 & 0 & 1}\right]</script><script type="math/tex; mode=display">[R]_\phi=\left[\matrix{1 & 0 & 0 \\0 & cos\phi & sin\phi \\0 & -sin\phi & cos\phi}\right]</script><script type="math/tex; mode=display">[R]_\Phi=\left[\matrix{-sin\Phi & 0 & cos\Phi \\0 & 1 & 0 \\cos\Phi & 0 & sin\Phi}\right]</script><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><script type="math/tex; mode=display">RR^T=I \\R^TR=I \\|det(R)|=1</script><p>所有旋转矩阵组成的群称为<strong>特殊正交群(special orthogonal group, SO3)</strong></p><h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>以下讨论中标量(scalar)表示：</p><script type="math/tex; mode=display">x</script><p>向量(Vector)表示：</p><script type="math/tex; mode=display">y=[y_1,y_2,...,y_m]^T</script><p>矩阵(Matrix)表示(懒，没有手打)：</p><p><img src="https://s2.loli.net/2022/03/27/U6tOaKjynPDqBWE.png" alt="image-20220327203450843"></p><p>各种求导的表示：</p><p>【待填坑】</p><h2 id="WCS-vs-CCS"><a href="#WCS-vs-CCS" class="headerlink" title="WCS vs. CCS"></a>WCS vs. CCS</h2><p>WCS(World Coordinate System)可以位于任何位置</p><p>CCS(Camera Coordinate System)必须设置在相机光心</p><p><img src="https://s2.loli.net/2022/03/27/j3GQ5i4PUlYoWp9.png" alt="image-20220327204022068"></p><p>变换关系：</p><script type="math/tex; mode=display">p_i^C=Rp_i^W+t</script><p>齐次坐标形式：</p><p><img src="https://s2.loli.net/2022/03/27/TCBovaF3kDuMlRt.png" alt="image-20220327204128088"></p><p><strong>special Euclidean group</strong>(SE3): The group containing all homogeneous transformation matrices.</p><h2 id="Pinhole-camera-model"><a href="#Pinhole-camera-model" class="headerlink" title="Pinhole camera model"></a>Pinhole camera model</h2><p><img src="https://s2.loli.net/2022/03/14/vqywfTEZB49HgKC.png" alt="image-20220314213506296"></p><p><img src="https://s2.loli.net/2022/03/27/WrYIKbByaq9QTFC.png" alt="image-20220327205301847"></p><p>IPCS系中的坐标</p><script type="math/tex; mode=display">\overline{p}=[x_i,y_i,f]^T</script><p>重要关系</p><script type="math/tex; mode=display">\overline{p}=f\widehat{p}^C=\frac{f}{z_i^C}p^C</script><p>其中</p><script type="math/tex; mode=display">\widehat{p}^C=[\frac{x_i^C}{z_i^C},\frac{y_i^C}{z_i^C},1]^T</script><p>是$p^C$的归一化表示(normalized).</p><h2 id="Intrinsic-matrix"><a href="#Intrinsic-matrix" class="headerlink" title="Intrinsic matrix"></a>Intrinsic matrix</h2><p>意义：连接<strong>image plane coordinate system</strong> &amp;&amp; <strong>pixel coordinate system</strong></p><script type="math/tex; mode=display">IPCS(x,y)\leftrightarrow PCS(u,v)</script><p><strong>Lens distortion does not exist in a perspective camera model</strong>.</p><h3 id="变换关系"><a href="#变换关系" class="headerlink" title="变换关系"></a>变换关系</h3><p><img src="https://s2.loli.net/2022/03/27/n4G7zZXCvK26YIp.png" alt="image-20220327210634917"></p><p>引入</p><p>$s_x,s_y$:effective size measured (in pixels per millimeter) in the horizontal and vertical directions, respectively.</p><script type="math/tex; mode=display">f_x=fs_x \\f_y=fs_y \\x_i=f\frac{x_i^C}{z_i^C} \\y_i=f\frac{y_i^C}{z_i^C}</script><p>可得</p><script type="math/tex; mode=display">u_i=u_o+s_x x_i \\v_i=v_o+s_y y_i</script><p>最终表达式</p><p><img src="https://s2.loli.net/2022/03/27/tqWVJy2gCcOu5kU.png" alt="image-20220327212615708"></p><p>或表达为</p><script type="math/tex; mode=display">\widetilde{p}=\frac{1}{z_i^C}Kp^C</script><p>说明：</p><p>1.$\widetilde{p}=[u_i,v_i,1]^T$是$p=[u_i,v_i]^T$的齐次坐标</p><p>2.intrinsic parameters:$u_o,v_o,f,s_x,s_y$</p><p>3.Intrinsic Matrix</p><p><img src="https://s2.loli.net/2022/03/27/DJd1v2ZxYj5CuaE.png" alt="image-20220327213004948"></p>]]></content>
    
    
    <categories>
      
      <category>IPMV courses</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-Ray-Tracing-Path Tracing-L16</title>
    <link href="/2022/03/06/Games101-Ray-Tracing-Path-Tracing-L16/"/>
    <url>/2022/03/06/Games101-Ray-Tracing-Path-Tracing-L16/</url>
    
    <content type="html"><![CDATA[<h1 id="Ray-Tracing-Path-Tracing"><a href="#Ray-Tracing-Path-Tracing" class="headerlink" title="Ray Tracing-Path Tracing"></a>Ray Tracing-Path Tracing</h1><h2 id="Monte-Carlo-Integration"><a href="#Monte-Carlo-Integration" class="headerlink" title="Monte Carlo Integration"></a>Monte Carlo Integration</h2><p><img src="https://s2.loli.net/2022/03/06/GtLEx1YyMX3gwiz.png" alt="image-20220306204532500"></p><p>引入：对难以解析求解的定积分求数值解。</p><p>基本思想：在区域内不断采样，并认为采样值=函数平均值</p><script type="math/tex; mode=display">\int f(X)dx=\frac{1}{N}\sum_{i=1}^N \frac{f(X_i)}{p(X_i)} \space \space X_i \sim p(x_i)</script><p>其中积分域已经在$p(X_i)$中体现。</p><span id="more"></span><h2 id="Path-Tracing"><a href="#Path-Tracing" class="headerlink" title="Path Tracing"></a>Path Tracing</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Whitted-style Ray Tracing 存在很多问题：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- <span class="hljs-keyword">Always</span> <span class="hljs-keyword">perform</span> specular reflections / refractions <br>- Stop bouncing at diffuse surfaces<br></code></pre></td></tr></table></figure><p>问题1：无法处理glossy reflection</p><p><img src="https://s2.loli.net/2022/03/12/fnD2rUMHGVjYCOe.png" alt="image-20220312152618274"></p><center>The Utah teapot</center><p>问题2：漫反射无反射光</p><p><img src="https://s2.loli.net/2022/03/12/GP81pZEFjWc3MOm.png" alt="image-20220312152920081"></p><center>The Cornell box</center><p>PS:图中箱子内部立方体侧面为红色/绿色的现象称为Color Bleeding(可以理解为墙上的颜色“流血”到箱子上)</p><p>这一经典模型(The Cornell box)被广泛引用于测试全局光照效果。</p><p>但是<strong>Rendering Equation是对的！</strong> </p><script type="math/tex; mode=display">L_O(p,\omega_O)=L_e(p,\omega_O)+\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_O)(n\cdot\omega_i)d\omega_i</script><h3 id="A-Simple-Monte-Carlo-Solution-直接光照情形"><a href="#A-Simple-Monte-Carlo-Solution-直接光照情形" class="headerlink" title="A Simple Monte Carlo Solution(直接光照情形)"></a>A Simple Monte Carlo Solution(直接光照情形)</h3><p><img src="https://s2.loli.net/2022/03/12/2UokeiVdjZa1q9A.png" alt="image-20220312154809839"></p><p>考虑这一场景中特定点P的直接光照(即忽略所有多次反射)。</p><p>渲染方程简化为：</p><script type="math/tex; mode=display">L_O(p,\omega_O)=\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_O)(n\cdot\omega_i)d\omega_i</script><p>几何意义：在半球不同方向上的积分</p><p><img src="https://s2.loli.net/2022/03/12/P7CWK5eiyVwLJA2.png" alt="image-20220312155116645"></p><p>用Monte Carlo积分法写成</p><script type="math/tex; mode=display">L_O(p,\omega_O)=\frac{1}{N} \sum_{i=1}^N \frac{L_i(p,\omega_i)f_r(p,\omega_i,\omega_O)(n\cdot\omega_i)}{p(\omega_i)}</script><p>其中分母上的p表示概率密度函数，其余的p代表点。</p><p>$p(\omega_i)$可以取半球上的均匀分布$p(\omega_i)=\frac{1}{2\pi}$</p><p>算法伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">shade</span>(p, wo) <span class="hljs-comment">//计算p点向wo方向发出的光</span><br>Randomly choose N directions wi~pdf<br>Lo = <span class="hljs-number">0.0</span><br>For each wi<br>Trace a ray <span class="hljs-built_in">r</span>(p, wi)<br>If ray r hit the light<br>Lo += (<span class="hljs-number">1</span> / N) * L_i * f_r * cosine / <span class="hljs-built_in">pdf</span>(wi)<br>Return Lo<br></code></pre></td></tr></table></figure><p>通过递归加入全局光照(Global Illumination)</p><p><img src="https://s2.loli.net/2022/03/12/DPkiCxj6pKnWHdE.png" alt="image-20220312161649732"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">shade</span>(p, wo) <br>Randomly choose N directions wi~pdf<br>Lo = <span class="hljs-number">0.0</span><br>For each wi<br>Trace a ray <span class="hljs-built_in">r</span>(p, wi)<br>If ray r hit the light<br>Lo += (<span class="hljs-number">1</span> / N) * L_i * f_r * cosine / <span class="hljs-built_in">pdf</span>(wi)<br>Else If ray r hit an object at q <span class="hljs-comment">//考虑p点接受的反射光</span><br>Lo += (<span class="hljs-number">1</span> / N) * <span class="hljs-built_in">shade</span>(q, -wi) * f_r * cosine / <span class="hljs-built_in">pdf</span>(wi)<br>Return Lo<br></code></pre></td></tr></table></figure><h4 id="问题1：光线数目指数爆炸"><a href="#问题1：光线数目指数爆炸" class="headerlink" title="问题1：光线数目指数爆炸"></a>问题1：光线数目指数爆炸</h4><p><img src="https://s2.loli.net/2022/03/12/pdmTzuQS5wVfanY.png" alt="image-20220312162107711"></p><p>因此只能保留一根光线：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">shade</span>(p, wo)<br>Randomly choose ONE direction wi~<span class="hljs-built_in">pdf</span>(w)<br><span class="hljs-function">Trace a ray <span class="hljs-title">r</span><span class="hljs-params">(p, wi)</span></span><br><span class="hljs-function">If ray r hit the light</span><br><span class="hljs-function">Return L_i * f_r * cosine / <span class="hljs-title">pdf</span><span class="hljs-params">(wi)</span></span><br><span class="hljs-function">Else If ray r hit an object at q</span><br><span class="hljs-function">Return <span class="hljs-title">shade</span><span class="hljs-params">(q, -wi)</span> * f_r * cosine / <span class="hljs-title">pdf</span><span class="hljs-params">(wi)</span></span><br></code></pre></td></tr></table></figure><p>只保留一根光线，使用Monte Carlo积分的方式称为<strong>Path Tracing</strong>(直观理解；对于每一根光线实际上产生了一条从观察者到物体的路径并进行追踪，即为“路径追踪”)</p><h4 id="问题2：noisy"><a href="#问题2：noisy" class="headerlink" title="问题2：noisy"></a>问题2：noisy</h4><p>解决：对于一个像素计算多条path求平均值</p><p><img src="https://s2.loli.net/2022/03/12/Anh3BTiCReaS6FD.png" alt="image-20220312162457532"></p><p>算法：Ray Generation</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">ray_generation</span>(camPos, pixel)<br>Uniformly choose N sample positions within the pixel<br>pixel_radiance = <span class="hljs-number">0.0</span><br>For each sample in the pixel<br>Shoot a ray <span class="hljs-built_in">r</span>(camPos, cam_to_sample)<br>If ray r hit the scene at p<br>pixel_radiance += <span class="hljs-number">1</span> / N * <span class="hljs-built_in">shade</span>(p, sample_to_cam)<br>Return pixel_radiance<br></code></pre></td></tr></table></figure><h4 id="问题3：递归边界问题"><a href="#问题3：递归边界问题" class="headerlink" title="问题3：递归边界问题"></a>问题3：递归边界问题</h4><p>问题：以上算法中使用递归进行转移，但是没有给出边界条件(即停不下来)</p><p>dilema：自然界中的光反射本就是无数次，但是无法用计算机模拟；如果指定反射次数进行切断，又会带来能量损失（见下方对比图）</p><p><img src="https://s2.loli.net/2022/03/12/bH326ZfsLuSe9kE.png" alt="image-20220312163308511"></p><center>3 bounces</center><p><img src="https://s2.loli.net/2022/03/12/KkOxo9gB2EwHCUn.png" alt="image-20220312163339735"></p><center>17 bounces</center><p>解决方式：俄罗斯轮盘赌(Russian Roulette , RR)</p><p>即生成一个概率值P，对于特定点以概率P向外发射光线，以概率(1-P)不发射光线。</p><p>这样期望值</p><script type="math/tex; mode=display">E = P * (Lo / P) + (1 - P) * 0 = Lo</script><p>仍为$L_o$。</p><p>算法改动：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">shade</span>(p, wo)<br>Manually specify a probability P_RR<br>Randomly select ksi in a uniform dist. in [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br><span class="hljs-built_in">If</span> (ksi &gt; P_RR) <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br><br>Randomly choose ONE direction wi~<span class="hljs-built_in">pdf</span>(w)<br><span class="hljs-function">Trace a ray <span class="hljs-title">r</span><span class="hljs-params">(p, wi)</span></span><br><span class="hljs-function">If ray r hit the light</span><br><span class="hljs-function">Return L_i * f_r * cosine / <span class="hljs-title">pdf</span><span class="hljs-params">(wi)</span> / P_RR</span><br><span class="hljs-function">Else If ray r hit an object at q</span><br><span class="hljs-function">Return <span class="hljs-title">shade</span><span class="hljs-params">(q, -wi)</span> * f_r * cosine / <span class="hljs-title">pdf</span><span class="hljs-params">(wi)</span> / P_RR</span><br></code></pre></td></tr></table></figure><p>至此，已经完成了<strong>正确的Path Tracing</strong></p><h3 id="Efficiency"><a href="#Efficiency" class="headerlink" title="Efficiency"></a>Efficiency</h3><p>目前讨论的Path Tracing效率不高。</p><p><img src="https://s2.loli.net/2022/03/12/h37op68W9LxaCbf.png" alt="image-20220312164914218"></p><p>原因：采样选用半球面上均匀，导致很多光线“浪费”</p><p><img src="https://s2.loli.net/2022/03/12/fOZpeyBmAEuoVGj.png" alt="image-20220312165205732"></p><p>想法：如果采样可以直接在光源上进行，就可以避免光线浪费。但是光源上采样的变量和原先选取的点不同（积分域不同），需要变换，即寻求$d\omega$和$dA$之间的关系。</p><p><img src="https://s2.loli.net/2022/03/12/zn8jZWwqybL1HlP.png" alt="image-20220312170359426"></p><script type="math/tex; mode=display">d\omega = \frac{dA cos\theta'}{||x'-x||^2}</script><p>渲染方程重写为</p><script type="math/tex; mode=display">L_O(p,\omega_O)=\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_O)cos\theta d\omega_i \\=\int_{A}L_i(p,\omega_i)f_r(p,\omega_i,\omega_O)\frac{cos\theta cos\theta'}{||x'-x||^2}dA</script><p>至此积分域变换到光源。可以将一个点接受的Radiance分为两部分:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1.</span> light source <span class="hljs-comment">(direct, no need to have RR)</span> <br><span class="hljs-number">2.</span> other reflectors <span class="hljs-comment">(indirect, RR)</span><br></code></pre></td></tr></table></figure><h3 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">shade</span>(p, wo)<br># Contribution from the light source.<br>Uniformly sample the light at x’ (pdf_light = <span class="hljs-number">1</span> / A)<br>L_dir = L_i * f_r * cos θ * cos θ’ / |x’ - p|^<span class="hljs-number">2</span> / pdf_light <br><br># Contribution from other reflectors.<br>    L_indir = <span class="hljs-number">0.0</span><br>    Test Russian Roulette with probability P_RR<br>    Uniformly sample the hemisphere toward <span class="hljs-built_in">wi</span> (pdf_hemi = <span class="hljs-number">1</span> / <span class="hljs-number">2</span>pi)<br>    Trace a ray <span class="hljs-built_in">r</span>(p, wi)<br>    If ray r hit a non-emitting object at q<br>    L_indir = <span class="hljs-built_in">shade</span>(q, -wi) * f_r * cos θ / pdf_hemi / P_RR<br>    <br>    Return L_dir + L_indir<br></code></pre></td></tr></table></figure><h3 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES:"></a>NOTES:</h3><h4 id="1-在前述进行积分域变换时，需要考虑光源与物体之间是否有遮挡情况"><a href="#1-在前述进行积分域变换时，需要考虑光源与物体之间是否有遮挡情况" class="headerlink" title="1.在前述进行积分域变换时，需要考虑光源与物体之间是否有遮挡情况"></a>1.在前述进行积分域变换时，需要考虑光源与物体之间是否有遮挡情况</h4><p><img src="https://s2.loli.net/2022/03/12/bIdLyCf8rGgZ4MT.png" alt="image-20220312171616075"></p><p>修改代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"># Contribution from the light source.<br>L_dir = <span class="hljs-number">0.0</span><br>Uniformly sample the light at x’ (pdf_light = <span class="hljs-number">1</span> / A)<br>Shoot a ray from p to x’<br>If the ray is <span class="hljs-keyword">not</span> blocked in the middle<br>L_dir = …<br></code></pre></td></tr></table></figure><h4 id="2-Pah-Tracing-难以处理点光源"><a href="#2-Pah-Tracing-难以处理点光源" class="headerlink" title="2.Pah Tracing 难以处理点光源"></a>2.Pah Tracing 难以处理点光源</h4><h4 id="3-Path-Tracing-的正确性"><a href="#3-Path-Tracing-的正确性" class="headerlink" title="3.Path Tracing 的正确性"></a>3.Path Tracing 的正确性</h4><p>可以实现<strong>PHOTO-REALISTIC</strong></p><p><img src="https://s2.loli.net/2022/03/12/kuvM5L4TVQoJOnX.png" alt="image-20220312171945678"></p><h4 id="4-现代光线追踪介绍"><a href="#4-现代光线追踪介绍" class="headerlink" title="4.现代光线追踪介绍"></a>4.现代光线追踪介绍</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">• Previous <br><span class="hljs-bullet">-</span> Ray tracing == Whitted-style ray tracing<br>• Modern<br><span class="hljs-bullet">    -</span> The general solution of light transport, including<br><span class="hljs-bullet">    -</span> (Unidirectional &amp; bidirectional) path tracing <br><span class="hljs-bullet">    -</span> Photon mapping <br><span class="hljs-bullet">    -</span> Metropolis light transport <br><span class="hljs-bullet">    -</span> VCM / UPBP…<br></code></pre></td></tr></table></figure><h4 id="5-未展开的话题"><a href="#5-未展开的话题" class="headerlink" title="5.未展开的话题"></a>5.未展开的话题</h4><p>(1)关于均匀采样的具体实现？</p><p>(2)对于不同的函数形式，Monte Carlo积分选取什么PDF？（重要性采样理论，importance sampling）</p><p>(3)随机数生成要求(low discrepancy sequences)</p><p>(4)对光源和对指定点采样的结合(multiple imp. sampling)</p><p>(5)像素的颜色就是选取path计算结果的平均吗?(pixel reconstruction filter)</p><p>(6)我们计算出的radiance和颜色直接的关系？(gamma correction, curves, color space)</p><h3 id="Fear-the-science-my-friends"><a href="#Fear-the-science-my-friends" class="headerlink" title="Fear the science, my friends."></a><strong>Fear the science, my friends.</strong></h3>]]></content>
    
    
    <categories>
      
      <category>Games101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graphics</tag>
      
      <tag>Ray Tracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-Ray-Tracing-Radiometry-L15</title>
    <link href="/2022/03/05/Games101-Ray-Tracing-Radiometry-L15/"/>
    <url>/2022/03/05/Games101-Ray-Tracing-Radiometry-L15/</url>
    
    <content type="html"><![CDATA[<h1 id="Ray-Tracing-Basic-radiometry（辐射度量学）"><a href="#Ray-Tracing-Basic-radiometry（辐射度量学）" class="headerlink" title="Ray Tracing -  Basic radiometry（辐射度量学）"></a>Ray Tracing -  Basic radiometry（辐射度量学）</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>辐射度量学可以提供光线的物理参数。包括：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">• Measurement <span class="hljs-keyword">system</span> <span class="hljs-keyword">and</span> units <span class="hljs-keyword">for</span> illumination<br>• <span class="hljs-keyword">Perform</span> lighting calculations <span class="hljs-keyword">in</span> a physically correct manner<br>• <span class="hljs-built_in">New</span> terms: Radiant flux, intensity, irradiance, radiance（无准确中文翻译）<br></code></pre></td></tr></table></figure><h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><h3 id="Radiant-energy-（电磁辐射能量）"><a href="#Radiant-energy-（电磁辐射能量）" class="headerlink" title="Radiant energy （电磁辐射能量）"></a>Radiant energy （电磁辐射能量）</h3><p> Radiant energy is the <strong>energy of electromagnetic radiation.</strong> </p><script type="math/tex; mode=display">Q[J(Joule)]</script><p>(Barely used in CG.)</p><h3 id="Radiant-flux-power-（辐射功率）"><a href="#Radiant-flux-power-（辐射功率）" class="headerlink" title="Radiant flux (power) （辐射功率）"></a>Radiant flux (power) （辐射功率）</h3><p>Radiant flux (power) is the <strong>energy</strong> emitted, reflected, transmitted or received, <strong>per unit time.</strong></p><script type="math/tex; mode=display">\phi=\frac{dQ}{dT}[W(Watt)/lm(lumen)]</script><p>其中流明（lumen，符号lm）是光通量的国际单位。</p><p>另可以定义为：<strong>photons flowing through a sensor in unit time</strong>，见下图。</p><p><img src="https://s2.loli.net/2022/03/05/AR3Heb29a5Try7U.png" alt="image-20220211111945007"></p><span id="more"></span><h3 id="Radiant-Intensity"><a href="#Radiant-Intensity" class="headerlink" title="Radiant Intensity"></a>Radiant Intensity</h3><p>The radiant (luminous) intensity is the power per unit <strong>solid angle</strong> emitted by a point light source.</p><p>考虑的是光源在方向上的量度。</p><p><img src="https://s2.loli.net/2022/02/11/Or9AcZjHx8wQ31G.png" alt="image-20220211114908451"></p><p>即：<strong>单位立体角的功率</strong></p><script type="math/tex; mode=display">I(\omega)\equiv\frac{d\phi}{d\omega}</script><script type="math/tex; mode=display">[\frac{W}{sr} or \frac{lm}{sr}=cd=candela]</script><p>（单位的不同取决于是在热学范围内定义还是光学范围内定义）</p><hr><p>【复习：立体角 Solid angle】</p><p><img src="https://s2.loli.net/2022/03/05/1OQkV69FvhHPrt8.png" alt="image-20220211115144683"></p><script type="math/tex; mode=display">\Omega=\frac{A}{r^2}</script><p>Sphere has $4\pi$ steradians.</p><p>单位立体角的计算：</p><p><img src="https://s2.loli.net/2022/03/05/8rhkcvxQpXl9uqJ.png" alt="image-20220211135625265"></p><script type="math/tex; mode=display">dA=(rd\theta)(rsin\theta d\phi)r^2sin\theta d\theta d\phi</script><script type="math/tex; mode=display">\Rightarrow d\omega=\frac{dA}{r^2}=sin\theta d\theta d\phi</script><p>因此可以用单位向量$\omega$去表示一个立体角。</p><p>对于此公式的理解：</p><script type="math/tex; mode=display">1.微分立体角的大小和所处方位\theta有关，因此在极点和赤道处\theta和\phi的变化引起的立体角变化是不同的。 \\2.由上可知，\theta 和 \phi 对于球面面积的划分是不均匀的。</script><p><img src="https://s2.loli.net/2022/03/05/C359iRKLQjyw7Us.png" alt="image-20220211120155931"></p><hr><p>Intensity具有的性质（根据定义）：</p><script type="math/tex; mode=display">\phi= \int_{s^2} I {\rm d}\omega=4\pi I</script><script type="math/tex; mode=display">\Rightarrow I = \frac{\phi}{4\pi}</script><h3 id="Irradiance"><a href="#Irradiance" class="headerlink" title="Irradiance"></a>Irradiance</h3><p><strong>Power per unit area</strong> incident on a surface point.</p><script type="math/tex; mode=display">E(x)\equiv \frac{d\phi(x)}{dA} \\Unit: [\frac{W}{m^2}]/[\frac{lm}{m^2}=lux]</script><p>注意！此处的面积其实指<strong>投影之后的面积</strong>。</p><p>通过irradiance的衰减可以解释点光源的强度呈现平方反比律衰减。</p><p><img src="https://s2.loli.net/2022/03/05/xgqfIyCGWhnAsdV.png" alt="tempsnip"></p><h3 id="Radiance"><a href="#Radiance" class="headerlink" title="Radiance"></a>Radiance</h3><p>Power emitted, reflected, transmitted or received by a surface, <strong>per unit solid angle, per projected unit area</strong>.</p><script type="math/tex; mode=display">L(p,\omega)\equiv\frac{d^2 \Phi(p,\omega)}{d\omega dAcos\theta}</script><script type="math/tex; mode=display">Unit: [\frac{W}{sr \space m^2}][\frac{cd}{m^2}=\frac{lm}{sr\space m^2}=nit]</script><p>要点：功率局限于一个<strong>很小的面</strong>，一个<strong>很小的角度范围</strong></p><p><img src="https://s2.loli.net/2022/03/05/uxzTecoE4l9aWD1.png" alt="image-20220305214440845"></p><p>Radiance分为发出(Incident Radiance)和接受(Exiting Radiance)，实质相同</p><p>与之前概念的对比：</p><p>​    Radiance = <strong>Intensity per projected unit area</strong></p><p>​    Radiance = <strong>Irradiance per solid angle</strong></p><script type="math/tex; mode=display">L(p,\omega)=\frac{dE(p)}{d\omega cos\theta}</script><p>​    <img src="https://s2.loli.net/2022/03/06/KZ59iasXvpV1x8N.png" alt="image-20220306112623404"></p><p>Radiance和Irradiance的区别：<strong>方向性</strong></p><p>​    Irradiance: total power received by area $dA$</p><p>​    Radiance: power received by area $d A$ from “direction” $d \omega$</p><p>​    Irradiance可以理解为来自各个方向Radiance的积分</p><h2 id="Bidirectional-Reflectance-Distribution-Function-BRDF，双向反射分布函数"><a href="#Bidirectional-Reflectance-Distribution-Function-BRDF，双向反射分布函数" class="headerlink" title="Bidirectional Reflectance Distribution Function (BRDF，双向反射分布函数)"></a>Bidirectional Reflectance Distribution Function (BRDF，双向反射分布函数)</h2><p>BRDF告诉我们从某个方向来的光线如何反射到另一方向去（即各个方向的能量分布）</p><p><strong>Definition</strong>: Represents how much light is reflected into each outgoing direction from each incoming direction </p><p><img src="https://s2.loli.net/2022/03/05/JZNq37PS2gtHAIX.png" alt="image-20220305220700635"></p><script type="math/tex; mode=display">f_r(\omega_i\rightarrow\omega_r)=\frac{dL_r(\omega_r)}{dE_i(\omega_i)}=\frac{dL_r(\omega_r)}{L_i(\omega_i)cos\theta d\omega_i}[\frac{1}{sr}]</script><p>通过BRDF可以定义<strong>不同的材质</strong></p><h4 id="Reflection-Equation"><a href="#Reflection-Equation" class="headerlink" title="Reflection Equation"></a>Reflection Equation</h4><p><img src="https://s2.loli.net/2022/03/05/uAE9bJ3LO2prPmz.png" alt="image-20220305221540887"></p><script type="math/tex; mode=display">L_r(p,\omega_r)=\int_{H^2}f_r(p,\omega_i\rightarrow\omega_r)L_i(p,\omega_i)cos\theta_id\omega_i</script><p>解释：计算一个出射方向的Radiance，需要对所有入射方向的Radiance计算BRDF然后求和。</p><h4 id="Challenge：Recursive-Equation"><a href="#Challenge：Recursive-Equation" class="headerlink" title="Challenge：Recursive Equation"></a>Challenge：Recursive Equation</h4><p>​    Reflected radiance depends on incoming radiance, But incoming radiance depends on reflected radiance (at </p><p>another point in the scene).</p><p>​    即：由于光线在场景中反复弹射，会形成递归效应。</p><h4 id="Rendering-Equation"><a href="#Rendering-Equation" class="headerlink" title="Rendering Equation"></a>Rendering Equation</h4><p><img src="https://s2.loli.net/2022/03/06/Z5AjL9UEBN6ogwr.png" alt="image-20220306103302254"></p><script type="math/tex; mode=display">L_O(p,\omega_O)=L_e(p,\omega_O)+\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_O)(n\cdot\omega_i)d\omega_i</script><p>式子中假设所有向量都朝向外。</p><p>解释：某一点的光 = 自己辐射出的 + 其他地方反射过来的</p><p>地位：现代图形学（表面上的光线反射及传播）的基础</p><h5 id="方程简化及理解"><a href="#方程简化及理解" class="headerlink" title="方程简化及理解"></a>方程简化及理解</h5><p>经过很多的简化步骤最后可以得到（简化的具体过程尚不清楚）</p><script type="math/tex; mode=display">L=E+KL</script><p>形成了矩阵乘积（算子）的形式。</p><p>目的：利用矩阵求逆类似Taylor展开的性质得到：</p><script type="math/tex; mode=display">L=E+KE+K^2E+K^3E+...</script><p>右侧依次代表直接照射、弹射一次、弹射两次、…的光照效果。</p><h5 id="效果示意"><a href="#效果示意" class="headerlink" title="效果示意"></a>效果示意</h5><p><img src="https://s2.loli.net/2022/03/06/QxH35LcFPGgByZq.png" alt="image-20220306104450782"></p><p><img src="https://s2.loli.net/2022/03/06/iAm6pdWyvPtrxMz.png" alt="image-20220306111623993"></p><p><img src="https://s2.loli.net/2022/03/06/5ABmtyXKVMv1P8F.png" alt="image-20220306104518766"></p><h6 id="1-相较于2次反射，为什么4次反射时图片上方的灯突然变亮了？"><a href="#1-相较于2次反射，为什么4次反射时图片上方的灯突然变亮了？" class="headerlink" title="1.相较于2次反射，为什么4次反射时图片上方的灯突然变亮了？"></a>1.相较于2次反射，为什么4次反射时图片上方的灯突然变亮了？</h6><p>-有的物体需要光线在其中至少弹射若干次才能出来，如玻璃球至少弹射两次，此处的灯也是同理。</p><h6 id="2-如果反射次数可以到达-infty-，最后亮度会收敛还是发散？"><a href="#2-如果反射次数可以到达-infty-，最后亮度会收敛还是发散？" class="headerlink" title="2.如果反射次数可以到达$\infty$，最后亮度会收敛还是发散？"></a>2.如果反射次数可以到达$\infty$，最后亮度会收敛还是发散？</h6><p>-收敛。可从自然界和能量守恒的角度理解（自然界恒全局光照）</p><p>-但是如果考虑相机一直按住快门不放的情况，其亮度确实会不断增加而不收敛（这也印证了Radiometry中主要考虑单位时间内能量的想法是正确的）</p><h2 id="概率论回顾"><a href="#概率论回顾" class="headerlink" title="概率论回顾"></a>概率论回顾</h2><p>连续情况下：概率密度函数 Probability Distribution Function (PDF)</p><script type="math/tex; mode=display">Conditions\space on\space p(x):\space p(x)\geq0\space and \int p(x)dx=1 \\Expected\space value\space of\space x:E[X]=\int xp(x)dx \\Expected\space value\space of\space a\space function\space of\space a\space random\space variable: E[Y]=E[f(X)]=\int f(x)p(x)dx</script><hr>]]></content>
    
    
    <categories>
      
      <category>Games101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graphics</tag>
      
      <tag>Ray Tracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-Ray Tracing (Acceleration) -L14</title>
    <link href="/2022/03/02/Games101-Ray-Tracing-Acceleration-L14/"/>
    <url>/2022/03/02/Games101-Ray-Tracing-Acceleration-L14/</url>
    
    <content type="html"><![CDATA[<h1 id="Ray-Tracing-Acceleration"><a href="#Ray-Tracing-Acceleration" class="headerlink" title="Ray Tracing - Acceleration"></a>Ray Tracing - Acceleration</h1><h2 id="1-Uniform-Spatial-Partitions-Grids"><a href="#1-Uniform-Spatial-Partitions-Grids" class="headerlink" title="1.Uniform Spatial Partitions (Grids)"></a>1.Uniform Spatial Partitions (Grids)</h2><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">Assumptions</span>:<br><span class="hljs-literal">-</span> 判断光线是否与物体相交是耗时的<br><span class="hljs-literal">-</span> 判断光线是否与bounding box相交是容易的<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/02/10/GyDajLnXSZsv9bu.png" alt="image-20220208214130374"></p><span id="more"></span><p>预处理结束后，求出光线穿过的每个盒子，判断盒子里是否有物体，如果有，则判断光线是否与物体相交，这样避免了和空间中所有物体计算是否相交。</p><p><img src="https://s2.loli.net/2022/03/02/HmiSj6QDGrZY1JF.png" alt="image-20220208214151307"></p><p>加速结构基本思想：多做光线和盒子求交，避免做光线和物体求交。</p><p>缺陷：仍需要计算所有光线走过的格子。</p><h2 id="2-Spatial-Partitions（空间划分）"><a href="#2-Spatial-Partitions（空间划分）" class="headerlink" title="2.Spatial Partitions（空间划分）"></a>2.Spatial Partitions（空间划分）</h2><p>基本想法：改进（1.）中的格子划分方式，对于空旷的地方少用一些格子（即格子设置更大），密集的地方多用一些格子（即格子设置更小），有利于处理下面这一经典案例（图中存在着大量空旷区域，用统一的格子划分方式会比较慢）</p><p><img src="https://s2.loli.net/2022/03/02/gsf8yZhT9rGzIAn.png" alt="image-20220211220424258"></p><center>San Miguel Scene(经典场景), 10.7M triangles</center><p>Examples：（<strong>重点：KD-Tree</strong>）</p><p><img src="https://s2.loli.net/2022/03/02/nRlI72OBU4ijeEc.png" alt="image-20220208222552071"></p><p><strong>场景的加速结构预处理要在光线追踪计算之前做完！</strong></p><p><img src="https://s2.loli.net/2022/03/02/lxs6AYJPXfOc2ST.png" alt="image-20220209164215429"></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">执行流程：<br>对当前节点采用某种划分方式(x<span class="hljs-string">\y\z),得到两个子节点，然后对于子节点继续划分。</span><br>实际的物体<span class="hljs-string">\三角形只存放在叶子节点上</span><br></code></pre></td></tr></table></figure><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dos">问题：<br><span class="hljs-number">1</span>.一个物体可能出现在多个叶子节点中<br><span class="hljs-number">2</span>.KD-<span class="hljs-built_in">Tree</span>的建立需要考虑三角和盒子的求交（复杂）<br></code></pre></td></tr></table></figure><h2 id="3-Bounding-Volume-Hierarchy-BVH"><a href="#3-Bounding-Volume-Hierarchy-BVH" class="headerlink" title="3.Bounding Volume Hierarchy (BVH)"></a>3.Bounding Volume Hierarchy (BVH)</h2><p>属于Object Partitions（物体划分），应用广泛！</p><p><img src="https://s2.loli.net/2022/03/02/1J4kYbLnmyDjZ3w.png" alt="image-20220210221401987"></p><h3 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h3><p>BVH对物体进行划分，每次划分为两堆，然后分别求出bounding box，继续划分，再次重新计算bounding box，重复以上过程，划分方式可以竖直\水平等不做限制（如依次选择X轴，Y轴，Z轴），最终使得每个叶子节点中三角形数量较少，空间中物体的划分尽量均匀。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-symbol">Summary:</span> <span class="hljs-keyword">Building </span><span class="hljs-keyword">BVHs</span><br><span class="hljs-keyword"></span>• Find <span class="hljs-keyword">bounding </span><span class="hljs-keyword">box </span><br>找到当前节点物体的包围盒<br>• Recursively split set of objects in two <span class="hljs-keyword">subsets </span><br>递归地将当前物体分为两堆<br>• Recompute the <span class="hljs-keyword">bounding </span><span class="hljs-keyword">box </span>of the <span class="hljs-keyword">subsets </span><br>重新计算两堆物体的包围盒<br>• Stop when necessary <br>适合的时候停止（每个叶子节点中三角形数量较少，空间中物体的划分尽量均匀）<br>• Store objects in each leaf node<br>物体存储在叶子节点中<br></code></pre></td></tr></table></figure><h3 id="3-2-性能分析"><a href="#3-2-性能分析" class="headerlink" title="3.2 性能分析"></a>3.2 性能分析</h3><p>相较于KD-Tree的优势：<strong>每一个物体一定严格属于一个节点</strong>。因此省去了三角形和bounding box求交的问题。</p><p>存在的问题：并没有严格将空间”划分开“，即bounding box可能相交。因此在”划分”方面比较讲究。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Heuristics <span class="hljs-keyword">of</span> subdivision<br>Choose <span class="hljs-keyword">a</span> dimension <span class="hljs-built_in">to</span> <span class="hljs-built_in">split</span> <br>• Heuristic <span class="hljs-comment">#1: Always choose the longest axis in node </span><br>• Heuristic <span class="hljs-comment">#2: Split node at location of median object</span><br>即选定最长轴划分，划分界限为排序后位于中位的物体。<br></code></pre></td></tr></table></figure><hr><p>【补充：快速选择算法】</p><p>问题：对于n个无序数组成的序列，找出其中第i大的数。<br>时间复杂度：O(n)</p><hr><p>BVH中用这一算法实现对于大小居中物体的查找。</p><h3 id="3-3-存储结构"><a href="#3-3-存储结构" class="headerlink" title="3.3 存储结构"></a>3.3 存储结构</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Data Structure for <span class="hljs-keyword">BVHs</span><br><span class="hljs-keyword"></span>[Internal nodes store]<br>• <span class="hljs-keyword">Bounding </span><span class="hljs-keyword">box </span><br>• Children: pointers to child nodes <br>[Leaf nodes store]<br>• <span class="hljs-keyword">Bounding </span><span class="hljs-keyword">box </span><br>• List of objects<br></code></pre></td></tr></table></figure><h3 id="3-4-伪代码"><a href="#3-4-伪代码" class="headerlink" title="3.4 伪代码"></a>3.4 伪代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Intersect</span>(Ray ray, BVH node) <br>&#123;<br><span class="hljs-keyword">if</span> (ray misses node.bbox) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//若光线与bounding box不相交，结束</span><br><span class="hljs-comment">//若相交，分为是否是叶子节点</span><br> <span class="hljs-keyword">if</span> (node is a leaf node)<br> &#123;<br> test intersection with all objs;<br> <span class="hljs-keyword">return</span> closest intersection;<br> &#125; <span class="hljs-comment">//叶子节点，判断节点内部所有物体，返回最近的交点</span><br> hit1 = <span class="hljs-built_in">Intersect</span>(ray, node.child1);<br> hit2 = <span class="hljs-built_in">Intersect</span>(ray, node.child2);<br>    <span class="hljs-comment">//若节点不是叶子节点，返回两个子节点交点的最近值</span><br> <span class="hljs-keyword">return</span> the closer of hit1, hit2;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-加速结构的比较：Spatial-vs-Object-Partitions"><a href="#4-加速结构的比较：Spatial-vs-Object-Partitions" class="headerlink" title="4.加速结构的比较：Spatial vs Object Partitions"></a>4.加速结构的比较：Spatial vs Object Partitions</h2><h3 id="4-1-Spatial-partition-e-g-KD-tree"><a href="#4-1-Spatial-partition-e-g-KD-tree" class="headerlink" title="4.1 Spatial partition (e.g.KD-tree)"></a>4.1 Spatial partition (e.g.KD-tree)</h3><p><img src="https://s2.loli.net/2022/03/02/CFfDekQnwgAYahp.png" alt="image-20220210225343386"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">• <span class="hljs-keyword">Partition</span> space <span class="hljs-keyword">into</span> non-overlapping regions <br>空间划分，划分的节点之间不重叠<br>• An <span class="hljs-keyword">object</span> can be contained <span class="hljs-keyword">in</span> multiple regions<br>缺点：一个物体可能被划分到多个区域中<br></code></pre></td></tr></table></figure><h3 id="4-2-Object-partition-e-g-BVH"><a href="#4-2-Object-partition-e-g-BVH" class="headerlink" title="4.2 Object partition (e.g. BVH)"></a>4.2 Object partition (e.g. BVH)</h3><p><img src="https://s2.loli.net/2022/03/02/Hno1iDxwtUMRY85.png" alt="image-20220210225528898"></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">• Partition <span class="hljs-built_in">set</span> <span class="hljs-keyword">of</span> objects <span class="hljs-keyword">into</span> disjoint subsets <br>优点：物体划分到不相交的子集，不会出现同一个物体被划分到不同的节点<br>• Bounding boxes <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-built_in">set</span> may overlap <span class="hljs-keyword">in</span> <span class="hljs-literal">space</span><br>缺点：不同节点所占空间可能重叠<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Games101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graphics</tag>
      
      <tag>Ray Tracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-Ray Tracing (Introduction) -L13</title>
    <link href="/2022/03/02/Games101-Ray-Tracing-Introduction-L13/"/>
    <url>/2022/03/02/Games101-Ray-Tracing-Introduction-L13/</url>
    
    <content type="html"><![CDATA[<h1 id="Ray-Tracing-Introduction-（L13"><a href="#Ray-Tracing-Introduction-（L13" class="headerlink" title="Ray Tracing - Introduction （L13)"></a>Ray Tracing - Introduction （L13)</h1><h2 id="0-Introduction"><a href="#0-Introduction" class="headerlink" title="0.Introduction"></a>0.Introduction</h2><h3 id="0-1-光栅化无法处理的问题"><a href="#0-1-光栅化无法处理的问题" class="headerlink" title="0.1 光栅化无法处理的问题"></a>0.1 光栅化无法处理的问题</h3><p>Rasterization couldn’t handle <strong>global effects</strong> well.</p><p><img src="https://cdn.jsdelivr.net/gh/thunderbolt215/imagehosting@main/data/1.18x6t15o01uo.webp" alt="1"></p><center>1.Soft Shadows（软阴影）</center><p><img src="https://s2.loli.net/2022/02/10/cm4RWXGL9xKhbVC.png" alt="image-20220207102616490"></p><center> 2.light bounces more than once（多次反射）</center><span id="more"></span><h3 id="0-2-Rasterization-vs-Ray-Tracing"><a href="#0-2-Rasterization-vs-Ray-Tracing" class="headerlink" title="0.2 Rasterization vs. Ray Tracing"></a>0.2 Rasterization vs. Ray Tracing</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Rasterization<br>-fast, <span class="hljs-keyword">but</span> low-quality<br>-<span class="hljs-built_in">real</span>-<span class="hljs-built_in">time</span><br><br>Ray Tracing<br>-accurate, <span class="hljs-keyword">but</span> very slow<br>-offline<br>-~<span class="hljs-number">10</span>K CPU core hours <span class="hljs-keyword">to</span> render one frame <span class="hljs-keyword">in</span> production<br></code></pre></td></tr></table></figure><p>质量和时间为“Trade-off”</p><h2 id="1-Recursive-Whitted-Style-Ray-Tracing"><a href="#1-Recursive-Whitted-Style-Ray-Tracing" class="headerlink" title="1.Recursive (Whitted-Style) Ray Tracing"></a>1.Recursive (Whitted-Style) Ray Tracing</h2><h3 id="1-1-Light-Rays"><a href="#1-1-Light-Rays" class="headerlink" title="1.1 Light Rays"></a>1.1 Light Rays</h3><p>基本假设： 直线传播；不发生碰撞；<strong>光路可逆</strong></p><p>（将物体发射到观察者的光线等效成由观察者发向物体一道“感知光线”，光路仍成立，这也是光线<strong>“追踪“</strong>的命名由来）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span> Light travels <span class="hljs-keyword">in</span> straight lines (though this <span class="hljs-keyword">is</span> wrong) <br><span class="hljs-number">2.</span> Light rays <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> “collide” <span class="hljs-keyword">with</span> <span class="hljs-keyword">each</span> other <span class="hljs-keyword">if</span> they <span class="hljs-keyword">cross</span> (though this <span class="hljs-keyword">is</span> still wrong) <br><span class="hljs-number">3.</span> Light rays travel <span class="hljs-keyword">from</span> the light sources <span class="hljs-keyword">to</span> the eye (but the physics <span class="hljs-keyword">is</span> invariant under <span class="hljs-type">path</span> reversal - reciprocity[可逆性]).<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/02/jnWSJ2Hy4blI7kq.png" alt="image-20220211191805453"></p><center>Eyes send out feeling rays to the world</center><h3 id="1-2-Ray-Casting-光线投射：生成不同的光线"><a href="#1-2-Ray-Casting-光线投射：生成不同的光线" class="headerlink" title="1.2  Ray Casting(光线投射：生成不同的光线)"></a>1.2  Ray Casting(光线投射：生成不同的光线)</h3><h4 id="1-2-1-概述"><a href="#1-2-1-概述" class="headerlink" title="1.2.1 概述"></a>1.2.1 概述</h4><p><img src="https://s2.loli.net/2022/03/02/naDQ7JRlkxjXKe2.png" alt="image-20220211193001892"></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">基本流程：<br><span class="hljs-number">1.</span> Generate <span class="hljs-keyword">an</span> image <span class="hljs-keyword">by</span> casting <span class="hljs-literal">one</span> ray per pixel <br><span class="hljs-number">2.</span> Check <span class="hljs-keyword">for</span> shadows <span class="hljs-keyword">by</span> sending <span class="hljs-keyword">a</span> ray <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> light<br></code></pre></td></tr></table></figure><h4 id="1-2-2-An-Example："><a href="#1-2-2-An-Example：" class="headerlink" title="1.2 2 An Example："></a>1.2 2 An Example：</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">Assumptions</span><br><span class="hljs-number">1.</span>光源为点光源，眼睛为针孔摄像机（即忽略光源和相机的大小和尺寸）<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/02/Vj4cNBLhFGZWXeu.png" alt="image-20220211193740056"></p><center>Step 1</center><p><img src="https://s2.loli.net/2022/03/02/NQ2M7ge1rHYVB6u.png" alt="image-20220211193754261"></p><center>Step 2</center><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">基本步骤：<br><span class="hljs-number">1</span>.对于每个像素，与眼睛连线形成Ray，计算这条光线照亮的场景中最近的点<br><span class="hljs-number">2</span>.该点与光源连线<span class="hljs-selector-attr">[这条连线叫做Shadow Ray]</span>，判定是否被照亮以及计算颜色<br><span class="hljs-number">3</span>.将计算结果写回原像素<br></code></pre></td></tr></table></figure><h4 id="1-2-3-Recursive-Ray-Casting-Whitted-Style-概述"><a href="#1-2-3-Recursive-Ray-Casting-Whitted-Style-概述" class="headerlink" title="1.2.3 Recursive Ray Casting(Whitted-Style) 概述"></a>1.2.3 Recursive Ray Casting(Whitted-Style) 概述</h4><p><img src="https://s2.loli.net/2022/03/02/56F3LJ2yVGI1fZH.png" alt="image-20220211195529474"></p><p>模拟光线不断弹射的过程，<strong>将多次反射和折射的结果都加入到该点的像素值上</strong>。</p><p><strong>注意</strong>：多次反射和折射当然要考虑能量衰减。</p><p><img src="https://s2.loli.net/2022/03/02/d24Lyag1HJCf9Bo.png" alt="image-20220211195825708"></p><center>效果图</center><h3 id="1-3-Ray-surface-Intersection"><a href="#1-3-Ray-surface-Intersection" class="headerlink" title="1.3 Ray-surface Intersection"></a>1.3 Ray-surface Intersection</h3><h4 id="1-3-1-Ray-Equation"><a href="#1-3-1-Ray-Equation" class="headerlink" title="1.3.1 Ray Equation"></a>1.3.1 Ray Equation</h4><p>Ray is defined by its <strong>origin</strong> and a <strong>direction vector</strong>.</p><script type="math/tex; mode=display">\vec{r}(t)=\vec{o}+t\vec{d}(0\leq t<\infty)</script><p><strong>ATTENTION：图形学中一般不纠结边界条件（如t&gt;0还是t&gt;=0）</strong></p><p> <strong>Example: Ray Intersection With Sphere</strong></p><p><img src="https://s2.loli.net/2022/02/11/ZU5Q9JoA6NVIuht.png" alt="image-20220211212028153"></p><script type="math/tex; mode=display">Ray:\vec{r}(t)=\vec{o}+t\vec{d}(0\leq t<\infty) \\Sphere:(\vec{p}-\vec{c})^2-R^2=0 \\Solve\space for\space intersection:(\vec{o}+t\vec{d}-\vec{c})^2-R^2=0</script><p>最后可以化为二次方程进行求解，注意根据光线与球面的位置关系分类讨论。</p><p><img src="https://s2.loli.net/2022/03/02/6YLoH19dVSg5NrE.png" alt="image-20220211212559675"></p><h4 id="1-3-2-For-implicit-surface"><a href="#1-3-2-For-implicit-surface" class="headerlink" title="1.3.2 For implicit surface"></a>1.3.2 <strong>For implicit surface</strong></h4><script type="math/tex; mode=display">General\space implicit\space surface:f(\vec{p})=0 \\Substitute\space ray\space equation:f(\vec{o}+t\vec{d})=0 \\[Solve\space for\space positive\space roots.]</script><p><img src="https://s2.loli.net/2022/02/11/oH25ahMSsBVdGXz.png" alt="image-20220211213140679"></p><center>Examples of implicit surfaces</center><h4 id="1-3-3-For-Triangle-Mesh-Explicit-surfaces"><a href="#1-3-3-For-Triangle-Mesh-Explicit-surfaces" class="headerlink" title="1.3.3 For  Triangle Mesh(Explicit surfaces)"></a>1.3.3 For  Triangle Mesh(Explicit surfaces)</h4><p>(作为显式表示的最重要代表，选用三角形面)</p><hr><p><strong>[Point in polygon Test]</strong></p><p>检查一点是否在多边形之内，可作一射线从该点开始往任意方向投射，如果射线与多边形边的交点个数为奇数，则该点位于多边形内部。</p><p><img src="https://s2.loli.net/2022/03/02/4esKFxDCm6BQNn5.png" alt="img"></p><hr><p>但是直接按此方法判定光线和三角形面的位置关系计算量过大。</p><p>改进：问题转化为<strong>求出光线和三角形所在平面的交点，再判断交点是否在三角形内部</strong>。</p><p><img src="https://s2.loli.net/2022/03/02/tHLlbFUOyMpPm2f.png" alt="image-20220207193014512"></p><center>示意</center><p>定义平面：<strong>法线</strong>+<strong>平面上任意一点P’</strong></p><p><img src="https://s2.loli.net/2022/03/02/fHhBOosKaiNEkpA.png" alt="image-20220207194031126"></p><script type="math/tex; mode=display">Plane\space Equation:(\vec{p}-\vec{p'})\cdot \vec{N}=0 \\可以写成\space ax+by+cz+d=0</script><p>至此已经可以解出光线与平面的交点，再判定是否在三角形内部。</p><p>改进：（可以直接解出光线和三角形的交点，并验证其解的合理性）</p><p><img src="https://s2.loli.net/2022/02/10/47ngwolWMQjtZxS.png" alt="image-20220207200051961"></p><center>重心坐标均非负，则交点在三角形内</center><h3 id="1-4-Accelerating-Ray-Surface-Intersection"><a href="#1-4-Accelerating-Ray-Surface-Intersection" class="headerlink" title="1.4 Accelerating Ray-Surface Intersection"></a>1.4 Accelerating Ray-Surface Intersection</h3><p>在像素数过多、光线弹射情况复杂时，上述方法效率过低。</p><p><img src="https://s2.loli.net/2022/03/02/gsf8yZhT9rGzIAn.png" alt="image-20220211220424258"></p><center>San Miguel Scene(经典场景), 10.7M triangles</center><h5 id="1-4-1-Bounding-Volumes"><a href="#1-4-1-Bounding-Volumes" class="headerlink" title="1.4.1 Bounding Volumes"></a>1.4.1 Bounding Volumes</h5><p>引入”包围盒“Bounding Volumes，即<strong>光线如果不会碰到Bounding Volumes，则它一定不会碰到物体</strong>。</p><p><img src="https://s2.loli.net/2022/03/02/ezKqXG8gYIDV2R3.png" alt="image-20220207202144038"></p><p>对于Bounding Volumes的进一步定义：<strong>Bounding Box is the intersection of 3 pairs of slabs</strong></p><p>即：<strong>包围盒是三组平面的交集</strong>。</p><p>常用包围盒：<strong>Axis-Aligned Bounding Box(AABB，轴对齐包围盒)</strong></p><p><img src="https://s2.loli.net/2022/02/11/3tIAwFzyGkCJpBv.png" alt="image-20220211220932624"></p><h5 id="1-4-2-Ray-Intersection-with-AABB"><a href="#1-4-2-Ray-Intersection-with-AABB" class="headerlink" title="1.4.2 Ray Intersection with AABB"></a>1.4.2 Ray Intersection with AABB</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">KEY ideas<br>The ray enters <span class="hljs-keyword">the</span> box only when <span class="hljs-keyword">it</span> enters all pairs <span class="hljs-keyword">of</span> slabs <br>The ray exits <span class="hljs-keyword">the</span> box <span class="hljs-keyword">as</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">it</span> exits <span class="hljs-keyword">any</span> pair <span class="hljs-keyword">of</span> slabs<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/02/7ThdrcLwoyNjGaC.png" alt="image-20220211223237789"></p><p>即：进入任何一对平面即认为进入box，离开所有平面才认为离开box。</p><p>因此对于每一对平面计算$t_{min}$和$t_{max}$，求出进入时间和离开时间：</p><script type="math/tex; mode=display">For\space 3D\space box, \\ t_{enter}=max\{t_{min}\} \\t_{exit}=min\{t_{max}\} \\</script><p>再考虑由于光线实际为射线带来的正负号问题。</p><script type="math/tex; mode=display">若t_{exit}<0,\space则box在光线后方\Rightarrow无交点 \\若t_{exit}\geq0,t_{enter}<0,\space则光线起点位于box内部\Rightarrow有交点</script><p>综上，得到结论：</p><script type="math/tex; mode=display">Ray\space and\space AABB\space intersect\space iff (if\space and\space only\space if) \\t_{enter}<t_{exit} \\t_{exit}\geq0</script><h5 id="1-4-3-Why-Axis-Aligned"><a href="#1-4-3-Why-Axis-Aligned" class="headerlink" title="1.4.3 Why Axis-Aligned?"></a>1.4.3 Why Axis-Aligned?</h5><p>因为计算更方便。</p><p><img src="https://s2.loli.net/2022/03/02/oYpn68VjlRMWdxb.png" alt="image-20220207212226703"></p>]]></content>
    
    
    <categories>
      
      <category>Games101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graphics</tag>
      
      <tag>Ray Tracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-hw6</title>
    <link href="/2022/03/02/Games101-hw6/"/>
    <url>/2022/03/02/Games101-hw6/</url>
    
    <content type="html"><![CDATA[<h1 id="Assignment-6"><a href="#Assignment-6" class="headerlink" title="Assignment 6"></a>Assignment 6</h1><h2 id="1-Basic"><a href="#1-Basic" class="headerlink" title="1. Basic"></a>1. Basic</h2><h3 id="1-1-Render-in-Renderer-cpp"><a href="#1-1-Render-in-Renderer-cpp" class="headerlink" title="1.1 Render() in Renderer.cpp"></a>1.1 <strong>Render()</strong> in Renderer.cpp</h3><p>这一部分直接按照作业5即可，在使用castRay函数时需要进行改动。</p><p>注意：记得对dir向量归一化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Renderer::Render</span><span class="hljs-params">(<span class="hljs-type">const</span> Scene&amp; scene)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::vector&lt;Vector3f&gt; <span class="hljs-title">framebuffer</span><span class="hljs-params">(scene.width * scene.height)</span></span>;<br><br>    <span class="hljs-type">float</span> scale = <span class="hljs-built_in">tan</span>(<span class="hljs-built_in">deg2rad</span>(scene.fov * <span class="hljs-number">0.5</span>));<br>    <span class="hljs-type">float</span> imageAspectRatio = scene.width / (<span class="hljs-type">float</span>)scene.height;<br>    <span class="hljs-function">Vector3f <span class="hljs-title">eye_pos</span><span class="hljs-params">(<span class="hljs-number">-1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> j = <span class="hljs-number">0</span>; j &lt; scene.height; ++j) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; scene.width; ++i) &#123;<br>            <span class="hljs-comment">// generate primary ray direction</span><br>            <span class="hljs-type">float</span> x = (<span class="hljs-number">2</span> * (i + <span class="hljs-number">0.5</span>) / (<span class="hljs-type">float</span>)scene.width - <span class="hljs-number">1</span>) *<br>                      imageAspectRatio * scale;<br>            <span class="hljs-type">float</span> y = (<span class="hljs-number">1</span> - <span class="hljs-number">2</span> * (j + <span class="hljs-number">0.5</span>) / (<span class="hljs-type">float</span>)scene.height) * scale;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Find the x and y positions of the current pixel to get the</span><br>            <span class="hljs-comment">// direction</span><br>            <span class="hljs-comment">//  vector that passes through it.</span><br>            <span class="hljs-comment">// Also, don&#x27;t forget to multiply both of them with the variable</span><br>            <span class="hljs-comment">// *scale*, and x (horizontal) variable with the *imageAspectRatio*</span><br>            <span class="hljs-comment">// x = (2 * (i + 0.5f) / (float)(scene.width-1) - 1) * imageAspectRatio * scale;</span><br>            <span class="hljs-comment">// y = (1 - 2 * (j + 0.5f) / (float)(scene.height-1)) * scale;</span><br><br>            <span class="hljs-comment">/*作业6添加部分*/</span><br>            Vector3f dir = <span class="hljs-built_in">Vector3f</span>(x, y, <span class="hljs-number">-1</span>); <span class="hljs-comment">// Don&#x27;t forget to normalize this direction!</span><br>            <span class="hljs-function">Ray <span class="hljs-title">ray</span><span class="hljs-params">(eye_pos, normalize(dir))</span></span>;<br>            framebuffer[m++] = scene.<span class="hljs-built_in">castRay</span>(ray, <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">/*作业6添加部分*/</span>          <br><br>            <span class="hljs-comment">// Don&#x27;t forget to normalize this direction!</span><br><br>        &#125;<br>        <span class="hljs-built_in">UpdateProgress</span>(j / (<span class="hljs-type">float</span>)scene.height);<br>    &#125;<br>    <span class="hljs-built_in">UpdateProgress</span>(<span class="hljs-number">1.f</span>);<br><br>    <span class="hljs-comment">// save framebuffer to file</span><br>    FILE* fp = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;binary.ppm&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>);<br>    (<span class="hljs-type">void</span>)<span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;P6\n%d %d\n255\n&quot;</span>, scene.width, scene.height);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; scene.height * scene.width; ++i) &#123;<br>        <span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> color[<span class="hljs-number">3</span>];<br>        color[<span class="hljs-number">0</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)(<span class="hljs-number">255</span> * <span class="hljs-built_in">clamp</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, framebuffer[i].x));<br>        color[<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)(<span class="hljs-number">255</span> * <span class="hljs-built_in">clamp</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, framebuffer[i].y));<br>        color[<span class="hljs-number">2</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)(<span class="hljs-number">255</span> * <span class="hljs-built_in">clamp</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, framebuffer[i].z));<br>        <span class="hljs-built_in">fwrite</span>(color, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, fp);<br>    &#125;<br>    <span class="hljs-built_in">fclose</span>(fp);    <br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><h3 id="1-2-Triangle-getIntersection-in-Triangle-hpp"><a href="#1-2-Triangle-getIntersection-in-Triangle-hpp" class="headerlink" title="1.2 Triangle::getIntersection in Triangle.hpp"></a>1.2 <strong>Triangle::getIntersection</strong> in Triangle.hpp</h3><p>这一部分出错较多。首先需要阅读一下框架中的计算，将其中参与运算的变量对应上之前作业5中的计算中间变量。需要编写的部分其实很简单，但是需要注意要把inter的各个成员变量都进行赋值，尤其注意不能漏掉m,normal,obj这些，同时赋值时需要注意参看上面的类的定义。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline Intersection Triangle::get<span class="hljs-constructor">Intersection(Ray <span class="hljs-params">ray</span>)</span><br>&#123;<br>    Intersection inter;<br><br>    <span class="hljs-keyword">if</span> (dot<span class="hljs-constructor">Product(<span class="hljs-params">ray</span>.<span class="hljs-params">direction</span>, <span class="hljs-params">normal</span>)</span> &gt; <span class="hljs-number">0</span>)<br>        return inter;<br>    double u, v, t_tmp = <span class="hljs-number">0</span>;<br>    Vector3f pvec = cross<span class="hljs-constructor">Product(<span class="hljs-params">ray</span>.<span class="hljs-params">direction</span>, <span class="hljs-params">e2</span>)</span>;  <span class="hljs-comment">//s1</span><br>    double det = dot<span class="hljs-constructor">Product(<span class="hljs-params">e1</span>, <span class="hljs-params">pvec</span>)</span>;  <span class="hljs-comment">//dotProduct(s1, e1)</span><br>    <span class="hljs-keyword">if</span> (fabs(det) &lt; EPSILON)<br>        return inter;<br><br>    double det_inv = <span class="hljs-number">1.</span><span class="hljs-operator"> / </span>det;<br>    Vector3f tvec = ray.origin - v0;  <span class="hljs-comment">//s</span><br>    u = dot<span class="hljs-constructor">Product(<span class="hljs-params">tvec</span>, <span class="hljs-params">pvec</span>)</span><span class="hljs-operator"> * </span>det_inv; <span class="hljs-comment">//b1</span><br>    <span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>u &gt; <span class="hljs-number">1</span>)<br>        return inter;<br>    Vector3f qvec = cross<span class="hljs-constructor">Product(<span class="hljs-params">tvec</span>, <span class="hljs-params">e1</span>)</span>;  <span class="hljs-comment">//s2</span><br>    v = dot<span class="hljs-constructor">Product(<span class="hljs-params">ray</span>.<span class="hljs-params">direction</span>, <span class="hljs-params">qvec</span>)</span><span class="hljs-operator"> * </span>det_inv;  <span class="hljs-comment">//b2</span><br>    <span class="hljs-keyword">if</span> (v &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>u + v &gt; <span class="hljs-number">1</span>)<br>        return inter;<br>    t_tmp = dot<span class="hljs-constructor">Product(<span class="hljs-params">e2</span>, <span class="hljs-params">qvec</span>)</span><span class="hljs-operator"> * </span>det_inv;<br><br>    <span class="hljs-comment">// TODO find ray triangle intersection</span><br>    <span class="hljs-keyword">if</span> (t_tmp&gt;<span class="hljs-number">0.0</span>f)<br>    &#123;<br>        inter.distance = t_tmp;<br>        <span class="hljs-comment">// inter.coords = Vector3f(u, v, 1.0); //**Wrong. </span><br>        <span class="hljs-comment">// inter.coords = ray(t_tmp);</span><br>        inter.coords = ray.origin + ray.direction<span class="hljs-operator"> * </span>t_tmp;  <br>        inter.happened = <span class="hljs-literal">true</span>;<br>        inter.m = m;   <span class="hljs-comment">//**Missed. Pay attention to the &quot;m&quot; above!(int class definition)</span><br>        inter.normal = normal;  <span class="hljs-comment">//*Missed. But what is &quot;normal&quot; referring to ?</span><br>        inter.obj = this;       <span class="hljs-comment">//*Missed. obj?  this?</span><br>    &#125;<br>    <br><br>    return inter;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-IntersectP-const-Ray-amp-ray-const-Vector3f-amp-invDir-const-std-array-amp-dirIsNeg-in-the-Bounds3-hpp"><a href="#1-3-IntersectP-const-Ray-amp-ray-const-Vector3f-amp-invDir-const-std-array-amp-dirIsNeg-in-the-Bounds3-hpp" class="headerlink" title="1.3 IntersectP(const Ray&amp; ray, const Vector3f&amp; invDir,const std::array&amp; dirIsNeg) in the Bounds3.hpp"></a>1.3 IntersectP(const Ray&amp; ray, const Vector3f&amp; invDir,const std::array<int, 3>&amp; dirIsNeg) in the Bounds3.hpp</h3><p>这部分没出什么问题，只需要注意一下eigen库的使用，不要把中括号和小括号搞反。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs zephir">inline <span class="hljs-keyword">bool</span> Bounds3::IntersectP(<span class="hljs-keyword">const</span> Ray&amp; ray, <span class="hljs-keyword">const</span> Vector3f&amp; invDir,<br>                                <span class="hljs-keyword">const</span> std::array&lt;<span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>&gt;&amp; dirIsNeg) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-comment">// invDir: ray direction(x,y,z), invDir=(1.0/x,1.0/y,1.0/z), use this because Multiply </span><br>    <span class="hljs-comment">// is faster that Division</span><br>    <span class="hljs-comment">// dirIsNeg: ray direction(x,y,z), dirIsNeg=[int(x&gt;0),int(y&gt;0),int(z&gt;0)], </span><br>    <span class="hljs-comment">// use this to simplify your logic</span><br>    <span class="hljs-comment">// TODO test if ray bound intersects</span><br>    <span class="hljs-keyword">double</span> tenter, texit, tmin, tmax;<br>    texit = std::numeric_limits&lt;<span class="hljs-keyword">double</span>&gt;::max();<br>    tenter = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">double</span> tmin = std::min((pMin[i] - ray.origin[i]) * invDir[i], <br>                                (pMax[i] - ray.origin[i]) * invDir[i]);<br>        <span class="hljs-keyword">double</span> tmax = std::max((pMin[i] - ray.origin[i]) * invDir[i], <br>                                (pMax[i] - ray.origin[i]) * invDir[i]);<br>        tenter = std::max(tenter, tmin);<br>        texit = std::min(texit, tmax);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tenter&lt;texit &amp;&amp; texit&gt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-getIntersection-BVHBuildNode-node-const-Ray-ray-in-BVH-cpp"><a href="#1-4-getIntersection-BVHBuildNode-node-const-Ray-ray-in-BVH-cpp" class="headerlink" title="1.4 getIntersection(BVHBuildNode* node, const Ray ray)in BVH.cpp"></a>1.4 <strong>getIntersection(BVHBuildNode* node, const Ray ray)</strong>in BVH.cpp</h3><p>这部分也相对简单，出错的地方是对于叶子节点返回其中所有物体表面与光线相交的最近点时没写对，这也需要注意相关类的定义。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Intersection BVHAccel::get<span class="hljs-constructor">Intersection(BVHBuildNode<span class="hljs-operator">*</span> <span class="hljs-params">node</span>, <span class="hljs-params">const</span> Ray&amp; <span class="hljs-params">ray</span>)</span> const<br>&#123;<br>    <span class="hljs-comment">// TODO Traverse the BVH to find intersection</span><br>    Intersection isect;<br>    std::<span class="hljs-built_in">array</span>&lt;<span class="hljs-built_in">int</span>, <span class="hljs-number">3</span>&gt; dirIsNeg;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)<br>        dirIsNeg<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-built_in">int</span>(ray.direction<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>&gt;<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!node-&gt;bounds.<span class="hljs-constructor">IntersectP(<span class="hljs-params">ray</span>, <span class="hljs-params">ray</span>.<span class="hljs-params">direction_inv</span>, <span class="hljs-params">dirIsNeg</span>)</span>) <br>        return isect; <span class="hljs-comment">//若光线与bounding box不相交，结束</span><br>    <span class="hljs-comment">//若相交</span><br>    <span class="hljs-comment">//叶子节点，判断节点内部所有物体，返回最近的交点</span><br>    <span class="hljs-keyword">if</span> (node-&gt;left<span class="hljs-operator"> == </span>nullptr<span class="hljs-operator"> &amp;&amp; </span>node-&gt;right<span class="hljs-operator"> == </span>nullptr)<br>        <span class="hljs-comment">// return Intersect(ray);    *Wrong.</span><br>        return node-&gt;<span class="hljs-keyword">object</span>-&gt;get<span class="hljs-constructor">Intersection(<span class="hljs-params">ray</span>)</span>;  <span class="hljs-comment">//Pay attention.</span><br>    Intersection hit1 = get<span class="hljs-constructor">Intersection(<span class="hljs-params">node</span>-&gt;<span class="hljs-params">left</span>, <span class="hljs-params">ray</span>)</span>;<br>    Intersection hit2 = get<span class="hljs-constructor">Intersection(<span class="hljs-params">node</span>-&gt;<span class="hljs-params">right</span>, <span class="hljs-params">ray</span>)</span>;<br>    <span class="hljs-comment">//若节点不是叶子节点，返回两个子节点交点的最近值</span><br>    <span class="hljs-keyword">if</span> (hit1.distance &lt; hit2.distance)<br>        return hit1;<br>    <span class="hljs-keyword">else</span> <br>        return hit2;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5-基础部分实现效果"><a href="#1-5-基础部分实现效果" class="headerlink" title="1.5 基础部分实现效果"></a>1.5 基础部分实现效果</h3><p><img src="https://s2.loli.net/2022/02/27/tlxA9inKOyM27ZL.png" alt="image-20220227222351813"></p>]]></content>
    
    
    <categories>
      
      <category>Games101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graphics</tag>
      
      <tag>Ray Tracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Image relief effect</title>
    <link href="/2022/03/02/Image-relief-effect/"/>
    <url>/2022/03/02/Image-relief-effect/</url>
    
    <content type="html"><![CDATA[<h1 id="图像浮雕效果实现"><a href="#图像浮雕效果实现" class="headerlink" title="图像浮雕效果实现"></a>图像浮雕效果实现</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="浮雕效果定义"><a href="#浮雕效果定义" class="headerlink" title="浮雕效果定义"></a>浮雕效果定义</h3><p>浮雕效果：指计算每个像素点与其周围像素的差值，差别较大的像素点在灰度图像中表现较为亮，边缘凸起，成浮雕形状。效果如下：</p><p><img src="https://s2.loli.net/2022/04/02/lTZ53GdSmavW86I.jpg" alt="test1"></p><center>原图</center><p><img src="https://s2.loli.net/2022/04/02/eG1hOUksz9IHpMq.jpg" alt=""></p><center>浮雕效果图</center><span id="more"></span><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>本作业中采用二维傅里叶变换实现浮雕效果。</p><p>二维傅里叶变换（离散）是一种将图像从空间域转换到频域的变换方法。图像可看作二维矩阵，本作业中的图像为彩色，包含RGB三个通道的灰度信息。利用二维离散傅里叶变换可以将图像从空间域（即二维灰度数表）转换到频域（即频率数表），便于进行频域滤波等操作。</p><p>变换具体公式为：</p><script type="math/tex; mode=display">f(x,y)=\frac{1}{MN}\sum_{u=0}^{M-1}\sum_{v=0}^{N-1}F(u,v)e^{j2\pi(\frac{ux}{M}+\frac{vy}{N})}</script><p>其中$f(x,y)$ 代表大小为 M x N 的图像矩阵(其中$ x = 0,1,2,···,M-1$ 和 $y = 0,1,2,···,N-1$)；$F(u,v)$ 表示 $f(x,y)$ 的傅里叶变换。</p><p>变换完成后，在时域上分别对x、y方向上进行差分叠加，然后借助不同的灰度等级逐步调节矩阵，即可得到浮雕效果。</p><h2 id="Matlab源代码"><a href="#Matlab源代码" class="headerlink" title="Matlab源代码"></a>Matlab源代码</h2><h3 id="relief函数"><a href="#relief函数" class="headerlink" title="relief函数"></a>relief函数</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">result</span> = <span class="hljs-title">relief</span><span class="hljs-params">(image, num)</span>     % <span class="hljs-title">num</span>为通道数</span><br>    [h, w, ~]=<span class="hljs-built_in">size</span>(image);       <br>    <span class="hljs-comment">% 生成每一列对应的jw_x和jw_y</span><br>    fx = <span class="hljs-built_in">linspace</span>(<span class="hljs-built_in">floor</span>(-w/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>, <span class="hljs-built_in">floor</span>(w/<span class="hljs-number">2</span>), w);               <br>    fx = fx / w * <span class="hljs-number">2</span> * <span class="hljs-built_in">pi</span> * <span class="hljs-number">1</span><span class="hljs-built_in">i</span>;                                   <br>    fy = <span class="hljs-built_in">linspace</span>(<span class="hljs-built_in">floor</span>(-h/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>, <span class="hljs-built_in">floor</span>(h/<span class="hljs-number">2</span>), h);<br>    fy = fy&#x27; / h * <span class="hljs-number">2</span> * <span class="hljs-built_in">pi</span> * <span class="hljs-number">1</span><span class="hljs-built_in">i</span>;<br>    <span class="hljs-comment">% 结果初始化</span><br>    result = <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(image));<br>    <span class="hljs-comment">% 逐个通道处理</span><br>    <span class="hljs-keyword">for</span> channel = <span class="hljs-number">1</span>:num                <br>        s = double(image(:, :, channel));<br>        f = fftshift(fft2(s));          <br>        <span class="hljs-comment">% 求差分并叠加</span><br>        df = f.*(<span class="hljs-number">1</span> - <span class="hljs-built_in">exp</span>(-fx)) + f.*(<span class="hljs-number">1</span> - <span class="hljs-built_in">exp</span>(-fy));    <br>        result(:, :, channel)=<span class="hljs-built_in">real</span>(ifft2(ifftshift(df)));<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">% 中心化与规范化</span><br>    result = double(result)./(<span class="hljs-built_in">max</span>(result) - <span class="hljs-built_in">min</span>(result))*<span class="hljs-number">255.0</span> + <span class="hljs-number">128.0</span>; <br>    result = uint8(result);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="主程序-调用relief函数"><a href="#主程序-调用relief函数" class="headerlink" title="主程序(调用relief函数)"></a>主程序(调用relief函数)</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">image_input = imread(<span class="hljs-string">&quot;test.jpg&quot;</span>);<br>image_output = relief(image_input, <span class="hljs-number">3</span>);<br>imshow(image_output);<br></code></pre></td></tr></table></figure><h2 id="测试图片"><a href="#测试图片" class="headerlink" title="测试图片"></a>测试图片</h2><h3 id="测试1-1024-683"><a href="#测试1-1024-683" class="headerlink" title="测试1(1024*683)"></a>测试1(1024*683)</h3><p><img src="https://s2.loli.net/2022/04/02/lTZ53GdSmavW86I.jpg" alt="test"></p><p><img src="https://s2.loli.net/2022/04/02/nHGCoA21lM6Dc5R.jpg" alt="result1"></p><h3 id="测试2-532-300"><a href="#测试2-532-300" class="headerlink" title="测试2(532*300)"></a>测试2(532*300)</h3><p><img src="https://s2.loli.net/2022/04/02/HphNCwv2LRuBdSU.jpg" alt="test2"></p><p><img src="https://s2.loli.net/2022/04/02/lTJCcNjK7GYLuHi.jpg" alt="res2"></p><h3 id="测试3-3840-2160"><a href="#测试3-3840-2160" class="headerlink" title="测试3(3840*2160)"></a>测试3(3840*2160)</h3><p><img src="https://s2.loli.net/2022/04/02/TFGp5gWCBHMIqos.jpg" alt="test4"></p><p><img src="https://s2.loli.net/2022/04/02/43efsyhF5lck9H2.jpg" alt="res4"></p><h3 id="测试4-681-517"><a href="#测试4-681-517" class="headerlink" title="测试4(681*517)"></a>测试4(681*517)</h3><p><img src="https://s2.loli.net/2022/04/02/iFZemb2G38ty5Ld.jpg" alt="test3"></p><p><img src="https://s2.loli.net/2022/04/02/zUSytTfIqwJHjFE.jpg" alt="res3"></p>]]></content>
    
    
    <categories>
      
      <category>courses</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pytorch入门</title>
    <link href="/2022/02/27/pytorch-intro-1/"/>
    <url>/2022/02/27/pytorch-intro-1/</url>
    
    <content type="html"><![CDATA[<h1 id="pytorch入门"><a href="#pytorch入门" class="headerlink" title="pytorch入门"></a>pytorch入门</h1><h2 id="视频链接"><a href="#视频链接" class="headerlink" title="视频链接"></a>视频链接</h2><p><a href="https://www.bilibili.com/video/BV1hE411t7RN?p=12&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1hE411t7RN?p=12&amp;spm_id_from=pageDriver</a></p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>shift+enter 换行（可以在console中换行）</p><p>ctrl+p 看到当前函数需要哪些参数</p><h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><p>jupyter适合于查看帮助文档等</p><span id="more"></span><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h3><p>windows下文件路径使用\\\\</p><p>尽量使用相对路径，绝对路径在windows下可能被当成转义符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># absolute path = &quot;E:\coding\torch_test\images\5e233a14c9334a84a879795ee679d2c1.jpg&quot;</span><br><span class="hljs-comment"># relative path = &quot;images/5e233a14c9334a84a879795ee679d2c1.jpg&quot;</span><br>img_path = <span class="hljs-string">&quot;images/5e233a14c9334a84a879795ee679d2c1.jpg&quot;</span><br>img_path_abs = <span class="hljs-string">&quot;E:\coding\torch_test\images\5e233a14c9334a84a879795ee679d2c1.jpg&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/28/gih2H698MoN1ElB.png" alt="image-20220328105947199"></p><hr><h2 id="2022-3-27"><a href="#2022-3-27" class="headerlink" title="2022.3.27"></a>2022.3.27</h2><h2 id="PyCharm控制台python-shell与IPython-shell的切换"><a href="#PyCharm控制台python-shell与IPython-shell的切换" class="headerlink" title="PyCharm控制台python shell与IPython shell的切换"></a>PyCharm控制台python shell与IPython shell的切换</h2><p>详见<a href="https://www.cnblogs.com/miaoning/p/11069224.html">https://www.cnblogs.com/miaoning/p/11069224.html</a></p><p>但是要注意需要在conda的环境中安装IPython</p><h2 id="Anaconda-Prompt-切换工作路径"><a href="#Anaconda-Prompt-切换工作路径" class="headerlink" title="Anaconda Prompt 切换工作路径"></a>Anaconda Prompt 切换工作路径</h2><p>首先切到C盘根目录下，然后直接输入对应盘符号即可</p><p><img src="https://s2.loli.net/2022/03/27/2MnYlUpbsi51FzG.png" alt="image-20220327100336654"></p><h2 id="Tensorboard"><a href="#Tensorboard" class="headerlink" title="Tensorboard"></a>Tensorboard</h2><p>打开log文件并指定端口(此处为 <a href="http://localhost:6007/">http://localhost:6007/</a>)</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">tensorboard <span class="hljs-attribute">--logdir</span>=logs <span class="hljs-attribute">--port</span>=6007<br></code></pre></td></tr></table></figure><p>demo1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br><br><span class="hljs-comment"># writer.add_image()</span><br><span class="hljs-comment"># y=x</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    writer.add_scalar(<span class="hljs-string">&quot;y=2x&quot;</span>,<span class="hljs-number">2</span>*i,i)<br><br>writer.close()<br></code></pre></td></tr></table></figure><p>效果图</p><p><img src="https://s2.loli.net/2022/03/27/OePvM3taE5UxznY.png" alt="image-20220327124109596"></p><hr><h2 id="2022-3-28"><a href="#2022-3-28" class="headerlink" title="2022.3.28"></a>2022.3.28</h2><h2 id="Transforms"><a href="#Transforms" class="headerlink" title="Transforms"></a>Transforms</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p><img src="https://s2.loli.net/2022/03/28/c2sz5tXZdorIQAe.png" alt="image-20220328110649328"> </p><p>关注官方文档，函数的输入输出，使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>())<br></code></pre></td></tr></table></figure><p>等方式尝试了解数据类型。</p><p>demo：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><br><span class="hljs-comment"># absolute path = &quot;E:\coding\torch_test\images\5e233a14c9334a84a879795ee679d2c1.jpg&quot;</span><br><span class="hljs-comment"># relative path = &quot;images/5e233a14c9334a84a879795ee679d2c1.jpg&quot;</span><br>img_path = <span class="hljs-string">&quot;images/5e233a14c9334a84a879795ee679d2c1.jpg&quot;</span><br><span class="hljs-comment"># img_path_abs = &quot;E:\coding\torch_test\images\5e233a14c9334a84a879795ee679d2c1.jpg&quot;</span><br>img = Image.<span class="hljs-built_in">open</span>(img_path)<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;cslogs&quot;</span>)<br><br><span class="hljs-comment"># ToTensor</span><br>tensor_ToTensor = transforms.ToTensor()  <span class="hljs-comment"># 创建ToTensor对象</span><br>img_tensor = tensor_ToTensor(img)        <span class="hljs-comment"># 这里其实调用了ToTensor的内置函数</span><br>writer.add_image(<span class="hljs-string">&quot;ToTensor&quot;</span>, img_tensor)<br><br><span class="hljs-comment"># Normalize</span><br>tensor_norm = transforms.Normalize([<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])<br>img_norm = tensor_norm(img_tensor)<br>writer.add_image(<span class="hljs-string">&quot;Normalize&quot;</span>, img_norm)<br><br><span class="hljs-comment"># Resize</span><br>tensor_resize = transforms.Resize([<span class="hljs-number">512</span>, <span class="hljs-number">512</span>])<br><span class="hljs-comment"># PIL --&gt;Resize--&gt; resize PIL --&gt;ToTensor--&gt; resize tensor</span><br>img_resize = tensor_ToTensor(tensor_resize(img))<br>writer.add_image(<span class="hljs-string">&quot;Resize&quot;</span>, img_resize, <span class="hljs-number">0</span>)<br><span class="hljs-comment"># Compose style</span><br>tensor_resize_2 = transforms.Resize(<span class="hljs-number">512</span>)<br>tensor_compose = transforms.Compose([tensor_resize_2, tensor_ToTensor])<br>img_resize_compose = tensor_compose(img)<br>writer.add_image(<span class="hljs-string">&quot;Resize&quot;</span>, img_resize_compose, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># RandomCrop</span><br>tensor_random = transforms.RandomCrop(<span class="hljs-number">512</span>)<br>tensor_compose_2 = transforms.Compose([tensor_random, tensor_ToTensor])<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">25</span>):<br>    img_crop = tensor_compose_2(img)<br>    writer.add_image(<span class="hljs-string">&quot;RamdomCrop&quot;</span>, img_crop, i)<br><br>writer.close()<br></code></pre></td></tr></table></figure><h2 id="Torchvision数据集使用"><a href="#Torchvision数据集使用" class="headerlink" title="Torchvision数据集使用"></a>Torchvision数据集使用</h2><p>以<a href="https://pytorch.org/vision/stable/generated/torchvision.datasets.CIFAR10.html#torchvision.datasets.CIFAR10"><code>CIFAR10</code></a>为例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br>dataset_transform = torchvision.transforms.Compose([<br>    torchvision.transforms.ToTensor()<br>])<br><span class="hljs-comment"># 一般download选项都设置为true</span><br>train_set = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./dataset&quot;</span>, train=<span class="hljs-literal">True</span>, transform=dataset_transform, download=<span class="hljs-literal">True</span>)<br>test_set = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./dataset&quot;</span>, train=<span class="hljs-literal">False</span>, transform=dataset_transform, download=<span class="hljs-literal">True</span>)<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;P10&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    img, tatget = train_set[i]<br>    writer.add_image(<span class="hljs-string">&quot;Train Images&quot;</span>, img, i)<br><br>writer.close()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOP-1</title>
    <link href="/2022/02/20/OOP-1/"/>
    <url>/2022/02/20/OOP-1/</url>
    
    <content type="html"><![CDATA[<h1 id="02-What-is-Object-Oriented"><a href="#02-What-is-Object-Oriented" class="headerlink" title="02 What is Object-Oriented"></a>02 What is Object-Oriented</h1><h2 id="Objects-Attributes-Services"><a href="#Objects-Attributes-Services" class="headerlink" title="Objects=Attributes+Services"></a>Objects=Attributes+Services</h2><p><img src="https://s2.loli.net/2022/03/20/ha4mFAnYDUMuBlE.png" alt="image-20220320213015024"></p><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>​    properties or status</p><h3 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h3><p>​     functions</p><span id="more"></span><h2 id="Comparision-C-amp-amp-C"><a href="#Comparision-C-amp-amp-C" class="headerlink" title="Comparision: C &amp;&amp; C++"></a>Comparision: C &amp;&amp; C++</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//C style</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point3d</span>&#123;</span><br>    <span class="hljs-type">float</span> x;<br>    <span class="hljs-type">float</span> y;<br>    <span class="hljs-type">float</span> z;<br>&#125;Point3d;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Point3d_print</span><span class="hljs-params">(<span class="hljs-type">const</span> Point3d* pd)</span>;<br>Point3d a;<br>a.x = <span class="hljs-number">1</span>;<br>a.y = <span class="hljs-number">2</span>;<br>a.z = <span class="hljs-number">3</span>;<br>Point3d_print(&amp;a);<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//C++ style</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point3d</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Point3d</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> z);<br><span class="hljs-built_in">print</span>();<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">float</span> x;<br><span class="hljs-type">float</span> y;<br><span class="hljs-type">float</span> z;<br>&#125;;<br><br><span class="hljs-function">Point3d <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;<br>a.<span class="hljs-built_in">print</span>();<br></code></pre></td></tr></table></figure><h2 id="What-is-object-oriented"><a href="#What-is-object-oriented" class="headerlink" title="What is object-oriented"></a>What is object-oriented</h2><p>A way to organize <strong>Designs</strong> and <strong>Implementations</strong></p><p>To focus on things, not operations.</p><h1 id="03-Fundamental-of-OOP"><a href="#03-Fundamental-of-OOP" class="headerlink" title="03 Fundamental of OOP"></a>03 Fundamental of OOP</h1><h2 id="Objects-send-and-receive-messages"><a href="#Objects-send-and-receive-messages" class="headerlink" title="Objects send and receive messages"></a>Objects send and receive messages</h2><p><img src="https://s2.loli.net/2022/03/20/kMynmbp56TcXoJC.png" alt="image-20220320215335376"><strong>Messages</strong> are:<br>    -Composed by the sender<br>    -<strong>Interperted by the receiver</strong>(重点：让接收者自己决定执行什么动作，不接触类的data)<br>    -Implemented by the methods </p><h2 id="Object-vs-Class"><a href="#Object-vs-Class" class="headerlink" title="Object vs. Class"></a>Object vs. Class</h2><p><img src="https://s2.loli.net/2022/03/20/CU7JmPDhMLqAyNp.png" alt="image-20220320220933094"></p><h2 id="OOP-Characteristics"><a href="#OOP-Characteristics" class="headerlink" title="OOP Characteristics"></a>OOP Characteristics</h2><ol><li>Everything is an object.</li><li>A program is a brunch of objects telling each other <strong>what</strong> to do by sending messages.(<strong>WHAT, not HOW!</strong>)</li><li>Each object has its own memory made up of other objects.</li><li>Every object has a type.</li><li>All objects of a particular type can receive the same messages.(<strong>反过来也成立，即可以接受相同消息的对象属于相同类型</strong>)</li></ol><h2 id="Functions-of-the-Interface"><a href="#Functions-of-the-Interface" class="headerlink" title="Functions of the Interface"></a>Functions of the Interface</h2><p><strong>-communication</strong></p><p><strong>-protection</strong></p><p>OOP程序设计中希望实现<strong>松耦合</strong></p><h2 id="Encapsulation-封装"><a href="#Encapsulation-封装" class="headerlink" title="Encapsulation(封装)"></a>Encapsulation(封装)</h2><p>Bundle <strong>data</strong> and <strong>methods</strong> dealing with these data together in an object.</p><p><strong>Hide</strong> the details of the data and the actions.</p><p>Restrict only access to the <strong>publicized methods</strong>. </p><h1 id="04-Example-Ticket-Machine"><a href="#04-Example-Ticket-Machine" class="headerlink" title="04 Example: Ticket Machine"></a>04 Example: Ticket Machine</h1><h2 id="规范"><a href="#规范" class="headerlink" title="[规范]"></a>[规范]</h2><p>project: 使用全小写字母，如 ticketmachine</p><p>class: 首字母大写，如 TicketMachine</p><h2 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h2><p>每个类都应当包含<strong>.h</strong>和<strong>.cpp</strong>两个文件</p><p>.h中声明，.cpp中定义</p><p>:: 称为域解析符</p>]]></content>
    
    
    <categories>
      
      <category>OOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Signals &amp; Systems Review-CH1</title>
    <link href="/2022/02/03/Signals-Systems-Review-CH1/"/>
    <url>/2022/02/03/Signals-Systems-Review-CH1/</url>
    
    <content type="html"><![CDATA[<h1 id="Signals-and-Systems-Review-CH1"><a href="#Signals-and-Systems-Review-CH1" class="headerlink" title="Signals and Systems Review - CH1"></a>Signals and Systems Review - CH1</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><h3 id="信息-消息-信号"><a href="#信息-消息-信号" class="headerlink" title="信息.消息.信号"></a>信息.消息.信号</h3><p>例子：<strong>电信号</strong>传递<strong>声音、图像、文字</strong></p><p>信号是消息的表现形式，消息是信号的具体内容</p><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><p>包括变换器、处理器等</p><p>$\Leftrightarrow$网络$\Leftrightarrow$电路</p><h3 id="信号分析"><a href="#信号分析" class="headerlink" title="信号分析"></a>信号分析</h3><p>目的：揭示信号特性及其改变方式</p><p>思想：分解成<strong>简单基本单元信号</strong></p><h3 id="系统分析"><a href="#系统分析" class="headerlink" title="系统分析"></a>系统分析</h3><p>对指定输入激励的输出响应</p><span id="more"></span><h2 id="1-2-信号描述"><a href="#1-2-信号描述" class="headerlink" title="1.2 信号描述"></a>1.2 信号描述</h2><h3 id="确定性信号-amp-随机信号"><a href="#确定性信号-amp-随机信号" class="headerlink" title="确定性信号&amp;随机信号"></a>确定性信号&amp;随机信号</h3><p>确定性信号：对于指定的某一时刻t，可确定一相应的函数值f(t)，<strong>若干不连续点除外</strong></p><h3 id="连续信号-amp-离散信号"><a href="#连续信号-amp-离散信号" class="headerlink" title="连续信号&amp;离散信号"></a>连续信号&amp;离散信号</h3><p>连续时间信号：自变量的取值范围是连续的（实数域），用t表示连续时间变量</p><p><img src="https://s2.loli.net/2022/04/03/4n1XgovF9skeYxf.png" alt="image-20220403145759285"></p><p>离散时间信号：自变量只取整数值的信号，用n表示离散时间变量</p><p><img src="https://s2.loli.net/2022/04/03/AT9Lcu6gwNjzt5n.png" alt="image-20220403145826087"></p><h3 id="周期信号-amp-非周期信号"><a href="#周期信号-amp-非周期信号" class="headerlink" title="周期信号&amp;非周期信号"></a>周期信号&amp;非周期信号</h3><p>周期信号：满足$x(t+T)=x(t)\space or\space x(n+N)=x(n)$</p><p><img src="https://s2.loli.net/2022/04/03/BSGRMUk9y7hz3qv.png" alt="image-20220403150009283"></p><h3 id="模拟、量化、抽样"><a href="#模拟、量化、抽样" class="headerlink" title="模拟、量化、抽样"></a>模拟、量化、抽样</h3><p>模拟信号：时间和幅值均连续</p><p><img src="https://s2.loli.net/2022/04/03/FzBOlVEjmLMw6UI.png" alt="image-20220403150055042"></p><p>抽样信号：时间离散，幅值连续</p><p><img src="https://s2.loli.net/2022/04/03/ydisMXkzvrFhPAE.png" alt="image-20220403150125448"></p><p>数字信号：时间和幅值均为离散</p><p><img src="https://s2.loli.net/2022/04/03/ewizHKBP49g5Dh2.png" alt="image-20220403150143318"></p><p>【模拟】$\rightarrow$抽样$\rightarrow$【抽样】$\rightarrow$量化$\rightarrow$【数字】</p><p>时间离散性$\Rightarrow$连续、离散</p><p>幅度离散型$\Rightarrow$(离散)抽样、数字</p><h3 id="能量信号-amp-功率信号"><a href="#能量信号-amp-功率信号" class="headerlink" title="能量信号&amp;功率信号"></a>能量信号&amp;功率信号</h3><p><strong>周期信号为功率信号</strong>，通常用它的平均功率来表征；</p><p>非周期信号可能为能量信号，也可能为功率信号，与函数形式有关。</p><h3 id="典型确定性信号"><a href="#典型确定性信号" class="headerlink" title="典型确定性信号"></a>典型确定性信号</h3><h4 id="指数信号"><a href="#指数信号" class="headerlink" title="指数信号"></a>指数信号</h4><script type="math/tex; mode=display">f(t)=e^{\alpha t}</script><p><img src="https://s2.loli.net/2022/04/03/rMvd6plFLuqRQJj.png" alt="image-20220403150704589"></p><p>单边指数信号</p><p><img src="https://s2.loli.net/2022/04/03/lmI4JewqxkBbhE2.png" alt="image-20220403150841141"></p><p>时间常数：$\tau = \frac{1}{|\alpha|}$，量纲为时间，代表衰减速度</p><p>重要特性：积分、微分仍是指数形式</p><h4 id="复指数信号"><a href="#复指数信号" class="headerlink" title="复指数信号"></a>复指数信号</h4><script type="math/tex; mode=display">f(t)=Ke^{st}</script><p>其中$s=\sigma + j\omega$为复数，称为<strong>复频率</strong></p><script type="math/tex; mode=display">f(t)=Ke^{\sigma t}cos(\omega t)+jKe^{\sigma t}sin{\omega t}</script><p><img src="https://s2.loli.net/2022/04/03/RzL5ltykH7YdSZn.png" alt="image-20220403152631396"></p><p><img src="https://s2.loli.net/2022/04/03/Xif2SUOuL5jtaQc.png" alt="image-20220403152644234"></p><p><img src="https://s2.loli.net/2022/04/03/qjpdZNm9OWzU8iv.png" alt="image-20220403152650531"></p><p><img src="https://s2.loli.net/2022/04/03/B6sfcMivy7NUCFQ.png" alt="image-20220403152712908"></p><h4 id="抽样信号"><a href="#抽样信号" class="headerlink" title="抽样信号"></a>抽样信号</h4><script type="math/tex; mode=display">Sa(t)=\frac{sin t}{t}</script><p><img src="https://s2.loli.net/2022/04/03/2IPsxX4wRUOe713.png" alt="image-20220403152927876"></p><p>性质：</p><script type="math/tex; mode=display">Sa(t)=Sa(-t)\space (偶函数)\\lim_{t\rightarrow0}Sa(t)=1 \\lim_{t\rightarrow \pm \infty}Sa(t)=0 \space(正负无穷都满足)\\Sa(\pm n\pi)=0\space,n=1,2,3,...(没有0！注意！) \\\int_0^{\infty}Sa(t)dt=\frac{\pi}{2} \\</script><p>sinc函数</p><script type="math/tex; mode=display">sinc(t)=\frac{sin(\pi t)}{\pi t}</script><p>钟形信号(高斯函数)</p><script type="math/tex; mode=display">f(t)=Ee^{-(\frac{t}{\tau})^2}</script><p><img src="https://s2.loli.net/2022/04/03/iqmZwhFfMn24Dgb.png" alt="image-20220403153806039"></p><h2 id="1-3-信号运算"><a href="#1-3-信号运算" class="headerlink" title="1.3 信号运算"></a>1.3 信号运算</h2><h3 id="宗量"><a href="#宗量" class="headerlink" title="宗量"></a>宗量</h3><p>宗量：可以理解为广义的自变量。这里的“广义”是指：自变量突破高中数学中的限制，可以是狭义的自变量，可以是函数，也可以是代数式……</p><p>可以依据<strong>宗量相同，函数值相同</strong>，求新坐标<strong>（！！！！）</strong></p><h3 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h3><p>f(t)沿着t轴平移$\tau$得到</p><script type="math/tex; mode=display">f(t)\rightarrow f(t-\tau) \\\tau>0，右移（滞后） \\\tau<0，左移（超前）</script><p>可以依据<strong>宗量相同，函数值相同</strong>，求新坐标</p><p><img src="https://s2.loli.net/2022/04/03/Z2e4LncSRoWdwDI.png" alt="image-20220403165602982"></p><h3 id="反褶"><a href="#反褶" class="headerlink" title="反褶"></a>反褶</h3><script type="math/tex; mode=display">f(t)\rightarrow f(-t)</script><p>以纵轴为轴折叠，把信号的过去与未来对调。</p><p><strong>没有可实现此功能的实际器件</strong>。</p><p>数字信号处理中可以实现此概念，例如堆栈中的“后进先出”。</p><h3 id="尺度"><a href="#尺度" class="headerlink" title="尺度"></a>尺度</h3><script type="math/tex; mode=display">f(t)\rightarrow f(at)</script><p><img src="https://s2.loli.net/2022/04/03/TlmWDrZyvCXLOxH.png" alt="image-20220403165916331"></p><p><img src="https://s2.loli.net/2022/04/03/wH2BiVhy6JCURcr.png" alt="image-20220403165931513"></p><h3 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h3><script type="math/tex; mode=display">f(t)\rightarrow f(at\pm b)=f(a(t\pm \frac{b}{a})) \space (a,b>0)</script><p><strong>Steps:</strong></p><p>1.尺度：a&gt;1，压缩a倍；a&lt;1，扩展1/a倍</p><p>2.移位：+，左移b/a；-，右移b/a</p><p>3.反褶：</p><script type="math/tex; mode=display">f(a(t+\frac{b}{a}))\rightarrow f(-a(t+\frac{b}{a}))=f(-at- b)</script><p>1.平移量t0是自变量t净增减的量，即以f(t-t0)为标准形式来确定t0</p><p>2.反转时以被变换的宗量$\lambda=0$( 可以是t的复合函数）的直线为轴，即以f(-$\lambda$)为标准形式确定反转轴</p><p>3.尺度变换应以被变换的宗量$\lambda=0$(的直线为展缩中心线，即以f(a $\lambda$)为标准形式确定展缩中心线</p>]]></content>
    
    
    <categories>
      
      <category>courses</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Signals</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
