<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>彩色图像处理基础</title>
    <link href="/2022/12/17/%E5%BD%A9%E8%89%B2%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/12/17/%E5%BD%A9%E8%89%B2%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="彩色图像处理基础"><a href="#彩色图像处理基础" class="headerlink" title="彩色图像处理基础"></a>彩色图像处理基础</h1><h2 id="彩色基础"><a href="#彩色基础" class="headerlink" title="彩色基础"></a>彩色基础</h2><h3 id="颜色的描述"><a href="#颜色的描述" class="headerlink" title="颜色的描述"></a>颜色的描述</h3><p>物体本身的颜色是由光反射所产生的，这种反射是由物体的物理性质决定的，不同的物体由于光的吸收、发射光谱等因素的差异拥有了不一样的颜色。但人类对颜色的解释则更为复杂，这种解释主要来源于生活经验，我们通过视觉感知到的特征对光的颜色类别进行描述，往往还伴随着心理和生理因素的影响，难以定量分析，因此这里所讨论的颜色主要指由物体物理性质决定的颜色。</p><p>一般意义上的彩色光波长范围为$[400nm,700nm]$，描述彩色光源的物理量主要包括：</p><ul><li>辐射亮度：指从光源流出的总能量，单位为$W$；</li><li>发光强度：指观察者从光源感知到的总能量，单位为$lm$；</li><li>亮度：体现了发光强度的消色概念，是一个主观描述子，在后文的彩色模型中会详细讨论。</li></ul><p>出于标准化描述的考虑，国际照明委员会(CIE)规定了三原色的波长：</p><script type="math/tex; mode=display">\left\{\begin{matrix}\lambda_{Red}=700nm \\ \lambda_{Green}=546.1nm\\ \lambda_{Blue}=435.8nm\end{matrix}\right.</script><p>需要强调的是，与“原色”本身的字面含义不同，规定三原色的目的仅仅是为了标准化描述，并不意味着以不同的发光强度混合这三种标准原色就能产生所有的可见颜色。</p><p>光的原色和颜料的原色定义不同，颜料的原色定义为减去或吸收光的一种原色，同时反射或投射其他两种原色，因此颜料的原色恰好对应于光的二次色，即深红色(红色+蓝色)、青色(绿色+蓝色)、黄色(红色+绿色)，这两套原色体系的对比如图所示：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/1280px-AdditiveColorMixing.5mwgxb0zzxs0.webp" alt="1280px-AdditiveColorMixing"></p><center>光的原色</center><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/SubtractiveColorMixing.1hdcek9hw8jk.webp" alt="SubtractiveColorMixing"></p><center>颜料的原色</center><p>我们可定义形成任意特殊颜色的红色量、绿色量和蓝色量为三色值，记作$X,Y,Z$，并定义三色系数为</p><script type="math/tex; mode=display">\left\{\begin{matrix}x=\frac{X}{X+Y+Z}\\ y=\frac{Y}{X+Y+Z}\\ z=\frac{Z}{X+Y+Z}\end{matrix}\right.</script><p>由此可以通过三色系数来规定某种色彩。</p><h3 id="色度与色度图"><a href="#色度与色度图" class="headerlink" title="色度与色度图"></a>色度与色度图</h3><p>不同颜色之间的区分主要依靠人为引入的描述量亮度、色调和饱和度，这将会在下文的HSI模型中详细讨论，这里可以简单理解为：亮度作为主观描述子体现发光强度的消色概念；色调表示了观察者感知到的主导颜色；饱和度表示了与某种色调混合的白光量，体现了颜色的相对纯度。通常将色调和饱和度一起称为色度，由此一种颜色可以通过其亮度和色度来表征。</p><p>通过CIE色度图也可以对颜色进行规定。如下所示：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/1280px-PlanckianLocus.2ontzcg9eea0.webp" alt="1280px-PlanckianLocus"></p><p>这里的$x,y$即为上文所述的三色系数，表示红色和绿色所占的比例，对于任意点的$x,y$值可以计算出$z$(蓝色)值：</p><script type="math/tex; mode=display">z=1-x-y</script><p>色度图的舌形边界给出了光谱中的纯色所在位置，它们是完全饱和的，其波长范围为$[380nm,780nm]$。除边界外位于色度图内部的点均表示混合色，特别地，图中白光对应的点称为<strong>等能量点</strong>，代表了三原色的等比例混合，其饱和度为0，标注在下图中。一个点越远离边界、越接近等能量点，其饱和度越低。</p><p>色度图中任意两点的连线段定义了不同的颜色变化，例如连接纯红色点和纯蓝色点的线段上所有点的颜色都是由纯红色和纯蓝色混合得到，根据颜色混合比例的不同可能更靠近红色端或更靠近蓝色端。这一结论可以推广到三个点的情况，即连接三个颜色点中的任意两点可以得到一个”颜色三角形“，这个三角形边界上及其内部的任何点对应的颜色都可以由三个顶点对应的颜色组合产生。由此我们可以得到RGB三原色所能产生的颜色范围：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/CIExy1931_AdobeWGRGB.eua5nntifog.webp" alt="CIExy1931_AdobeWGRGB"></p><p>可以看到这个三角形并未覆盖整个色度图，这也再次验证了三原色的并非意味着可以通过对它们的不同比例混合产生所有的颜色。这一特殊的颜色范围称为<strong>彩色域</strong>，同时这也是今天高质量彩色打印设备的彩色域。</p><h2 id="彩色模型"><a href="#彩色模型" class="headerlink" title="彩色模型"></a>彩色模型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>彩色模型(又称彩色空间、彩色系统)为我们定义了颜色坐标系及其内部的子空间。通过这种定义，模型内部的每种颜色都可以用子空间内包含的一个点表示，从而通过一种标准的方式规定了颜色的表达。</p><p>如今大部分彩色模型都可以划分为为面向硬件和面向应用两类。常见的模型包括：</p><ul><li>面向硬件：RGB模型、CMY模型、CMYK模型，主要面向彩色显示器、彩色摄像机、彩色打印等；</li><li>面向应用：HSI模型，主要面向人类对颜色的描述和解释。</li></ul><p>下面将介绍常见的几个色彩模型。</p><h3 id="RGB彩色模型"><a href="#RGB彩色模型" class="headerlink" title="RGB彩色模型"></a>RGB彩色模型</h3><p>RGB彩色模型(又称三原色光模型或红绿蓝颜色模型，下称RGB模型)，是一种加色模型，即将红(Red)、绿(Green)、蓝(Blue)三原色的色光以不同的比例相加，以合成产生各种色彩光。</p><p>RGB模型中的颜色坐标系是根据笛卡尔坐标系建立的，如图所示为RGB坐标系，其中的三个坐标轴分别代表RGB三种颜色的分量。</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/image-20221125150432499.6g77sno7k400.webp" alt="image-20221125150432499"></p><p>假定所有的颜色值已经归一化，颜色表示中R,G,B的值都位于[0,1]内，我们可以得到一个如图所示的单位立方体，即RGB彩色立方体：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/RGB_color_solid_cube.6w49z2kg37k0.webp" alt="RGB_color_solid_cube"></p><p>RGB模型中的颜色都是位于立方体内部或立方体上的点，可以定义为从坐标系原点向外延伸的向量。其中RGB的三原色位于单位立方体沿三根轴方向分布的三个顶点上：红色$(1,0,0)$，绿色$(0,1,0)$，蓝色$(0,0,1)$，它们混合形成的二次色则位于与之相邻的另外三个顶点上：黄色$(1,1,0)$，深红色$(1,0,1)$，青色$(0,1,1)$，此外还有两个特殊的颜色的位置是黑色$(0,0,0)$和白色$(1,1,1)$，它们的连线是立方体的一条体对角线，同时也是灰度级也沿着这条连线从黑色变为白色。</p><p>RGB模型中图像由三幅分量图像组成，实际应用中送入RGB显示器时将会合并三种原色对应的图像得到一幅彩色图像，一个三通道分解的实例如下：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/xpixel图片修改.3r3ucd0pus40.webp" alt="xpixel图片修改"></p><p>定义表示每个像素所用的比特数为<strong>像素深度</strong>，则如果我们有一幅RGB图像三个分量图像均为$x$比特图像，它的每个RGB像素的像素深度为$3x$比特。特别地，当像素深度达到24比特时称为<strong>全彩色图像</strong>。</p><p>值得注意的是，对于确定了像素深度的图像，在未归一化前坐标轴的值域要做相应改变，例如对于8比特图像，值域为$[0,255]$，白色的坐标为$(255,255,255)$。</p><h3 id="CMY与CMYK彩色模型"><a href="#CMY与CMYK彩色模型" class="headerlink" title="CMY与CMYK彩色模型"></a>CMY与CMYK彩色模型</h3><h4 id="CMY模型"><a href="#CMY模型" class="headerlink" title="CMY模型"></a>CMY模型</h4><p>CMY彩色模型使用青色（Cyan）、深红色（Magenta）、黄色（Yellow）三种颜料原色构成彩色模型，将红色、绿色和蓝色作为二次色。下图是这一颜色模型的叠色示意：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/顏色減法.2b3g8z0js84k.webp" alt="顏色減法"></p><p>其对应的坐标系和归一化后得到的彩色立方体如下：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/cmyclrs1.4fq3owtjmto.webp" alt="cmyclrs1"></p><p>CMY模型和RGB模型存在着简单的转换关系：</p><script type="math/tex; mode=display">\begin{bmatrix}C\\ M\\ Y\end{bmatrix}=\begin{bmatrix}1\\1\\ 1\end{bmatrix}-\begin{bmatrix}R\\G\\ B\end{bmatrix}</script><p>这里的转换关系公式应用于图像中的独立像素，并假设已经进行过归一化，下同。</p><p>由这一转换关系可以看出，$R$分量的增大会导致$C$分量的减小，极限情况下有$R=1,C=0$，这表明<strong>纯</strong>青色颜料不反射红光。同理我们也可以得到<strong>纯</strong>深红色颜料不反射绿光，<strong>纯</strong>黄色材料不反射蓝光等。</p><h4 id="CMYK模型"><a href="#CMYK模型" class="headerlink" title="CMYK模型"></a>CMYK模型</h4><p>CMYK模型，被普遍称为<strong>“印刷四分色模式”</strong>，是彩色印刷时采用的一种套色模式。它利用色料的三原色混色原理，加上黑色油墨，共计四种颜色混合叠加，形成所谓“全彩印刷”的效果。使用的四种颜色简称为CMYK，如下图所示。其中CMY与上面介绍的CMY模型完全一致，不同之处在于引入黑色(K,全称Key plate)构成印刷四分色模式，因而得到了更广泛的应用。</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/CMYK_color_swatches.3k79hum80f.webp" alt="CMYK_color_swatches"></p><p>CMY到CMYK的转换关系为</p><script type="math/tex; mode=display">\left\{\begin{matrix}{C}'=0\\ M'=0\\ Y'=0\end{matrix}\right.,where~k=0 \\</script><script type="math/tex; mode=display">\left\{\begin{matrix}C'=(C-K)/(1-K)\\ M'=(M-K)/(1-K)\\ Y'=(Y-K)/(1-K)\end{matrix}\right.,where~k\neq 0</script><p>CMYK到CMY的转换则为：</p><script type="math/tex; mode=display">\left\{\begin{matrix}C=C'(1-K)+K\\M=M'(1-K)+K \\ Y=Y'(1-K)+K\end{matrix}\right.</script><p>式中带$’$的量属于CMYK系统，不带$’$的量属于CMY系统。</p><h3 id="HSI模型"><a href="#HSI模型" class="headerlink" title="HSI模型"></a>HSI模型</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>前面所述的RGB模型、CMY模型、CMYK模型彼此之间存在简单的转换关系，因此非常适合于硬件实现，同时也符合人眼对于相应原色的较强感知。但是这类颜色模型都存在类似的弊端。例如已知三种原色混合的百分比，我们不能直接给出颜色混合的结果；给定某一颜色，我们也无法给出单一的颜色组合或者区间来描述它，换言之，这类颜色模型在彩色图像生成方面是理想的，但在描述颜色方面存在劣势，会增大图像分析与处理的工作量，而接下来引入的HSI模型则解决了这一问题。</p><p>HSI颜色模型是美国色彩学家孟塞尔(H.A.Munseu)于1915年提出的，它反映了人的视觉系统感知彩色的方式，用H、S、I三参数描述颜色特性，这三个量是人们从现实图像世界抽象出来的概念，这套概念比RGB模型更符合人的视觉特性，因此HSI模型在描述人类实际解释的颜色方面有较大的优势。</p><ul><li>色调</li></ul><p>色调定义颜色的频率，用H表示，这是一种描述纯色的属性，例如我们可以说某个彩色物体的色调是纯蓝色、亮黄色或者红色。</p><p>图示表示中，H用角度$(0-360^\circ)$表示它反映颜色最接近的光谱波长，如红色为$0^\circ$，绿色为$120^\circ$，蓝色为$240^\circ$。</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/image-20221125172626586.1wauy01xv3fk.webp" alt="image-20221125172626586"></p><ul><li>饱和度</li></ul><p>饱和度表示颜色的深浅程度，用S表示，是纯色被白光稀释的程度的度量，一种颜色的饱和度越高，它就越鲜艳；反之，一种颜色的饱和度越低，它就越接近于灰色。调节饱和度，我们可以得到图像上明显的差异效果：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/Saturation_change_photoshop.2o8yqc10g040.webp" alt="Saturation_change_photoshop"></p><p>如果用色环图示进行表示，则S代表色环的原点到彩色点的半径长度。例如在下图中，有向线段的外端点为纯色，其饱和度为1(100%)，而线段根部(原点处)，饱和度为0(0%)。</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/image-20221125173459533.2mfvojy5l4q0.webp" alt="image-20221125173459533"></p><ul><li>亮度</li></ul><p>亮度是一个不可测量的主管描述子，一般用I表示，它体现了发光强度的消色概念，也是描述彩色感觉的关键参数之一。</p><p>与亮度相似的一个概念是<strong>明度</strong>，一般用V表示，用明度替换亮度即可得到与HSI模型类似的HSV模型。两者的联系是：一种纯色的明度等于白色的明度，而纯色的亮度等于中度灰的亮度，换言之，即明度值是相对1处而言，亮度值是相对0.5处而言。</p><p>不论颜色如何，明度分布范围为从最亮1(100%)到最暗0(0%):</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/image-20221126113125215.44gqof9ybc60.webp" alt="image-20221126113125215"></p><p>而亮度分布范围则是从最亮0.5(50%)到最暗0(0%)再到最亮0.5(50%)：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/image-20221126113114491.1dnj5gg9apfk.webp" alt="image-20221126113114491"></p><p>颜色模型需要满足唯一性，即模型内一确定点对应的颜色应唯一，同时外界一确定颜色对应的模型内点也应唯一。上文所述的H、S两者可以构成一个圆，I垂直于这个圆面，将他们表示在一个空间中可以得到一个圆柱，但该圆柱颜色空间不满足唯一性，因此并不适用于做颜色模型(例如当$I=0$时，HS将没有意义，圆柱的整个底面都是黑色)。</p><p>由此我们将圆柱的底部挤压为一个点，变成圆锥模型，这时就符合颜色模型定义了。故HSI色彩空间可以用一个圆锥空间模型来描述，如下图所示：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/image-20221125171020679.4ipcep40y3u0.webp" alt="image-20221125171020679"></p><p>色彩空间的圆锥模型相把色调、亮度和色饱和度的变化情形表现得很清楚，因此HSI色彩空间可以大大简化图像分析和处理的工作量。</p><h4 id="与RGB模型的关系"><a href="#与RGB模型的关系" class="headerlink" title="与RGB模型的关系"></a>与RGB模型的关系</h4><p>RGB模型到HSI模型的转换关系为(假设RGB值已经归一化到区间$[0,1]$)：</p><ul><li>色调分量H(单位：$\circ$)：</li></ul><script type="math/tex; mode=display">H=\left\{\begin{matrix}\theta, B\leq G \\360-\theta, B>G\end{matrix}\right.</script><p>其中</p><script type="math/tex; mode=display">\theta=arccos({\frac{\frac{1}{2}[(R-G)+(R-B)]}{[(R-G)^2+(R-B)(G-B)]^{\frac{1}{2}}}})</script><ul><li>饱和度分量S：</li></ul><script type="math/tex; mode=display">S=1-\frac{3}{R+G+B}[min(R,G,B)]</script><ul><li>亮度分量I:</li></ul><script type="math/tex; mode=display">I=\frac{1}{3}(R+G+B)</script><p>HSI模型到RGB模型的转换关系为(假设HSI已归一化后H乘以$360^{\circ}$)：</p><ul><li>RG扇区$(0^\circ \leq H &lt;120^\circ)$</li></ul><script type="math/tex; mode=display">\left\{\begin{matrix}B=I(1-S)  \\ R=I[1+\frac{ScosH}{cos(60^\circ-H)}]\\ G=3I-(R+B)\end{matrix}\right.</script><ul><li>GB扇区$(120^\circ \leq H &lt;240^\circ)$</li></ul><p>在这个扇区时，令</p><script type="math/tex; mode=display">H=H-120^\circ</script><p>得到：</p><script type="math/tex; mode=display">\left\{\begin{matrix}R=I(1-S)\\ G=I[1+\frac{ScosH}{cos(60^\circ-H)}]\\ B=3I-(R+G)\end{matrix}\right.</script><ul><li>BR扇区$(240^\circ \leq H &lt;360^\circ)$</li></ul><p>在这个扇区时，令</p><script type="math/tex; mode=display">H=H-240^\circ</script><p>得到：</p><script type="math/tex; mode=display">\left\{\begin{matrix}G=I(1-S) \\ B=I[1+\frac{ScosH}{cos(60^\circ-H)}]\\ R=3I-(R+B)\end{matrix}\right.</script><p>这一转换关系也可以从RGB彩色立方体中获得，如图所示。</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/image-20221126095742252.6e7fpfwls400.webp" alt="image-20221126095742252"></p><p>将立方体旋转到如图所示位姿，黑色作为基点，白色作为顶点，两点连线构成了亮度轴，亮度沿亮度轴分布在[0,1]内。要获取任一点的亮度分量，只需要取包含该彩色点并与亮度轴垂直的平面，该平面与亮度轴的交点即为亮度分量；饱和度对应于该彩色点到亮度轴的距离；对于已知彩色点将其和黑色点、白色点连接构成颜色三角形，则由于三角形内部的点都由三个顶点对应颜色产生，而黑色和白色不改变色调，所以同一个三角形平面内的点色调均相同，因此色调对应于这一平面绕亮度轴旋转的角度。</p><h3 id="YUV-YCbCr-模型"><a href="#YUV-YCbCr-模型" class="headerlink" title="YUV(YCbCr)模型"></a>YUV(YCbCr)模型</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>YUV模型也使用三个分量来存储数据，对每个像素而言其存储结构为：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/webp.4kjbcymc2nq0.webp" alt="webp"></p><p>三个分量具体的意义是：</p><ul><li><p>Y：用于表示<strong>明亮度</strong>(Luminance或Luma)，即灰度值，表示了图片的总体轮廓，常见的亮度图如下：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/v2-3943a5e8886f08863cf6ee7697c46fa0_r.242lg5vlefs0.webp" alt="v2-3943a5e8886f08863cf6ee7697c46fa0_r"></p></li><li><p>U、V：用于表示<strong>色度</strong>(Chrominance或Chroma)，描述色彩颜色和颜色饱和度，UV图如下：</p></li></ul><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/v2-6f30f523322f7817d3f17f429e81e49b_720w.1zrpmnmxyrgg.webp" alt="v2-6f30f523322f7817d3f17f429e81e49b_720w"></p><p>下面举一个例子，图中上方第一张图片为YUV图片的原图，下面的图片分别为只有Y分量、只有U分量、只有V分量数据的图片。可以看到只有Y分量的图片能够看清楚图片的轮廓，但图片是黑白的。</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/800px-Barns_grand_tetons_YCbCr_separation.2lm8q51dhfc0.webp" alt="800px-Barns_grand_tetons_YCbCr_separation"></p><p>(这里其实是对U,V分量的灰度图进行了伪上色过程，具体参考的就是上面的UV图或者下面的crcb图，如我们现在要画U分量的图，就固定V分量的值然后画一条平行于U轴的直线，按这个直线的色彩分布进行伪上色)</p><p>此外还需指出，与YUV模型意义相近的一个常用模型叫做YCbCr。 YCbCr是YUV模型的具体实现，YCbCr是在世界数字组织视频标准研制过程中作为<code>ITU - R BT1601</code>建议的一部分，它其实是YUV经过缩放和偏移的翻版。其中Y与YUV中的Y含义一致，为亮度分量；Cb，Cr同样都指色彩，Cb指蓝色色度分量，而Cr指红色色度分量，其色度图如下：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/1280px-YCbCr-CbCr_Scaled_Y50.1t6piyaey5xc.webp" alt="1280px-YCbCr-CbCr_Scaled_Y50"></p><p>YUV模型的主要优点包括：</p><ol><li>便于压缩编码；</li><li>数据量相较于其他颜色模型更小；</li><li>能够兼容老式黑白电视。</li></ol><p>其中第三个优点已经可以看出，因为Y分量单独显示是其实就是黑白图像，因此YUV要想兼容黑白电视只需要去除UV相关的数据就可以了。其他优点将在后面的介绍中体现。</p><h4 id="与RGB模型的关系-1"><a href="#与RGB模型的关系-1" class="headerlink" title="与RGB模型的关系"></a>与RGB模型的关系</h4><p>YUV与RGB之间的转换需要按照相应标准进行，常见的标准有ITU-R BT.601(标清)、ITU-R BT.709(高清)、ITU-R BT.2020(超高清)，除标准之外还要区分不同的颜色范围，下面仅示例一种标准下的转换公式。</p><p>RGB到YUV的转换，就是将图像所有像素点的R、G、B分量转换到Y、U、V分量的过程：</p><script type="math/tex; mode=display">\left\{\begin{matrix}Y = 0.299 R + 0.587 G + 0.114 B\\U = -0.1687 R - 0.3313 G + 0.5 B + 128\\ V = 0.5 R - 0.4187 G - 0.0813 B + 128\end{matrix}\right.</script><p>YUV到RGB的转换类似：</p><script type="math/tex; mode=display">\left\{\begin{matrix}R = Y + 1.402 (V-128)\\ G= Y - 0.34414 (U-128) - 0.71414 (V-128)\\  B= Y + 1.772 (U-128)\end{matrix}\right.</script><p>这种转换的实际应用价值是：将图像显示器中以RGB模型来显示的图像转换到YUV模型，便于传输图像数据，还能够节省带宽。</p><h4 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h4><p>一般的视频采集芯片输出的码流是YUV数据流的形式，视频处理也通常是在原始YUV码流上进行编码和解析，因此了解YUV模型的采样和存储结构对图像行业从业者有着重要意义。YUV码流的存储格式与其采样的方式密切相关，这里将首先简要介绍YUV主流的采样方式，包括<code>YUV444</code>，<code>YUV422</code>，<code>YUV420</code>，不同类型之间的主要区别是使用了不同的方式进行U、V分量的采样。</p><ul><li>YUV444</li></ul><p>YUV444中每个Y分量分别对应一个U分量和一个V分量。</p><p>下面的图示中，Y用×表示，UV用○表示：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/1240.317omnf0pm60.webp" alt="1240"></p><ul><li>YUV422</li></ul><p>YUV422中每2个Y分量共用一个U分量和一个V分量。</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/1240-166997380331210.6bor18bcxmk0.webp" alt="1240-166997380331210"></p><ul><li>YUV420</li></ul><p>YUV420中每4个Y分量共用一个U分量和一个V分量。</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/auto-orient.4rq6dxw0e040.webp" alt="auto-orient"></p><p>通过计算可以得到，在存储一张$2\times 2$像素的图片时：YUV444需要$12\times8$bit，YUV422需要$8\times 8$bit，而YUV420则只需要$6\times 8$bit。可以看到YUV444存储的数据量与RGB相同，但YUV422和YUV420却只需要存储RGB的数据量的$\frac{2}{3}$和$\frac{1}{2}$,这也是YUV模型的重要优势之一。</p><h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><p>YUV有packed和planar两种存储方式。其中packed格式是先连续存储所有的Y分量，然后依次交叉存储U、V分量；planar格式也会先连续存储所有的Y分量，然后先连续存储U(或V)分量的数据，再连续存储V(或U)分量的数据。</p><p>每种YUV类型都会有多种存储方式，常用的有YUV422和YUV420两种，读者可自行查阅相关存储结构细节，这里不做过多展开。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>《数字图像处理》(第四版).冈萨雷斯著.</p><p><a href="https://zh.wikipedia.org/wiki/三原色光模式">三原色光模式- 维基百科，自由的百科全书</a></p><p><a href="https://en.wikipedia.org/wiki/CMYK_color_model">CMYK color model - Wikipedia</a></p><p><a href="https://zh.wikipedia.org/wiki/颜色">颜色- 维基百科，自由的百科全书</a></p>]]></content>
    
    
    <categories>
      
      <category>ImageProcessing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ImageProcessing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bitonic-Sort解题报告</title>
    <link href="/2022/12/17/Bitonic-Sort%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/"/>
    <url>/2022/12/17/Bitonic-Sort%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="分段双调排序-解题报告"><a href="#分段双调排序-解题报告" class="headerlink" title="分段双调排序-解题报告"></a>分段双调排序-解题报告</h1><h2 id="a-算法描述"><a href="#a-算法描述" class="headerlink" title="a)算法描述"></a>a)算法描述</h2><h3 id="0-定义"><a href="#0-定义" class="headerlink" title="0.定义"></a>0.定义</h3><p>双调排序是一种并行排序算法，它同时也被用于排序网络的构建。</p><h3 id="1-双调序列"><a href="#1-双调序列" class="headerlink" title="1.双调序列"></a>1.双调序列</h3><p>双调序列是一个先单调递增后单调递减（或者先单调递减后单调递增）的序列。</p><p>即序列表示为</p><script type="math/tex; mode=display">x_0 \leq \ldots \leq x_k \geq \ldots \geq x_{n-1}(0 \leq k  \leq n)</script><h3 id="2-Batcher定理"><a href="#2-Batcher定理" class="headerlink" title="2.Batcher定理"></a>2.Batcher定理</h3><p>将任意一个长为<code>2n</code>的双调序列分为等长的两半<code>X</code>和<code>Y</code>，将<code>X</code>中的元素与<code>Y</code>中的元素按原顺序比较，即对于所有的<code>0&lt;=i&lt;n</code>，比较<code>a[i]</code>与<code>a[i+n]</code>，将较大者放入<code>MAX</code>序列，较小者放入<code>MIN</code>序列。</p><p>定理指出，经过这一操作后得到的<code>MAX</code>和<code>MIN</code>序列仍然是双调序列，并且<code>MAX</code>序列中的任意一个元素不小于<code>MIN</code>序列中的任意一个元素。</p><p>这一操作对应代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n;i++) <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">get</span>(i)&gt;<span class="hljs-built_in">get</span>(i+n)) <span class="hljs-built_in">exchange</span>(i,i+n);<br></code></pre></td></tr></table></figure><h3 id="3-双调排序"><a href="#3-双调排序" class="headerlink" title="3.双调排序"></a><strong>3.双调排序</strong></h3><p>假设有一个双调序列，根据Batcher定理，将该序列划分成2个双调序列，然后继续对每个双调序列递归划分，得到更短的双调序列，直到得到的子序列长度为1为止，于是得到了一个按单调递增顺序排列的输出序列。</p><p>具体方法是，把一个序列<code>(1…n)</code>对半分，假设<code>n=2^k</code>，然后<code>1</code>和<code>n/2+1</code>比较，小的放上，接下来<code>2</code>和<code>n/2+2</code>比较，小的放上，以此类推；然后看成两个<code>(n/2)</code>长度的序列，因为他们都是双调序列，所以可以重复上面的过程；总共重复<code>k</code>轮，即最后一轮已经是长度是<code>2</code>的序列比较了，就可得到最终的排序结果。</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/5.6tnra9kutek0.webp" alt="5"></p><p>（图片来源：<a href="https://blog.csdn.net/xbinworld/article/details/76408595">三十分钟理解：双调排序Bitonic Sort，适合并行计算的排序算法</a>）</p><p>上图为这组元素进行升序双调排序的示意图。可以看到第一轮比较中，只有<code>20</code>和<code>0</code>发生了交换；第二轮比较中，<code>9</code>和<code>0</code>、<code>95</code>和<code>35</code>、<code>90</code>和<code>23</code>、<code>60</code>和<code>18</code>、<code>40</code>和<code>20</code>发生了交换，由于序列长度为<code>16</code>，递归到第四轮时得到了正确的升序结果。</p><h3 id="4-任意序列生成双调序列"><a href="#4-任意序列生成双调序列" class="headerlink" title="4.任意序列生成双调序列"></a><strong>4.任意序列生成双调序列</strong></h3><p>前面所述为双调序列的排序方法，现在讨论如何将任意序列变成一个双调序列。</p><p>这个过程和前面排序的思路相反，基本想法是：如果已经有两个相邻、长度为<code>n</code>的、单调性相反的序列， 就可以连接得到一个长度为<code>2n</code>的双调序列，然后对这个<code>2n</code>的序列进行一次双调排序变成有序。</p><p>以16个元素的array为例，具体步骤如下：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/6.1he17ttedfnk.webp" alt="6"></p><p>（图片来源：<a href="https://blog.csdn.net/xbinworld/article/details/76408595">三十分钟理解：双调排序Bitonic Sort，适合并行计算的排序算法</a>）</p><ol><li>相邻两个元素合并形成8个单调性相反的单调序列</li><li>两两序列合并，形成4个双调序列，分别按相反单调性排序</li><li>4个长度为4的相反单调性单调序列，相邻两个合并，生成两个长度为8的双调序列，分别按相反单调性排序</li><li>2个长度为8的相反单调性单调序列，相邻两个合并，生成1个长度为16的双调序列，排序</li></ol><h3 id="5-非2的幂次长度序列双调排序"><a href="#5-非2的幂次长度序列双调排序" class="headerlink" title="5.非2的幂次长度序列双调排序"></a><strong>5.非2的幂次长度序列双调排序</strong></h3><p>以上讨论的双调排序算法只适合于<code>n</code>为<code>2</code>的幂次的情况。为了适合于任意长度的数组，可以用一个定义的最大或者最小者来填充数组，让数组的大小填充到<code>2</code>的幂长度，再进行排序，最后过滤掉那些最大（最小）值即可。</p><p>本次解题中使用的就是这种方式，但是在数组长度较大的时候可能会造成比较大的空间浪费，可以在以后的学习工作中学习更好的解决方案。</p><h2 id="b-尝试过和完成了的加分挑战"><a href="#b-尝试过和完成了的加分挑战" class="headerlink" title="b)尝试过和完成了的加分挑战"></a>b)尝试过和完成了的加分挑战</h2><p>所有的加分挑战都已完成，下面分别叙述：</p><h3 id="1-不递归"><a href="#1-不递归" class="headerlink" title="1.不递归"></a>1.不递归</h3><p><code>segmentedBitonicSort</code>函数及其所调用的任何其他函数在程序中都没有进行形式的递归。</p><h3 id="2-不调用函数"><a href="#2-不调用函数" class="headerlink" title="2.不调用函数"></a>2.不调用函数</h3><p><code>segmentedBitonicSort</code>函数内未调用除标准库以外的其他任何函数。</p><h3 id="3-内存高效"><a href="#3-内存高效" class="headerlink" title="3.内存高效"></a>3.内存高效</h3><p><code>segmentedBitonicSort</code>及其所调用的任何其他函数都没有进行任何形式的动态内存分配。</p><h3 id="4-可并行"><a href="#4-可并行" class="headerlink" title="4.可并行"></a>4.可并行</h3><p><code>segmentedBitonicSort</code>涉及到的所有时间复杂度O(n)以上的代码都写在for循环中，而且每个这样的for循环内部的循环顺序可以任意改变，不影响程序结果。</p><h3 id="5-不需内存"><a href="#5-不需内存" class="headerlink" title="5.不需内存"></a>5.不需内存</h3><p><code>segmentedBitonicSort</code>不调用任何函数（包括C/C++标准库函数，不使用全局变量，所有局部变量都是<code>int</code>、<code>float</code>或指针类型，C++程序不使用new关键字。</p><h3 id="6-绝对鲁棒"><a href="#6-绝对鲁棒" class="headerlink" title="6.绝对鲁棒"></a>6.绝对鲁棒</h3><p>包含<code>NaN</code>时（例如<code>sqrt(-1.f)</code>），保证除<code>NaN</code>以外的数据正确排序，<code>NaN</code>的个数保持不变。</p><p>本代码中利用<code>var != var</code>判定是否是<code>NAN</code>，若是<code>NAN</code>则在比较的时候当作极小值。</p><h2 id="c-可以独立运行的源代码"><a href="#c-可以独立运行的源代码" class="headerlink" title="c)可以独立运行的源代码"></a>c)可以独立运行的源代码</h2><p><strong>源文件:</strong><code>BitonicSort.cpp</code></p><p>见附件。</p><h2 id="d-测试数据"><a href="#d-测试数据" class="headerlink" title="d)测试数据"></a>d)测试数据</h2><p>测试数据1：样例输入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> data[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">0.8</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.5</span> &#125;;<br><span class="hljs-type">int</span> seg_id[<span class="hljs-number">5</span>] = &#123; <span class="hljs-number">0</span>,   <span class="hljs-number">0</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span>,   <span class="hljs-number">1</span> &#125;;<br><span class="hljs-type">int</span> seg_start[<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span> &#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> m = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/res1.48o6fht4dd80.webp" alt="res1"></p><p>测试数据2：加入<code>sqrt(-1.f)</code>测试鲁棒性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> data[<span class="hljs-number">12</span>] = &#123; <span class="hljs-number">0.1</span>, <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>), <span class="hljs-number">0.5</span> ,<span class="hljs-number">0.7</span>,<span class="hljs-number">0.9</span>,<span class="hljs-number">0.8</span>,<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>),<span class="hljs-number">0.2</span>,<span class="hljs-number">0.3</span>,<span class="hljs-number">0.6</span>,<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>),<span class="hljs-number">0.0</span> &#125;;<br><span class="hljs-type">int</span> seg_id[<span class="hljs-number">12</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span> &#125;;<br><span class="hljs-type">int</span> seg_start[<span class="hljs-number">4</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">9</span>,<span class="hljs-number">12</span> &#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-number">12</span>;<br><span class="hljs-type">int</span> m = <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/res2.4hfnnum033i0.webp" alt="res2"></p><p>测试数据3：大部分为<code>NAN</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> data[<span class="hljs-number">8</span>] = &#123; <span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>),<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>),<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>),<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>),<span class="hljs-number">0.1</span>,<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>),<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>),<span class="hljs-built_in">sqrt</span>(<span class="hljs-number">-1.f</span>) &#125;;<br><span class="hljs-type">int</span> seg_id[<span class="hljs-number">8</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span> &#125;;<br><span class="hljs-type">int</span> seg_start[<span class="hljs-number">3</span>] = &#123; <span class="hljs-number">0</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span> &#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span> m = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>输出：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/res3.6nlnrg4p8nc0.webp" alt="res3"></p><h2 id="e-性能分析"><a href="#e-性能分析" class="headerlink" title="e)性能分析"></a>e)性能分析</h2><p>具有<code>2^n</code>长度数据的双调排序的时间复杂度为<code>O(n(logn)^2)</code>。</p><p>当数组长度<code>n</code>为任意数字时需要补齐到<code>2</code>的幂次方，这个对于任意<code>n</code>的新排序网络可以嵌入原始的对于<code>2^k</code>的双调排序网络。因此，它仍有 <code>log(n)*(log(n)+1)/2</code> 层，每层最多比较<code>n/2</code>次，结果仍然是一个复杂度为<code>O(nlog(n)^2)</code>的比较器，跟原始的双调排序网络无区别。</p><p>此外由于已经具备了可并行性，引入<code>openmp</code>等并行框架可以提升执行效率，在此由于时间原因未加入。</p><h2 id="f-测试的起始和完成时间以及实际使用的时间"><a href="#f-测试的起始和完成时间以及实际使用的时间" class="headerlink" title="f)测试的起始和完成时间以及实际使用的时间"></a>f)测试的起始和完成时间以及实际使用的时间</h2><p>起始时间：<code>2022-9-9 15:40</code></p><p>完成时间：<code>2022-9-9 23:50</code></p><p>期间除去吃饭、洗澡等事务实际使用的时间约为8小时，花费了约5小时进行算法学习、资料查找、加分挑战实现以及调试等，约3小时进行解题报告文档撰写。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><p><a href="https://blog.csdn.net/xbinworld/article/details/76408595">三十分钟理解：双调排序Bitonic Sort，适合并行计算的排序算法</a></p><p>主要参考了其中内容进行了算法理解和描述。</p></li><li><p><a href="https://en.wikipedia.org/wiki/Bitonic_sorter">Wiki pedia: Bitonic sorter</a></p><p>主要参考了其中的算法描述和并行结构写法。</p></li><li><p><a href="http://www.tools-of-computing.com/tc/CS/Sorts/bitonic_sort.htm">Bitonic Sort</a></p><p>主要参考其中对于算法并行化改进的描述以及并行结构写法。</p></li><li><p><a href="https://blog.huangjunqin.com/2017/08/19/segmentedBitonicSort/">分段双调排序算法 - 黄俊钦</a></p><p>是曾经做过这项测试的同学的解题博客，在基本完成代码编写后参考了其中的文档结构，并补充了合法性检查以及数组边界设置。</p></li><li><p>各类有关并行计算和位运算的资料若干</p></li></ul><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p><a href="https://github.com/thunderbolt215/Bitonic-Sort">https://github.com/thunderbolt215/Bitonic-Sort</a></p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Bitonic Sort</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性回归基本理论</title>
    <link href="/2022/12/17/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA/"/>
    <url>/2022/12/17/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="名词汇总"><a href="#名词汇总" class="headerlink" title="名词汇总"></a>名词汇总</h1><div class="table-container"><table><thead><tr><th>名词</th><th style="text-align:left">说明</th><th>举例（写法）</th></tr></thead><tbody><tr><td>training data set</td><td style="text-align:left"></td><td></td></tr><tr><td>sample(data point, data instance数据样本)</td><td style="text-align:left"></td><td>$\bold{x}^{(i)}=[x_1^{(i)}+x_2^{(i)}]^T$</td></tr><tr><td>label(target)</td><td style="text-align:left">试图预测的目标</td><td>$y^{(i)}$</td></tr><tr><td>features(covariates协变量)</td><td style="text-align:left">预测时依据的自变量</td><td></td></tr><tr><td>batch size</td><td style="text-align:left">小批量样本数</td><td></td></tr><tr><td>learning rate</td><td style="text-align:left"></td><td></td></tr><tr><td>hyperparameter</td><td style="text-align:left">超参数</td><td></td></tr><tr><td>hyperparameter tuning</td><td style="text-align:left">调参</td><td></td></tr><tr><td>validation data set</td><td style="text-align:left">验证数据集</td><td></td></tr><tr><td>likelihood</td><td style="text-align:left">可能性</td></tr></tbody></table></div><h1 id="线性回归基本概念"><a href="#线性回归基本概念" class="headerlink" title="线性回归基本概念"></a>线性回归基本概念</h1><h2 id="基本要素"><a href="#基本要素" class="headerlink" title="基本要素"></a>基本要素</h2><ul><li>x和y之间呈线性关系</li><li>噪声正态分布</li></ul><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>例如$y=w_1x_1+w_2x_2+b$，可称之为<strong>仿射变换(affine transformation)</strong></p><blockquote><p>通过加权和特征进行线性变换，并通过偏置项进行平移</p></blockquote><p>写成向量形式</p><script type="math/tex; mode=display">\hat{y}=\bold{w}^Tx+b</script><p>记X为特征集合，<strong>每行代表一个样本，每列代表一个特征</strong>，线性模型为</p><script type="math/tex; mode=display">\hat{y}=Xw+b</script><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>给定训练数据特征X、已知标签y，求权重向量w和偏置b，当给定<strong>从X同分布中取样的新样本特征</strong>时，使得新样本预测标签的误差尽可能小。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><h3 id="平方误差"><a href="#平方误差" class="headerlink" title="平方误差"></a>平方误差</h3><p>常用平方误差：</p><script type="math/tex; mode=display">l^{(i)}(\bold{w},b)=\frac{1}{2}(\hat{y}^{(i)}-y^{(i)})^2</script><blockquote><p>系数1/2是为了求导之后系数变为1，无特殊含义</p></blockquote><p>一般计算训练集n个样本上的损失均值</p><script type="math/tex; mode=display">L(\bold{w},b)=\frac{1}{n}\sum_{i=1}^nl^{(i)}(\bold{w},b)=\frac{1}{n}\sum_{i=1}^n\frac{1}{2}(\bold{w}^Tx^{(i)}+b-y^{(i)})^2</script><h3 id="与正态分布的联系"><a href="#与正态分布的联系" class="headerlink" title="与正态分布的联系"></a>与正态分布的联系</h3><blockquote><p>正态分布随机变量x具有均值$\mu$和标准差$\sigma$,概率密度函数为</p><script type="math/tex; mode=display">p(x)=\frac{1}{\sqrt{2\pi \sigma^2}}exp(-\frac{1}{2\sigma^2}(x-\mu)^2)</script></blockquote><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/Snipaste_2022-10-13_21-26-37.4fkp9j2zaj60.webp" alt="Snipaste_2022-10-13_21-26-37"></p><p>总结：<strong>最小化目标函数等价于执行最大似然估计</strong></p><h2 id="解析解"><a href="#解析解" class="headerlink" title="解析解"></a>解析解</h2><p>线性回归问题可以表示为</p><script type="math/tex; mode=display">\bold{w}^*,b^*=\operatorname{argmin}_{\bold{w},b}L(\bold{w},b)</script><p>存在解析解【但是还不会算】</p><h2 id="Minibatch-stochastic-gradient-descent-小批量随机梯度下降"><a href="#Minibatch-stochastic-gradient-descent-小批量随机梯度下降" class="headerlink" title="Minibatch stochastic gradient descent(小批量随机梯度下降)"></a>Minibatch stochastic gradient descent(小批量随机梯度下降)</h2><p>梯度下降：计算<strong>损失函数</strong>关于<strong>模型参数</strong>的<strong>导数(梯度)</strong></p><p>每次计算更新时随机抽取一小批样本$\Beta$：<strong><em>Minibatch stochastic gradient descent</em></strong></p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ul><li>初始化模型参数</li><li>随机抽取小批量样本，在负梯度方向更新参数</li><li>不断迭代</li></ul><script type="math/tex; mode=display">\bold{w} \leftarrow \bold{w}-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}\partial_{\bold{w}}l^{(i)}(\bold{w},b)=\bold{w}-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}\bold{x}^{(i)}(\bold{w}^Tx^{(i)}+b-y^{(i)}),\\b \leftarrow b-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}\partial_{b}l^{(i)}(\bold{w},b)=b-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}(\bold{w}^Tx^{(i)}+b-y^{(i)})</script><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ul><li>$|\Beta|$表示每个小批量的<strong>样本数(batch size)</strong></li><li>$\eta$表示<strong>学习率(learning rate)</strong></li></ul><p>这些参数通常预先指定，可以调整，但不在训练过程中更新，称为<strong>超参数(hyperparameter)</strong>，选择超参数的过程称为<strong>调参(hyperparameter tuning)</strong></p><h2 id="矢量化加速"><a href="#矢量化加速" class="headerlink" title="矢量化加速"></a>矢量化加速</h2><p>利用线性代数库矢量化代码，可以实现对运算数量级的速度提升。</p><h2 id="与神经网络的联系"><a href="#与神经网络的联系" class="headerlink" title="与神经网络的联系"></a>与神经网络的联系</h2><p>线性回归模型可视为单个人工神经元组成的网络(<strong>单层神经网络</strong>)</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/Snipaste_2022-10-13_21-31-37.5kgfyh56fcg0.webp" alt="Snipaste_2022-10-13_21-31-37"></p><h2 id="调用API版本"><a href="#调用API版本" class="headerlink" title="调用API版本"></a>调用API版本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">synthesis_data</span>(<span class="hljs-params">w, b, number</span>):<br>    X = torch.rand(number, <span class="hljs-built_in">len</span>(w))<br>    noise = torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, size=(number, <span class="hljs-number">1</span>))<br>    y = torch.matmul(X, w) + noise<br>    y += b<br>    <span class="hljs-keyword">return</span> X, y<br><br><span class="hljs-comment"># dataloader 还不理解</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_array</span>(<span class="hljs-params">data_array, batch_size, is_train=<span class="hljs-literal">True</span></span>):<br>    dataset = data.TensorDataset(*data_array)<br>    <span class="hljs-keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)<br><br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 生成数据集</span><br>    w_true = torch.tensor([<span class="hljs-number">2</span>, -<span class="hljs-number">3.4</span>]).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>    b_true = <span class="hljs-number">4.2</span><br>    n = <span class="hljs-number">1000</span><br>    features, labels = synthesis_data(w_true, b_true, n)<br><br>    batch_size = <span class="hljs-number">10</span><br>    data_iter = load_array((features, labels), batch_size)<br>    <span class="hljs-comment"># print(next(iter(data_iter)))</span><br><br>    net = nn.Sequential(nn.Linear(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>))<br>    net[<span class="hljs-number">0</span>].weight.data.normal_(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>)<br>    net[<span class="hljs-number">0</span>].bias.data.fill_(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment"># print(net[0])</span><br><br>    loss = nn.MSELoss()<br>    trainer = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.03</span>)<br><br>    num_epochs = <span class="hljs-number">30</span><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, num_epochs+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter:<br>            l = loss(net(X), y)<br>            trainer.zero_grad()<br>            l.backward()<br>            trainer.step()<br>        l = loss(net(features), labels)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;epoch<span class="hljs-subst">&#123;epoch&#125;</span>, loss<span class="hljs-subst">&#123;l:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br><br>    w = net[<span class="hljs-number">0</span>].weight.data<br>    b = net[<span class="hljs-number">0</span>].bias.data<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;error of w= <span class="hljs-subst">&#123;w-w_true&#125;</span>&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;error of b= <span class="hljs-subst">&#123;b-b_true&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>其中还有不少不理解的地方，等待后续补充</p><h3 id="【不理解的地方】"><a href="#【不理解的地方】" class="headerlink" title="【不理解的地方】"></a>【不理解的地方】</h3>]]></content>
    
    
    <categories>
      
      <category>Deeplearning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Deeplearning</tag>
      
      <tag>Linear Regression</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图像取样与量化</title>
    <link href="/2022/12/17/%E5%9B%BE%E5%83%8F%E5%8F%96%E6%A0%B7%E4%B8%8E%E9%87%8F%E5%8C%96/"/>
    <url>/2022/12/17/%E5%9B%BE%E5%83%8F%E5%8F%96%E6%A0%B7%E4%B8%8E%E9%87%8F%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="图像取样与量化"><a href="#图像取样与量化" class="headerlink" title="图像取样与量化"></a>图像取样与量化</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h2><p><a href="https://www.jianshu.com/p/5a80a5681bb9">https://www.jianshu.com/p/5a80a5681bb9</a></p><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a><strong>要点</strong></h2><p>先转换为灰度图再进行取样和量化。</p><p>取样实际上是对原图像矩阵等间隔取样，量化采用<code>histeq()</code>进行，其中的参数代表量化分级数。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs matlab">ori = imread(<span class="hljs-string">&quot;e:\\coding\test.png&quot;</span>);<br>gray = rgb2gray(ori);<br>prop1 = <span class="hljs-number">8</span>;<br>sampling = gray(<span class="hljs-number">1</span>:prop1:<span class="hljs-keyword">end</span>, <span class="hljs-number">1</span>:prop1:<span class="hljs-keyword">end</span>);<br>prop2 = <span class="hljs-number">8</span>;<br>quantifying = histeq(gray, prop2);<br><br>subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>), imshow(gray), title(<span class="hljs-string">&#x27;origin&#x27;</span>)<br>subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>), imshow(sampling), title(<span class="hljs-string">&#x27;sampling&#x27;</span>)<br>subplot(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>), imshow(quantifying), title(<span class="hljs-string">&#x27;quantifying&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/untitled.xlud9neywdc.webp" alt="untitled"></p>]]></content>
    
    
    <categories>
      
      <category>ImageProcessing</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Image Processing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Re:从0开始的手写线性回归</title>
    <link href="/2022/12/17/Re-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%89%8B%E5%86%99%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    <url>/2022/12/17/Re-%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%9A%84%E6%89%8B%E5%86%99%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="Re-从0开始的手写线性回归"><a href="#Re-从0开始的手写线性回归" class="headerlink" title="Re:从0开始的手写线性回归"></a>Re:从0开始的手写线性回归</h1><p>只使用<strong>tensor</strong>和<strong>autograd</strong>完成简单的线性回归全过程。</p><h2 id="一些小细节"><a href="#一些小细节" class="headerlink" title="一些小细节"></a>一些小细节</h2><ul><li>pycharm要求函数之间空两行</li><li>函数内部变量尽量不要与外部重名，参考：</li></ul><p><a href="https://www.cnblogs.com/shengulong/p/10171386.html">https://www.cnblogs.com/shengulong/p/10171386.html</a></p><p><a href="https://www.twle.cn/t/649">https://www.twle.cn/t/649</a></p><p>【目前还不完全理解，以及不确定是否需要解决】</p><h2 id="代码注解"><a href="#代码注解" class="headerlink" title="代码注解"></a>代码注解</h2><h3 id="生成数据集"><a href="#生成数据集" class="headerlink" title="生成数据集"></a>生成数据集</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">synthesis_data</span>(<span class="hljs-params">w, b, number</span>):<br>    X = torch.rand(number, <span class="hljs-built_in">len</span>(w))<br>    noise = torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, size=(number, <span class="hljs-number">1</span>))<br>    y = torch.matmul(X, w) + noise<br>    y += b<br>    <span class="hljs-keyword">return</span> X, y<br></code></pre></td></tr></table></figure><ul><li><h4 id="y-b一句需要单独成行，否则会出错"><a href="#y-b一句需要单独成行，否则会出错" class="headerlink" title="y+=b一句需要单独成行，否则会出错"></a><code>y+=b</code>一句需要单独成行，否则会出错</h4></li><li><p>采用<code>reshape(x, y)</code>可以改变tensor的大小，如果参数选择-1则可以仅输入行或者列，自动计算另一个参数。书中使用的<code>reshape(-1, 1)</code>可以确定列数为1，自动计算行数。</p></li></ul><p>生成后画出特征的两个维度和标签的三维散点图：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/Figure_1.jdj9vymy5t4.webp" alt="Figure_1"></p><h3 id="随机读取小批量数据"><a href="#随机读取小批量数据" class="headerlink" title="随机读取小批量数据"></a>随机读取小批量数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># iter:迭代器</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_iter</span>(<span class="hljs-params">batch_size, features, labels</span>):<br>    total_number = <span class="hljs-built_in">len</span>(labels)<br>    indices = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(total_number))<br>    random.shuffle(indices)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, total_number-batch_size, batch_size):<br>        batch_indices = indices[i:i+batch_size-<span class="hljs-number">1</span>]<br>        <span class="hljs-keyword">yield</span> features[batch_indices, :], labels[batch_indices]<br></code></pre></td></tr></table></figure><ul><li>学习这种随机取出小批量数据的方法！</li><li>合理大小的小批量可以利⽤GPU硬件的优势，每个样本都可以并行地进行模型计算、损失函数计算、梯度计算。结果是GPU可以在处理几百个样本时，所花费的时间不比处理⼀个样本时多太多。</li><li>实际上深度学习内置的iter效率高得多</li></ul><h3 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h3><p>在这里模型参数指权重w和偏置b。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">initialize_parameter</span>(<span class="hljs-params">mu, sigma</span>):<br>    w = torch.normal(mu, sigma, size=(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>), requires_grad=<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># w = torch.zeros(size=(2, 1), requires_grad=True)</span><br>    b = torch.zeros(<span class="hljs-number">1</span>, requires_grad=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> w, b<br></code></pre></td></tr></table></figure><ul><li>参数w使用了正态分布进行初始化，其实也可以直接以0作为初始值【那为什么要指定初始值啊】</li><li>注意不要漏掉<code>requires_grad=True</code></li></ul><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linear_regression</span>(<span class="hljs-params">w, b, X</span>):<br>    <span class="hljs-keyword">return</span> torch.matmul(X, w) + b<br></code></pre></td></tr></table></figure><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">squared_loss</span>(<span class="hljs-params">labels, targets</span>):<br>    <span class="hljs-comment"># return 0.5 * (labels - targets) ** 2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span> * (labels - targets.reshape(labels.shape)) ** <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><ul><li>这里使用了<code>reshape()</code>，是一种安全且规范的写法，保证了两个向量确实是按我们期望的方式都作为列项链进行相减。<strong>值得认可！</strong></li></ul><h3 id="优化算法-小批量随机梯度下降"><a href="#优化算法-小批量随机梯度下降" class="headerlink" title="优化算法(小批量随机梯度下降)"></a>优化算法(小批量随机梯度下降)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sgd</span>(<span class="hljs-params">params, learning_rate, batch_size</span>):<br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:<br>            param -= learning_rate * param.grad / batch_size<br>            param.grad.zero_()<br></code></pre></td></tr></table></figure><p>【关于自动求导的部分待填坑】</p><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><h4 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 初始化模型参数</span><br>w, b = initialize_parameter(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>)<br>learning_rate = <span class="hljs-number">0.03</span><br>batch_size = <span class="hljs-number">10</span><br>net = linear_regression<br>num_epochs = <span class="hljs-number">30</span><br>loss = squared_loss<br></code></pre></td></tr></table></figure><ul><li><p>注意这两句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">net = linear_regression<br>loss = squared_loss<br></code></pre></td></tr></table></figure><p>是一种规范的写法，<strong>值得认可！</strong></p></li></ul><h4 id="训练过程-1"><a href="#训练过程-1" class="headerlink" title="训练过程"></a>训练过程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    <span class="hljs-keyword">for</span> features_sample, labels_sample <span class="hljs-keyword">in</span> data_iter(batch_size, features, labels):<br>        loss_list = loss(net(w, b, features_sample), labels_sample)<br>        loss_list.<span class="hljs-built_in">sum</span>().backward()<br>        sgd([w, b], learning_rate, batch_size)<br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        train_loss = loss(net(w, b, features), labels)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;epoch <span class="hljs-subst">&#123;epoch + <span class="hljs-number">1</span>&#125;</span>, loss <span class="hljs-subst">&#123;<span class="hljs-built_in">float</span>(train_loss.mean()):f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p>整个算法步骤按上一节所述如下：</p><ul><li>初始化模型参数</li><li>随机抽取小批量样本，在负梯度方向更新参数</li><li>不断迭代</li></ul><script type="math/tex; mode=display">\bold{w} \leftarrow \bold{w}-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}\partial_{\bold{w}}l^{(i)}(\bold{w},b)=\bold{w}-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}\bold{x}^{(i)}(\bold{w}^Tx^{(i)}+b-y^{(i)}),\\b \leftarrow b-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}\partial_{b}l^{(i)}(\bold{w},b)=b-\frac{\eta}{|\Beta|}\sum_{i\in\Beta}(\bold{w}^Tx^{(i)}+b-y^{(i)})</script><p>【关于自动求导的部分待填坑】</p><h3 id="训练效果"><a href="#训练效果" class="headerlink" title="训练效果"></a>训练效果</h3><p>这里如果<code>num_epochs</code>设为3，我的代码效果不好，因此增大到30了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python">epoch <span class="hljs-number">1</span>, loss <span class="hljs-number">0.602139</span><br>epoch <span class="hljs-number">2</span>, loss <span class="hljs-number">0.400999</span><br>epoch <span class="hljs-number">3</span>, loss <span class="hljs-number">0.274957</span><br>epoch <span class="hljs-number">4</span>, loss <span class="hljs-number">0.188473</span><br>epoch <span class="hljs-number">5</span>, loss <span class="hljs-number">0.130619</span><br>epoch <span class="hljs-number">6</span>, loss <span class="hljs-number">0.091479</span><br>epoch <span class="hljs-number">7</span>, loss <span class="hljs-number">0.064301</span><br>epoch <span class="hljs-number">8</span>, loss <span class="hljs-number">0.045488</span><br>epoch <span class="hljs-number">9</span>, loss <span class="hljs-number">0.032430</span><br>epoch <span class="hljs-number">10</span>, loss <span class="hljs-number">0.023281</span><br>epoch <span class="hljs-number">11</span>, loss <span class="hljs-number">0.016996</span><br>epoch <span class="hljs-number">12</span>, loss <span class="hljs-number">0.012337</span><br>epoch <span class="hljs-number">13</span>, loss <span class="hljs-number">0.009028</span><br>epoch <span class="hljs-number">14</span>, loss <span class="hljs-number">0.006587</span><br>epoch <span class="hljs-number">15</span>, loss <span class="hljs-number">0.004879</span><br>epoch <span class="hljs-number">16</span>, loss <span class="hljs-number">0.003635</span><br>epoch <span class="hljs-number">17</span>, loss <span class="hljs-number">0.002709</span><br>epoch <span class="hljs-number">18</span>, loss <span class="hljs-number">0.002028</span><br>epoch <span class="hljs-number">19</span>, loss <span class="hljs-number">0.001535</span><br>epoch <span class="hljs-number">20</span>, loss <span class="hljs-number">0.001165</span><br>epoch <span class="hljs-number">21</span>, loss <span class="hljs-number">0.000886</span><br>epoch <span class="hljs-number">22</span>, loss <span class="hljs-number">0.000677</span><br>epoch <span class="hljs-number">23</span>, loss <span class="hljs-number">0.000522</span><br>epoch <span class="hljs-number">24</span>, loss <span class="hljs-number">0.000404</span><br>epoch <span class="hljs-number">25</span>, loss <span class="hljs-number">0.000316</span><br>epoch <span class="hljs-number">26</span>, loss <span class="hljs-number">0.000250</span><br>epoch <span class="hljs-number">27</span>, loss <span class="hljs-number">0.000202</span><br>epoch <span class="hljs-number">28</span>, loss <span class="hljs-number">0.000164</span><br>epoch <span class="hljs-number">29</span>, loss <span class="hljs-number">0.000136</span><br>epoch <span class="hljs-number">30</span>, loss <span class="hljs-number">0.000114</span><br>loss of w: tensor([[-<span class="hljs-number">0.0262</span>], [-<span class="hljs-number">0.0319</span>]], grad_fn=&lt;SubBackward0&gt;)<br>loss of b: tensor([<span class="hljs-number">0.0309</span>], grad_fn=&lt;RsubBackward1&gt;)<br></code></pre></td></tr></table></figure><p>训练效果：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/训练效果.26wsulhzy5j4.webp" alt="训练效果"></p><h2 id="调API的线性回归"><a href="#调API的线性回归" class="headerlink" title="调API的线性回归"></a>调API的线性回归</h2><p>思想与上面完全一致，但是代码精简很多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">synthesis_data</span>(<span class="hljs-params">w, b, number</span>):<br>    X = torch.rand(number, <span class="hljs-built_in">len</span>(w))<br>    noise = torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, size=(number, <span class="hljs-number">1</span>))<br>    y = torch.matmul(X, w) + noise<br>    y += b<br>    <span class="hljs-keyword">return</span> X, y<br><br><span class="hljs-comment"># dataloader 还不理解</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_array</span>(<span class="hljs-params">data_array, batch_size, is_train=<span class="hljs-literal">True</span></span>):<br>    dataset = data.TensorDataset(*data_array)<br>    <span class="hljs-keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)<br><br><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 生成数据集</span><br>    w_true = torch.tensor([<span class="hljs-number">2</span>, -<span class="hljs-number">3.4</span>]).reshape(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>    b_true = <span class="hljs-number">4.2</span><br>    n = <span class="hljs-number">1000</span><br>    features, labels = synthesis_data(w_true, b_true, n)<br><br>    batch_size = <span class="hljs-number">10</span><br>    data_iter = load_array((features, labels), batch_size)<br>    <span class="hljs-comment"># print(next(iter(data_iter)))</span><br><br>    net = nn.Sequential(nn.Linear(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>))<br>    net[<span class="hljs-number">0</span>].weight.data.normal_(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>)<br>    net[<span class="hljs-number">0</span>].bias.data.fill_(<span class="hljs-number">0</span>)<br>    <span class="hljs-comment"># print(net[0])</span><br><br>    loss = nn.MSELoss()<br>    trainer = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.03</span>)<br><br>    num_epochs = <span class="hljs-number">30</span><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, num_epochs+<span class="hljs-number">1</span>):<br>        <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter:<br>            l = loss(net(X), y)<br>            trainer.zero_grad()<br>            l.backward()<br>            trainer.step()<br>        l = loss(net(features), labels)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;epoch<span class="hljs-subst">&#123;epoch&#125;</span>, loss<span class="hljs-subst">&#123;l:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br><br>    w = net[<span class="hljs-number">0</span>].weight.data<br>    b = net[<span class="hljs-number">0</span>].bias.data<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;error of w= <span class="hljs-subst">&#123;w-w_true&#125;</span>&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;error of b= <span class="hljs-subst">&#123;b-b_true&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>仍然有一样的问题，书中训练3个epoch效果就很好，我需要训练到10个左右才能达到相同效果</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Deeplearning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Deeplearning</tag>
      
      <tag>Linear Regression</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python补充</title>
    <link href="/2022/12/17/Python%E8%A1%A5%E5%85%85/"/>
    <url>/2022/12/17/Python%E8%A1%A5%E5%85%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Python-补充"><a href="#Python-补充" class="headerlink" title="Python 补充"></a>Python 补充</h1><h1 id="【有问题的章节】"><a href="#【有问题的章节】" class="headerlink" title="【有问题的章节】"></a>【有问题的章节】</h1><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017075323632896">字符串和编码</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888">函数参数</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017434209254976">返回函数</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017451662295584">装饰</a></p><h2 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h2><p><strong>parameter:</strong>形参，指的是函数中的参数名称：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">def add(x,y):&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;此处x,y为形参。<br>    return x+y<br></code></pre></td></tr></table></figure><p><strong>argument:</strong>实参，指的是你提供给函数调用的值：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">x=1<br>y=2<br>add(x,y)&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;此处x,y就变为实参了。<br></code></pre></td></tr></table></figure><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><p>约定缩进为<strong>4个空格</strong></p><p>重构代码时，必须<strong>重新检查缩进是否正确</strong></p><h3 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h3><p>python大小写敏感</p><h3 id="数据表示"><a href="#数据表示" class="headerlink" title="数据表示"></a>数据表示</h3><h4 id="进制表示"><a href="#进制表示" class="headerlink" title="进制表示"></a>进制表示</h4><div class="table-container"><table><thead><tr><th>进制</th><th>前缀</th></tr></thead><tbody><tr><td>2</td><td>0b</td></tr><tr><td>8</td><td>0o</td></tr><tr><td>16</td><td>0x</td></tr></tbody></table></div><p>示例：<code>0xff00</code>，<code>0xa5b4c3d2</code></p><p>数字中间可以用<code>_</code>分隔</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">10_000_000_000</span> = <span class="hljs-number">10000000000</span><br><span class="hljs-number">0xa1b2_c3d4</span> = <span class="hljs-number">0xa1b2c3d4</span><br></code></pre></td></tr></table></figure><p>浮点数（也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x10^9和12.3x10^8是完全相等的）</p><p>1.23x10^9表示为<code>1.23e9</code></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串是以<strong>单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本</strong></p><p>如果字符串内部既包含<code>&#39;</code>又包含<code>&quot;</code>怎么办？可以用转义字符<code>\</code>来标识，比如：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-symbol">&#x27;I</span>\<span class="hljs-symbol">&#x27;m</span> \<span class="hljs-string">&quot;OK\&quot;</span>!&#x27;<br></code></pre></td></tr></table></figure><p>表示的字符串内容是：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">I<span class="hljs-symbol">&#x27;m</span> <span class="hljs-string">&quot;OK&quot;</span>!<br></code></pre></td></tr></table></figure><p>转义字符<code>\</code>可以转义很多字符，比如<code>\n</code>表示换行，<code>\t</code>表示制表符，字符<code>\</code>本身也要转义，所以<code>\\</code>表示的字符就是<code>\</code>，可以在Python的交互式命令行用<code>print()</code>打印字符串看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;I\&#x27;m ok.&#x27;</span>)<br>I<span class="hljs-string">&#x27;m ok.</span><br><span class="hljs-string">&gt;&gt;&gt; print(&#x27;</span>I\<span class="hljs-string">&#x27;m learning\nPython.&#x27;</span>)<br>I<span class="hljs-string">&#x27;m learning</span><br><span class="hljs-string">Python.</span><br><span class="hljs-string">&gt;&gt;&gt; print(&#x27;</span>\\\n\\<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">\</span><br><span class="hljs-string">\</span><br></code></pre></td></tr></table></figure><p>如果字符串里面有很多字符都需要转义，就需要加很多<code>\</code>，为了简化，Python还允许用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义，可以自己试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\\\t\\&#x27;</span>)<br>\       \<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">r&#x27;\\\t\\&#x27;</span>)<br>\\\t\\<br></code></pre></td></tr></table></figure><p>如果字符串内部有很多换行，用<code>\n</code>写在一行里不好阅读，为了简化，Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容，可以自己试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;&#x27;line1</span><br><span class="hljs-string"><span class="hljs-meta">... </span>line2</span><br><span class="hljs-string"><span class="hljs-meta">... </span>line3&#x27;&#x27;&#x27;</span>)<br>line1<br>line2<br>line3<br></code></pre></td></tr></table></figure><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>空值是Python里一个特殊的值，用<code>None</code>表示。<code>None</code>不能理解为<code>0</code>，因为<code>0</code>是有意义的，而<code>None</code>是一个特殊的空值。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>在Python中，通常用全部大写的变量名表示常量：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14159265359</span><br></code></pre></td></tr></table></figure><p>但事实上<code>PI</code>仍然是一个变量，Python根本没有任何机制保证<code>PI</code>不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量<code>PI</code>的值，也没人能拦住你。</p><h3 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h3><p>Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在<code>-2147483648</code>-<code>2147483647</code>。</p><p>Python的浮点数也没有大小限制，但是超出一定范围就直接表示为<code>inf</code>（无限大）。</p><h3 id="元组-tuple"><a href="#元组-tuple" class="headerlink" title="元组(tuple)"></a>元组(tuple)</h3><p>如果要定义一个空的tuple，可以写成<code>()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>t = ()<br><span class="hljs-meta">&gt;&gt;&gt; </span>t<br>()<br></code></pre></td></tr></table></figure><p><strong>只有1个元素的tuple定义时必须加一个逗号<code>,</code>，来消除歧义：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>t = (<span class="hljs-number">1</span>,)<br><span class="hljs-meta">&gt;&gt;&gt; </span>t<br>(<span class="hljs-number">1</span>,)<br></code></pre></td></tr></table></figure><p>Python在显示只有1个元素的tuple时，也会加一个逗号<code>,</code>，以免你误解成数学计算意义上的括号。</p><p>tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向<code>&#39;a&#39;</code>，就不能改成指向<code>&#39;b&#39;</code>，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！</p><h3 id="不可变对象"><a href="#不可变对象" class="headerlink" title="不可变对象"></a>不可变对象</h3><p><strong>对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。</strong></p><h3 id="字典-dict"><a href="#字典-dict" class="headerlink" title="字典(dict)"></a>字典(dict)</h3><p>dict的key必须是<strong>不可变对象</strong>.</p><p>在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key</p><h3 id="集合-set"><a href="#集合-set" class="headerlink" title="集合(set)"></a>集合(set)</h3><p>要创建一个set，需要提供一个list作为输入集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>s<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure><p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>s1 = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>s2 = <span class="hljs-built_in">set</span>([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span>s1 &amp; s2<br>&#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>s1 | s2<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure><p>set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象.</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><blockquote><p>在交互式命令行通过<code>help()</code>查看函数的帮助信息。</p></blockquote><p><strong>函数名其实就是指向一个函数对象的引用</strong>，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-built_in">abs</span> <span class="hljs-comment"># 变量a指向abs函数</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a(-<span class="hljs-number">1</span>) <span class="hljs-comment"># 所以也可以通过a调用abs函数</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><h5 id="返回单值"><a href="#返回单值" class="headerlink" title="返回单值"></a>返回单值</h5><p>如果没有<code>return</code>语句，函数执行完毕返回<code>None</code></p><p>此外<code>return None</code>可以简写为<code>return</code></p><h5 id="返回多值"><a href="#返回多值" class="headerlink" title="返回多值"></a>返回多值</h5><p><strong>Python的函数返回多值其实就是返回一个tuple</strong></p><h4 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h4><p><code>pass</code>语句用来作为占位符.</p><p>如果想定义一个什么事也不做的空函数，可以用<code>pass</code>语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">nop</span>():<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>用于其他语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> age &gt;= <span class="hljs-number">18</span>:<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>缺少了<code>pass</code>，代码运行就会有语法错误。</p><h4 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h4><h5 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">power</span>(<span class="hljs-params">x, n</span>):<br>    s = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>        n = n - <span class="hljs-number">1</span><br>        s = s * x<br>    <span class="hljs-keyword">return</span> s<br></code></pre></td></tr></table></figure><p><code>power(x, n)</code>函数有两个参数：<code>x</code>和<code>n</code>，这两个参数都是<strong>位置参数</strong>（调用函数时，传入的两个值按照位置顺序依次赋给参数<code>x</code>和<code>n</code>）</p><h5 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">power</span>(<span class="hljs-params">x, n=<span class="hljs-number">2</span></span>):<br>    s = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:<br>        n = n - <span class="hljs-number">1</span><br>        s = s * x<br>    <span class="hljs-keyword">return</span> s<br></code></pre></td></tr></table></figure><p><strong>必选参数在前，默认参数在后</strong>，<strong>默认参数必须指向不变对象！</strong></p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">enroll</span>(<span class="hljs-params">name, gender, age=<span class="hljs-number">6</span>, city=<span class="hljs-string">&#x27;Beijing&#x27;</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name:&#x27;</span>, name)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;gender:&#x27;</span>, gender)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;age:&#x27;</span>, age)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;city:&#x27;</span>, city)<br>    <br>调用<span class="hljs-number">1</span>：enroll(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-number">7</span>)<br>调用<span class="hljs-number">2</span>：enroll(<span class="hljs-string">&#x27;Adam&#x27;</span>, <span class="hljs-string">&#x27;M&#x27;</span>, city=<span class="hljs-string">&#x27;Tianjin&#x27;</span>)<br></code></pre></td></tr></table></figure><hr><h6 id="【关于默认参数不变性的理解】"><a href="#【关于默认参数不变性的理解】" class="headerlink" title="【关于默认参数不变性的理解】"></a>【关于默认参数不变性的理解】</h6><p>先定义一个函数，传入一个list，添加一个<code>END</code>再返回：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_end</span><span class="hljs-params">(L=[])</span></span>:<br>    L.append(<span class="hljs-string">&#x27;END&#x27;</span>)<br>    <span class="hljs-keyword">return</span> L<br></code></pre></td></tr></table></figure><p>当你正常调用时，结果似乎不错：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;&gt;&gt; <span class="hljs-built_in">add_end</span>(<span class="hljs-selector-attr">[1, 2, 3]</span>)<br><span class="hljs-selector-attr">[1, 2, 3, <span class="hljs-string">&#x27;END&#x27;</span>]</span><br>&gt;&gt;&gt; <span class="hljs-built_in">add_end</span>(<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>]</span>)<br><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;END&#x27;</span>]</span><br></code></pre></td></tr></table></figure><p>当你使用默认参数调用时，一开始结果也是对的：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">&gt;&gt;&gt; <span class="hljs-built_in">add_end</span>()<br><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;END&#x27;</span>]</span><br></code></pre></td></tr></table></figure><p>但是，再次调用<code>add_end()</code>时，结果就不对了：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">&gt;&gt;&gt; <span class="hljs-built_in">add_end</span>()<br><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;END&#x27;</span>, <span class="hljs-string">&#x27;END&#x27;</span>]</span><br>&gt;&gt;&gt; <span class="hljs-built_in">add_end</span>()<br><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;END&#x27;</span>, <span class="hljs-string">&#x27;END&#x27;</span>, <span class="hljs-string">&#x27;END&#x27;</span>]</span><br></code></pre></td></tr></table></figure><p>很多初学者很疑惑，默认参数是<code>[]</code>，但是函数似乎每次都“记住了”上次添加了<code>&#39;END&#39;</code>后的list。</p><p>原因解释如下：</p><p>Python函数在定义的时候，默认参数<code>L</code>的值就被计算出来了，即<code>[]</code>，因为默认参数<code>L</code>也是一个变量，它指向对象<code>[]</code>，每次调用该函数，如果改变了<code>L</code>的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的<code>[]</code>了。</p><p> 定义默认参数要牢记一点：<strong>默认参数必须指向不变对象</strong>！</p><p>要修改上面的例子，我们可以用<code>None</code>这个不变对象来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_end</span>(<span class="hljs-params">L=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> L <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        L = []<br>    L.append(<span class="hljs-string">&#x27;END&#x27;</span>)<br>    <span class="hljs-keyword">return</span> L<br></code></pre></td></tr></table></figure><p>现在，无论调用多少次，都不会有问题：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">&gt;&gt;&gt; <span class="hljs-built_in">add_end</span>()<br><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;END&#x27;</span>]</span><br>&gt;&gt;&gt; <span class="hljs-built_in">add_end</span>()<br><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;END&#x27;</span>]</span><br></code></pre></td></tr></table></figure><p>为什么要设计<code>str</code>、<code>None</code>这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p><hr><h5 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h5><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calc</span>(<span class="hljs-params">*numbers</span>):<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> numbers:<br>        <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + n * n<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>calc(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-number">5</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>calc()<br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h6 id="list-tuple做可变参数"><a href="#list-tuple做可变参数" class="headerlink" title="list/tuple做可变参数"></a>list/tuple做可变参数</h6><p>在list或tuple前面加一个<code>*</code>号，把list或tuple的元素变成可变参数传进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>calc(*nums)<br><span class="hljs-number">14</span><br></code></pre></td></tr></table></figure><h5 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h5><p>允许传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, **kw</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name:&#x27;</span>, name, <span class="hljs-string">&#x27;age:&#x27;</span>, age, <span class="hljs-string">&#x27;other:&#x27;</span>, kw)<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Bob&#x27;</span>, <span class="hljs-number">35</span>, city=<span class="hljs-string">&#x27;Beijing&#x27;</span>)<br>name: Bob age: <span class="hljs-number">35</span> other: &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Adam&#x27;</span>, <span class="hljs-number">45</span>, gender=<span class="hljs-string">&#x27;M&#x27;</span>, job=<span class="hljs-string">&#x27;Engineer&#x27;</span>)<br>name: Adam age: <span class="hljs-number">45</span> other: &#123;<span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;M&#x27;</span>, <span class="hljs-string">&#x27;job&#x27;</span>: <span class="hljs-string">&#x27;Engineer&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>也可以先组装成dict，再传递参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>extra = &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>, <span class="hljs-string">&#x27;job&#x27;</span>: <span class="hljs-string">&#x27;Engineer&#x27;</span>&#125;<br><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">24</span>, **extra)<br>name: Jack age: <span class="hljs-number">24</span> other: &#123;<span class="hljs-string">&#x27;city&#x27;</span>: <span class="hljs-string">&#x27;Beijing&#x27;</span>, <span class="hljs-string">&#x27;job&#x27;</span>: <span class="hljs-string">&#x27;Engineer&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h5 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h5><p>需要限制关键字名字时使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *, city, job</span>): <br>    <span class="hljs-comment"># 只接受city、job, 特殊分隔符`*`后面的参数被视为命名关键字参数。</span><br>    <span class="hljs-built_in">print</span>(name, age, city, job)<br>    <br><span class="hljs-meta">&gt;&gt;&gt; </span>person(<span class="hljs-string">&#x27;Jack&#x27;</span>, <span class="hljs-number">24</span>, city=<span class="hljs-string">&#x27;Beijing&#x27;</span>, job=<span class="hljs-string">&#x27;Engineer&#x27;</span>)<br>Jack <span class="hljs-number">24</span> Beijing Engineer  <span class="hljs-comment"># 命名关键字参数必须传入参数名</span><br></code></pre></td></tr></table></figure><p>如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符<code>*</code>了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *args, city, job</span>):<br>    <span class="hljs-built_in">print</span>(name, age, args, city, job)<br></code></pre></td></tr></table></figure><h5 id="参数顺序"><a href="#参数顺序" class="headerlink" title="参数顺序"></a>参数顺序</h5><p>参数定义的顺序必须是：<strong>必选参数、默认参数、可变参数、命名关键字参数和关键字参数</strong></p><p>对于任意函数，都可以通过类似<code>func(*args, **kw)</code>的形式调用它，无论它的参数是如何定义的。</p><h5 id="遗留的问题【等学完了错误处理再回来解决】"><a href="#遗留的问题【等学完了错误处理再回来解决】" class="headerlink" title="遗留的问题【等学完了错误处理再回来解决】"></a>遗留的问题【等学完了错误处理再回来解决】</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-keyword">import</span> math<br><br><span class="hljs-comment"># def mul(x, *args):</span><br><span class="hljs-comment">#     ans = x</span><br><span class="hljs-comment">#     for num in args:</span><br><span class="hljs-comment">#         ans = ans * num</span><br><span class="hljs-comment">#     return ans</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mul</span>(<span class="hljs-params">*args</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-number">123213</span>)<br>        <span class="hljs-keyword">return</span> TypeError(<span class="hljs-string">&quot;Lack of numbers&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        ans = <span class="hljs-number">1</span><br>        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> args:<br>            ans = ans * num<br>        <span class="hljs-keyword">return</span> ans<br><br><br><span class="hljs-comment"># 测试</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;mul(5) =&#x27;</span>, mul(<span class="hljs-number">5</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;mul(5, 6) =&#x27;</span>, mul(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;mul(5, 6, 7) =&#x27;</span>, mul(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;mul(5, 6, 7, 9) =&#x27;</span>, mul(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>))<br><span class="hljs-keyword">if</span> mul(<span class="hljs-number">5</span>) != <span class="hljs-number">5</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试失败!&#x27;</span>)<br><span class="hljs-keyword">elif</span> mul(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>) != <span class="hljs-number">30</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试失败!&#x27;</span>)<br><span class="hljs-keyword">elif</span> mul(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>) != <span class="hljs-number">210</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试失败!&#x27;</span>)<br><span class="hljs-keyword">elif</span> mul(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>) != <span class="hljs-number">1890</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试失败!&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-keyword">try</span>:<br>        mul()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试失败!&#x27;</span>)<br>    <span class="hljs-keyword">except</span> TypeError:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;测试成功!&#x27;</span>)<br></code></pre></td></tr></table></figure><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017261630425888#0">课后练习</a></p><p>注释掉的是正确答案，现在还不太懂。</p><p>（文件名：ex_function_para.py）</p><h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><p><strong>倒数第一位置的索引是-1</strong></p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">is_palindrome</span>(<span class="hljs-params">n</span>): <span class="hljs-comment">#判断一个数是否是回文数</span><br>    l = [ch <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(n)]<br>    <span class="hljs-keyword">return</span> l == l[::-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>通过<code>for</code>循环来遍历这个<code>list</code>或<code>tuple</code>，这种遍历我们称为迭代（Iteration）</p><ul><li>通过<code>collections.abc</code>模块的<code>Iterable</code>类型判断对象是否可迭代：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;abc&#x27;</span>, Iterable) <span class="hljs-comment"># str是否可迭代</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], Iterable) <span class="hljs-comment"># list是否可迭代</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-number">123</span>, Iterable) <span class="hljs-comment"># 整数是否可迭代</span><br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><ul><li>在<code>for</code>循环中同时迭代索引和元素本身：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> i, value <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>([<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]): <br>    <span class="hljs-comment">#`enumerate`函数可以把一个`list`变成索引-元素对</span><br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(i, value)<br>...<br><span class="hljs-number">0</span> A<br><span class="hljs-number">1</span> B<br><span class="hljs-number">2</span> C<br></code></pre></td></tr></table></figure><h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><ul><li>基本示例：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>[x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>, <span class="hljs-number">100</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>[x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>]<br>[<span class="hljs-number">4</span>, <span class="hljs-number">16</span>, <span class="hljs-number">36</span>, <span class="hljs-number">64</span>, <span class="hljs-number">100</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>[m + n <span class="hljs-keyword">for</span> m <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;ABC&#x27;</span> <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;XYZ&#x27;</span>]<br>[<span class="hljs-string">&#x27;AX&#x27;</span>, <span class="hljs-string">&#x27;AY&#x27;</span>, <span class="hljs-string">&#x27;AZ&#x27;</span>, <span class="hljs-string">&#x27;BX&#x27;</span>, <span class="hljs-string">&#x27;BY&#x27;</span>, <span class="hljs-string">&#x27;BZ&#x27;</span>, <span class="hljs-string">&#x27;CX&#x27;</span>, <span class="hljs-string">&#x27;CY&#x27;</span>, <span class="hljs-string">&#x27;CZ&#x27;</span>]<br></code></pre></td></tr></table></figure><ul><li>列出当前目录下的所有文件和目录名现：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> os <span class="hljs-comment"># 导入os模块，模块的概念后面讲到</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>[d <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> os.listdir(<span class="hljs-string">&#x27;.&#x27;</span>)] <span class="hljs-comment"># os.listdir可以列出文件和目录</span><br>[<span class="hljs-string">&#x27;.emacs.d&#x27;</span>, <span class="hljs-string">&#x27;.ssh&#x27;</span>, <span class="hljs-string">&#x27;.Trash&#x27;</span>, <span class="hljs-string">&#x27;Adlm&#x27;</span>, <span class="hljs-string">&#x27;Applications&#x27;</span>, <span class="hljs-string">&#x27;Desktop&#x27;</span>, <span class="hljs-string">&#x27;Documents&#x27;</span>, <span class="hljs-string">&#x27;Downloads&#x27;</span>, <span class="hljs-string">&#x27;Library&#x27;</span>, <span class="hljs-string">&#x27;Movies&#x27;</span>, <span class="hljs-string">&#x27;Music&#x27;</span>, <span class="hljs-string">&#x27;Pictures&#x27;</span>, <span class="hljs-string">&#x27;Public&#x27;</span>, <span class="hljs-string">&#x27;VirtualBox VMs&#x27;</span>, <span class="hljs-string">&#x27;Workspace&#x27;</span>, <span class="hljs-string">&#x27;XCode&#x27;</span>]<br></code></pre></td></tr></table></figure><p>在一个列表生成式中，<code>for</code>前面的<code>if ... else</code>是表达式，而<code>for</code>后面的<code>if</code>是过滤条件，不能带<code>else</code>。</p><ul><li>if … else的位置</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>[x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>) <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>] <span class="hljs-comment"># 过滤条件</span><br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span>[x <span class="hljs-keyword">if</span> x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>)] <span class="hljs-comment"># 表达式</span><br>[-<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, -<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, -<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, -<span class="hljs-number">9</span>, <span class="hljs-number">10</span>]<br></code></pre></td></tr></table></figure><p>2022-7-31 复习到generator</p><hr><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>Python中，这种一边循环一边计算的机制，称为生成器：generator</p><ul><li>把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>L = [x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span>L<br>[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>g = (x * x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-meta">&gt;&gt;&gt; </span>g<br>&lt;generator <span class="hljs-built_in">object</span> &lt;genexpr&gt; at <span class="hljs-number">0x1022ef630</span>&gt;<br></code></pre></td></tr></table></figure><ul><li>函数定义中包含<code>yield</code>关键字，成为generator函数，调用一个generator函数将返回一个generator：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params"><span class="hljs-built_in">max</span></span>):<br>    n, a, b = <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">while</span> n &lt; <span class="hljs-built_in">max</span>:<br>        <span class="hljs-keyword">yield</span> b<br>        a, b = b, a + b<br>        n = n + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;done&#x27;</span><br></code></pre></td></tr></table></figure><p>generator的函数，在每次调用<code>next()</code>的时候执行，遇到<code>yield</code>语句返回，再次执行时从上次返回的<code>yield</code>语句处继续执行。</p><p>正确的写法是创建一个generator对象，然后不断对这一个generator对象调用<code>next()</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>g = odd()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(g)<br>step <span class="hljs-number">1</span><br><span class="hljs-number">1</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(g)<br>step <span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">next</span>(g)<br>step <span class="hljs-number">3</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>2022-7-27 学到迭代器</p><hr><h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><p>可以直接作用于<code>for</code>循环的对象统称为<strong>可迭代对象</strong>：<code>Iterable</code>，可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterable<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>([], Iterable)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(&#123;&#125;, Iterable)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;abc&#x27;</span>, Iterable)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>((x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)), Iterable)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-number">100</span>, Iterable)<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>可迭代对象包括：</p><ul><li><p>集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；</p></li><li><p><code>generator</code>，包括生成器和带<code>yield</code>的generator function。</p></li></ul><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为<strong>迭代器</strong>：<code>Iterator</code>。可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> collections.abc <span class="hljs-keyword">import</span> Iterator<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>((x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)), Iterator)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>([], Iterator)<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(&#123;&#125;, Iterator)<br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-string">&#x27;abc&#x27;</span>, Iterator)<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code></p><p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-built_in">iter</span>([]), Iterator)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(<span class="hljs-built_in">iter</span>(<span class="hljs-string">&#x27;abc&#x27;</span>), Iterator)<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><p>Python的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]:<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>实际上完全等价于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 首先获得Iterator对象:</span><br>it = <span class="hljs-built_in">iter</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><span class="hljs-comment"># 循环:</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 获得下一个值:</span><br>        x = <span class="hljs-built_in">next</span>(it)<br>    <span class="hljs-keyword">except</span> StopIteration:<br>        <span class="hljs-comment"># 遇到StopIteration就退出循环</span><br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><h3 id="变量指向函数"><a href="#变量指向函数" class="headerlink" title="变量指向函数"></a>变量指向函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-built_in">abs</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>f(-<span class="hljs-number">10</span>)<br><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>函数名其实就是指向函数的变量！</p><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p><strong>一个函数就可以接收另一个函数作为参数</strong>，这种函数就称之为高阶函数</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y, f</span>):<br>    <span class="hljs-keyword">return</span> f(x) + f(y)<br></code></pre></td></tr></table></figure><p>调用<code>add(-5, 6, abs)</code>时，参数<code>x</code>，<code>y</code>和<code>f</code>分别接收<code>-5</code>，<code>6</code>和<code>abs</code>，计算过程为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">x = -<span class="hljs-number">5</span><br>y = <span class="hljs-number">6</span><br>f = <span class="hljs-built_in">abs</span><br>f(x) + f(y) ==&gt; <span class="hljs-built_in">abs</span>(-<span class="hljs-number">5</span>) + <span class="hljs-built_in">abs</span>(<span class="hljs-number">6</span>) ==&gt; <span class="hljs-number">11</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p><code>map()</code>函数接收两个参数，一个是函数，一个是<code>Iterable</code>（可迭代对象），<code>map</code>将传入的函数依次作用到序列的每个元素，并把结果作为新的<code>Iterator</code>（迭代器）返回</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>r = <span class="hljs-built_in">map</span>(f, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>])<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(r)<br>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br><br><span class="hljs-comment"># 注意：返回值为迭代器，需要转化为list才能用</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]))<br>[<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&#x27;9&#x27;</span>]<br></code></pre></td></tr></table></figure><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p><code>reduce</code>把一个函数作用在一个序列<code>[x1, x2, x3, ...]</code>上，这个函数必须接收两个参数，<code>reduce</code>把结果继续和序列的下一个元素做累积计算，其效果就是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> reduce<br><br>DIGITS = &#123;<span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;4&#x27;</span>: <span class="hljs-number">4</span>, <span class="hljs-string">&#x27;5&#x27;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&#x27;6&#x27;</span>: <span class="hljs-number">6</span>, <span class="hljs-string">&#x27;7&#x27;</span>: <span class="hljs-number">7</span>, <span class="hljs-string">&#x27;8&#x27;</span>: <span class="hljs-number">8</span>, <span class="hljs-string">&#x27;9&#x27;</span>: <span class="hljs-number">9</span>&#125;<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">str2int</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y</span>):<br>        <span class="hljs-keyword">return</span> x * <span class="hljs-number">10</span> + y<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">char2num</span>(<span class="hljs-params">s</span>):<br>        <span class="hljs-keyword">return</span> DIGITS[s]<br>    <span class="hljs-keyword">return</span> reduce(fn, <span class="hljs-built_in">map</span>(char2num, s))<br></code></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>示例：删掉一个序列中的空字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">not_empty</span>(<span class="hljs-params">s</span>):<br>    <span class="hljs-keyword">return</span> s <span class="hljs-keyword">and</span> s.strip()<br><br><span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(not_empty, [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-literal">None</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;  &#x27;</span>]))<br><span class="hljs-comment"># 结果: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span><br></code></pre></td></tr></table></figure><p><code>filter()</code>函数返回的是一个<code>Iterator</code>，也就是一个惰性序列，所以要强迫<code>filter()</code>完成计算结果，需要用<code>list()</code>函数获得所有结果并返回list。</p><h4 id="【待理解：filter实现素数筛子-ex-filter-prime-sieve-py-】"><a href="#【待理解：filter实现素数筛子-ex-filter-prime-sieve-py-】" class="headerlink" title="【待理解：filter实现素数筛子(ex_filter_prime_sieve.py)】"></a>【待理解：filter实现素数筛子(ex_filter_prime_sieve.py)】</h4><h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p><code>sorted()</code>函数可以接收一个<code>key</code>函数来实现自定义的排序</p><p>示例：</p><h5 id="按绝对值大小排序："><a href="#按绝对值大小排序：" class="headerlink" title="按绝对值大小排序："></a>按绝对值大小排序：</h5><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="language-python"><span class="hljs-built_in">sorted</span>([<span class="hljs-number">36</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">12</span>, <span class="hljs-number">9</span>, -<span class="hljs-number">21</span>], key=<span class="hljs-built_in">abs</span>)</span><br>[5, 9, -12, -21, 36]<br></code></pre></td></tr></table></figure><p>key指定的函数将作用于list的每一个元素上，并根据key函数返回的结果进行排序。对比原始的list和经过<code>key=abs</code>处理过的list：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">list</span> = [<span class="hljs-number">36</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">12</span>, <span class="hljs-number">9</span>, -<span class="hljs-number">21</span>]<br><br><span class="hljs-attr">keys</span> = [<span class="hljs-number">36</span>, <span class="hljs-number">5</span>,  <span class="hljs-number">12</span>, <span class="hljs-number">9</span>,  <span class="hljs-number">21</span>]<br></code></pre></td></tr></table></figure><p>然后<code>sorted()</code>函数按照keys进行排序，并按照对应关系返回list相应的元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ascii">keys排序结果 =&gt; [5, 9,  12,  21, 36]<br>                |  |    |    |   |<br>最终结果     =&gt; [5, 9, -12, -21, 36]<br></code></pre></td></tr></table></figure><h5 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h5><p>默认排序：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;&gt;&gt; <span class="hljs-built_in">sorted</span>(<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-string">&#x27;about&#x27;</span>, <span class="hljs-string">&#x27;Zoo&#x27;</span>, <span class="hljs-string">&#x27;Credit&#x27;</span>]</span>)<br><span class="hljs-selector-attr">[<span class="hljs-string">&#x27;Credit&#x27;</span>, <span class="hljs-string">&#x27;Zoo&#x27;</span>, <span class="hljs-string">&#x27;about&#x27;</span>, <span class="hljs-string">&#x27;bob&#x27;</span>]</span><br></code></pre></td></tr></table></figure><p>默认情况下，对字符串排序，是按照ASCII的大小比较的，由于<code>&#39;Z&#39; &lt; &#39;a&#39;</code>，结果，大写字母<code>Z</code>会排在小写字母<code>a</code>的前面。</p><p>现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。</p><p>这样，我们给<code>sorted</code>传入key函数，即可实现忽略大小写的排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">sorted</span>([<span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-string">&#x27;about&#x27;</span>, <span class="hljs-string">&#x27;Zoo&#x27;</span>, <span class="hljs-string">&#x27;Credit&#x27;</span>], key=<span class="hljs-built_in">str</span>.lower)<br>[<span class="hljs-string">&#x27;about&#x27;</span>, <span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-string">&#x27;Credit&#x27;</span>, <span class="hljs-string">&#x27;Zoo&#x27;</span>]<br></code></pre></td></tr></table></figure><p>要进行反向排序，不必改动key函数，可以传入第三个参数<code>reverse=True</code>：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&gt;&gt;&gt; sorted([<span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-string">&#x27;about&#x27;</span>, <span class="hljs-string">&#x27;Zoo&#x27;</span>, <span class="hljs-string">&#x27;Credit&#x27;</span>], <span class="hljs-attribute">key</span>=str.lower, <span class="hljs-attribute">reverse</span>=<span class="hljs-literal">True</span>)<br>[<span class="hljs-string">&#x27;Zoo&#x27;</span>, <span class="hljs-string">&#x27;Credit&#x27;</span>, <span class="hljs-string">&#x27;bob&#x27;</span>, <span class="hljs-string">&#x27;about&#x27;</span>]<br></code></pre></td></tr></table></figure><p>看到返回函数 2022-7-28</p><hr><h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><h3 id="匿名函数-lambda"><a href="#匿名函数-lambda" class="headerlink" title="匿名函数(lambda)"></a>匿名函数(lambda)</h3><p>Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象（lambda abstraction）</p><p>关键字<code>lambda</code>表示匿名函数，冒号前面的<code>x</code>表示函数参数。</p><p>匿名函数有个限制，就是只能有一个表达式，不用写<code>return</code>，返回值就是该表达式的结果。</p><p>可以把匿名函数赋值给一个变量，再利用变量来调用该函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>f = <span class="hljs-keyword">lambda</span> x: x * x<br><span class="hljs-meta">&gt;&gt;&gt; </span>f<br>&lt;function &lt;<span class="hljs-keyword">lambda</span>&gt; at <span class="hljs-number">0x101c6ef28</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>f(<span class="hljs-number">5</span>)<br><span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。本质上，decorator就是一个返回函数的高阶函数。</p><p>所以，我们要定义一个能打印日志的decorator，可以定义如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">def log(func):<br>    def <span class="hljs-keyword">wrapper</span>(*args, **kw):<br>        print(<span class="hljs-string">&#x27;call %s():&#x27;</span> % func.__name__)<br>        <span class="hljs-keyword">return</span> func(*args, **kw)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">wrapper</span><br></code></pre></td></tr></table></figure><h3 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h3><p>采用<code>functools.partial</code>创建。</p><p><code>functools.partial</code>的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> functools<br><span class="hljs-meta">&gt;&gt;&gt; </span>int2 = functools.partial(<span class="hljs-built_in">int</span>, base=<span class="hljs-number">2</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>int2(<span class="hljs-string">&#x27;1000000&#x27;</span>)<br><span class="hljs-number">64</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>int2(<span class="hljs-string">&#x27;1010101&#x27;</span>)<br><span class="hljs-number">85</span><br></code></pre></td></tr></table></figure><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>使用模块的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># --python标准文件模板--</span><br><br><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-string">&#x27; a test module &#x27;</span> <span class="hljs-comment"># 模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释</span><br><br>__author__ = <span class="hljs-string">&#x27;Michael Liao&#x27;</span> <span class="hljs-comment"># 作者</span><br><br><span class="hljs-comment"># --python标准文件模板--</span><br><br><span class="hljs-keyword">import</span> sys <span class="hljs-comment"># 导入的实质是使变量sys指向该模块</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>():<br>    args = sys.argv<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args)==<span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>)<br>    <span class="hljs-keyword">elif</span> <span class="hljs-built_in">len</span>(args)==<span class="hljs-number">2</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello, %s!&#x27;</span> % args[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Too many arguments!&#x27;</span>)<br><br><span class="hljs-comment"># if测试可以让模块通过命令行执行时额外进行测试</span><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test()<br></code></pre></td></tr></table></figure><p>学到面向对象高级编程 2022-7-30</p><hr><h2 id="一些实际问题"><a href="#一些实际问题" class="headerlink" title="一些实际问题"></a>一些实际问题</h2><h3 id="字符画"><a href="#字符画" class="headerlink" title="字符画"></a>字符画</h3><p>现在自己写的尺寸有些问题</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git入门</title>
    <link href="/2022/12/17/Git%E5%85%A5%E9%97%A8/"/>
    <url>/2022/12/17/Git%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Git入门"><a href="#Git入门" class="headerlink" title="Git入门"></a>Git入门</h1><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的官方网站中的git教程</a></p><p><a href="https://backlog.com/git-tutorial/cn/intro/intro1_1.html">猴子都能懂的git入门</a></p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="初始化git仓库"><a href="#初始化git仓库" class="headerlink" title="初始化git仓库"></a>初始化git仓库</h3><p><code>git init</code></p><p>注意只有在git目录下有效。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta"># </span><span class="language-bash">以创建空目录“learngit”为例</span><br><span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> learngit</span><br><span class="hljs-meta">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> learngit</span><br><span class="hljs-meta">$ </span><span class="language-bash">git init</span><br></code></pre></td></tr></table></figure><h3 id="文件放入git仓库"><a href="#文件放入git仓库" class="headerlink" title="文件放入git仓库"></a>文件放入git仓库</h3><ul><li><p><code>git add &lt;file&gt;</code>，</p><p>可反复多次使用，添加多个文件；</p></li><li><p><code>git commit -m &lt;message&gt;</code></p></li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-comment"># 首先将文件放到当前目录(或者其子目录下)</span><br><span class="hljs-comment"># 以readme.txt为例</span><br>$ git add readme.txt <span class="hljs-comment"># 可反复使用以提交多个文件</span><br>$ git commit -m <span class="hljs-string">&quot;wrote a readme file&quot;</span><br>[<span class="hljs-keyword">master</span> <span class="hljs-title">(root-commit</span>) eaadf4e] wrote a readme file<br> <span class="hljs-number">1</span> file changed, <span class="hljs-number">2</span> insertions(+)<br> create mode <span class="hljs-number">100644</span> readme.txt<br></code></pre></td></tr></table></figure><h3 id="查看工作区状态"><a href="#查看工作区状态" class="headerlink" title="查看工作区状态"></a>查看工作区状态</h3><p><code>git status</code></p><h3 id="查看文件修改内容"><a href="#查看文件修改内容" class="headerlink" title="查看文件修改内容"></a>查看文件修改内容</h3><p><code>git diff</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs diff">$ git diff HEAD -- readme.txt <br><span class="hljs-comment">diff --git a/readme.txt b/readme.txt</span><br><span class="hljs-comment">index 76d770f..a9c5755 100644</span><br><span class="hljs-comment">--- a/readme.txt</span><br><span class="hljs-comment">+++ b/readme.txt</span><br><span class="hljs-meta">@@ -1,4 +1,4 @@</span><br> Git is a distributed version control system.<br> Git is free software distributed under the GPL.<br> Git has a mutable index called stage.<br><span class="hljs-deletion">-Git tracks changes.</span><br><span class="hljs-addition">+Git tracks changes of files.</span><br></code></pre></td></tr></table></figure><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><ul><li><p><code>HEAD</code>指向的版本就是当前版本，上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，可以写成<code>HEAD~100</code></p></li><li><p><code>git log</code><br>查看提交历史</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ git log<br>commit <span class="hljs-number">1094</span>adb<span class="hljs-number">7</span>b<span class="hljs-number">9</span>b<span class="hljs-number">3807259</span>d<span class="hljs-number">8</span>cb<span class="hljs-number">349e7</span>df<span class="hljs-number">1</span>d<span class="hljs-number">4</span>d<span class="hljs-number">6477073</span> (HEAD -&gt; master)<br>Author: Michael Liao &lt;askxuefeng<span class="hljs-title">@gmail.com</span>&gt;<br>Date:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">21</span>:<span class="hljs-number">06</span>:<span class="hljs-number">15</span> <span class="hljs-number">2018</span> +<span class="hljs-number">0800</span><br><br>    append GPL<br><br>commit e<span class="hljs-number">475</span>afc<span class="hljs-number">93</span><span class="hljs-keyword">c</span><span class="hljs-number">209</span>a<span class="hljs-number">690</span><span class="hljs-keyword">c</span><span class="hljs-number">39</span><span class="hljs-keyword">c</span><span class="hljs-number">13</span>a<span class="hljs-number">46716e8</span>fa<span class="hljs-number">000</span><span class="hljs-keyword">c</span><span class="hljs-number">366</span><br>Author: Michael Liao &lt;askxuefeng<span class="hljs-title">@gmail.com</span>&gt;<br>Date:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">21</span>:<span class="hljs-number">03</span>:<span class="hljs-number">36</span> <span class="hljs-number">2018</span> +<span class="hljs-number">0800</span><br><br>    <span class="hljs-keyword">add</span> distributed<br><br>commit eaadf<span class="hljs-number">4e385</span>e<span class="hljs-number">865</span>d<span class="hljs-number">25</span><span class="hljs-keyword">c</span><span class="hljs-number">48e7</span>ca<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">8395</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>f<span class="hljs-number">7</span>dfaef<span class="hljs-number">0</span><br>Author: Michael Liao &lt;askxuefeng<span class="hljs-title">@gmail.com</span>&gt;<br>Date:   Fri May <span class="hljs-number">18</span> <span class="hljs-number">20</span>:<span class="hljs-number">59</span>:<span class="hljs-number">18</span> <span class="hljs-number">2018</span> +<span class="hljs-number">0800</span><br><br>    wrote a readme file<br></code></pre></td></tr></table></figure><p>加上<code>--pretty=oneline</code>参数进行简化</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$ git log --pretty<span class="hljs-operator">=</span>oneline<br><span class="hljs-number">1094</span>adb<span class="hljs-number">7</span>b<span class="hljs-number">9</span>b<span class="hljs-number">3807259</span>d<span class="hljs-number">8</span>cb<span class="hljs-number">349e7</span>df<span class="hljs-number">1</span>d<span class="hljs-number">4</span>d<span class="hljs-number">6477073</span> (HEAD -&gt; master) append GPL<br>e<span class="hljs-number">475</span>afc<span class="hljs-number">93</span><span class="hljs-keyword">c</span><span class="hljs-number">209</span>a<span class="hljs-number">690</span><span class="hljs-keyword">c</span><span class="hljs-number">39</span><span class="hljs-keyword">c</span><span class="hljs-number">13</span>a<span class="hljs-number">46716e8</span>fa<span class="hljs-number">000</span><span class="hljs-keyword">c</span><span class="hljs-number">366</span> <span class="hljs-keyword">add</span> distributed<br>eaadf<span class="hljs-number">4e385</span>e<span class="hljs-number">865</span>d<span class="hljs-number">25</span><span class="hljs-keyword">c</span><span class="hljs-number">48e7</span>ca<span class="hljs-number">9</span><span class="hljs-keyword">c</span><span class="hljs-number">8395</span><span class="hljs-keyword">c</span><span class="hljs-number">3</span>f<span class="hljs-number">7</span>dfaef<span class="hljs-number">0</span> wrote a readme file<br></code></pre></td></tr></table></figure></li><li><p><code>git reflog</code></p><p>查看命令历史</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git reflog<br>e475afc HEAD@&#123;<span class="hljs-number">1</span>&#125;: <span class="hljs-keyword">reset</span>: moving <span class="hljs-keyword">to</span> HEAD^<br><span class="hljs-number">1094</span>adb (HEAD -&gt; master) HEAD@&#123;<span class="hljs-number">2</span>&#125;: <span class="hljs-keyword">commit</span>: append GPL<br>e475afc HEAD@&#123;<span class="hljs-number">3</span>&#125;: <span class="hljs-keyword">commit</span>: <span class="hljs-keyword">add</span> distributed<br>eaadf4e HEAD@&#123;<span class="hljs-number">4</span>&#125;: <span class="hljs-keyword">commit</span> (initial): wrote a readme file<br></code></pre></td></tr></table></figure></li><li><p><code>git reset --hard commit_id</code></p><p>回退到指定版本，<code>commit_id</code>可以通过<code>git log</code>查询。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">reset</span> --hard 1094a<br>HEAD <span class="hljs-built_in">is</span> now <span class="hljs-built_in">at</span> 83b0afe <span class="hljs-built_in">append</span> GPL<br></code></pre></td></tr></table></figure><p>特殊地，<code>$ git reset --hard HEAD^</code>可以回到上一个版本。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^</span><br>HEAD <span class="hljs-keyword">is</span> now at e475afc <span class="hljs-keyword">add</span> distributed撤销<br></code></pre></td></tr></table></figure></li></ul><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><ul><li><p>想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">$ git checkout <span class="hljs-comment">-- readme.txt</span><br><br>$ git status<br><span class="hljs-keyword">On</span> branch master<br><span class="hljs-keyword">nothing</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">commit</span>, working tree clean<br></code></pre></td></tr></table></figure></li><li><p>改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改</p><p>第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git reset HEAD readme.txt<br>Unstaged changes <span class="hljs-keyword">after</span> <span class="hljs-symbol">reset:</span><br>Mreadme.txt<br></code></pre></td></tr></table></figure></li><li><p>已经提交了不合适的修改到版本库时，想要撤销本次提交</p><p><strong>版本回退</strong></p></li></ul><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>删除文件后：</p><ul><li><p>确实希望删除</p><p><code>git rm</code>     <code>git commit -m</code></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stata">$ git <span class="hljs-keyword">rm</span> <span class="hljs-keyword">test</span>.txt<br><span class="hljs-keyword">rm</span> &#x27;<span class="hljs-keyword">test</span>.txt&#x27;<br><br>$ git commit -<span class="hljs-keyword">m</span> <span class="hljs-string">&quot;remove test.txt&quot;</span><br>[master d46f35e] remove <span class="hljs-keyword">test</span>.txt<br> 1 <span class="hljs-keyword">file</span> changed, 1 deletion(-)<br> delete mode 100644 <span class="hljs-keyword">test</span>.txt<br></code></pre></td></tr></table></figure></li><li><p>误删，希望恢复</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ git checkout <span class="hljs-comment">-- test.txt</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="远程库连接"><a href="#远程库连接" class="headerlink" title="远程库连接"></a>远程库连接</h3><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p>新建仓库后，看到页面：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/image-20220802203838527.5z4enq85ml00.webp" alt="image-20220802203838527"></p><p>按照github的提示：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">git remote add origin https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/thunderbolt215/</span>test_git.git<br>git branch -M main<br>git push -u origin main<br></code></pre></td></tr></table></figure><p>此后提交文件只需要：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><h4 id="解除和远程库关系"><a href="#解除和远程库关系" class="headerlink" title="解除和远程库关系"></a>解除和远程库关系</h4><p>用<code>git remote -v</code>查看远程库信息：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">$ git remote -v<br>origin  git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/learn-git.git (fetch)<br>origin  git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:michaelliao/learn-git.git (push)<br></code></pre></td></tr></table></figure><p>然后，根据名字删除，比如删除<code>origin</code>：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> git remote <span class="hljs-built_in">rm</span> origin<br></code></pre></td></tr></table></figure><p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库，远程库本身并没有任何改动。</p><p>要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p><h4 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h4><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</p><p>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> git@github.com:michaelliao/gitskills.git <span class="hljs-comment"># ssh协议</span></span><br><span class="hljs-meta">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://github.com/thunderbolt215/test_git.git <span class="hljs-comment"># https协议</span></span><br></code></pre></td></tr></table></figure><p>这部分如果出现拒绝访问等错误可以尝试：</p><ul><li><p>重启git bash</p></li><li><p>查看ssh是否有问题</p><p>（参考：<a href="https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416）">https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416）</a></p></li></ul><p>2022-8-2 学到分支管理</p><hr><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><h4 id="简单图示"><a href="#简单图示" class="headerlink" title="简单图示"></a>简单图示</h4><p>初始状态</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919022325462368/0" alt="git-br-initial"></p><p>创建新分支</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919022363210080/l" alt="git-br-create"></p><p>dev分支下添加内容</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919022387118368/l" alt="git-br-dev-fd"></p><p>合并</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919022412005504/0" alt="git-br-ff-merge"></p><p>删除dev分支</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919022479428512/0" alt="git-br-rm"></p><h4 id="基本操作-1"><a href="#基本操作-1" class="headerlink" title="基本操作"></a>基本操作</h4><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git switch &lt;name&gt;</code>(<code>git checkout &lt;name&gt;</code>)</p><p>创建+切换分支：<code>git switch -c &lt;name&gt;</code>(<code>git checkout -b &lt;name&gt;</code>)</p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><p>分支合并图：<code>git log --graph</code></p><p>查看远程仓库信息：</p><p><code>git remote -v</code>显示更详细的信息：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ git remote -v<br>origin  https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/thunderbolt215/</span>test_git.git (fetch)<br>origin  https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/thunderbolt215/</span>test_git.git (push)<br></code></pre></td></tr></table></figure><p>显示了可以抓取和推送的<code>origin</code>的地址</p><h4 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h4><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>示例：</p><p>创建新分支feature1，提交相应修改；然后切换到main分支，提交修改：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919023000423040/0" alt="git-br-feature1"></p><p>此时无法直接合并，产生冲突。</p><p>解决冲突需要将文件修改后保存，此时分支示意图：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919023031831104/0" alt="git-br-conflict-merged"></p><p>最后删除feature1分支即完成。</p><h4 id="管理策略"><a href="#管理策略" class="headerlink" title="管理策略"></a>管理策略</h4><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p><code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://cdn.staticaly.com/gh/thunderbolt215/imagehosting@main/data/7.2mtnxv2ejoa0.webp" alt="7"></p><p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p><h4 id="bug分支【没看懂】"><a href="#bug分支【没看懂】" class="headerlink" title="bug分支【没看懂】"></a>bug分支【没看懂】</h4><h4 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h4><p>开发一个新feature，最好新建一个分支。</p><p>如果要丢弃一个没有被合并过的分支（即执行过了<code>git commit</code>但是还没<code>git merge</code>），可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h4 id="push-1"><a href="#push-1" class="headerlink" title="push"></a>push</h4><p>推送时指定本地分支：(main 为例)</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> main<br></code></pre></td></tr></table></figure><p>2022-8-3 学到标签管理</p><hr><h2 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="零碎知识点"></a>零碎知识点</h2><h3 id="版本控制系统只能跟踪文本文件"><a href="#版本控制系统只能跟踪文本文件" class="headerlink" title="版本控制系统只能跟踪文本文件"></a>版本控制系统只能跟踪文本文件</h3><ul><li>只能跟踪<strong>纯文本文件</strong>的改动</li><li>word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的</li><li>windows下采用记事本编辑文件会出问题，应该采用vscode</li></ul><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><ul><li>工作区</li></ul><p><img src="https://www.liaoxuefeng.com/files/attachments/919021113952544/0" alt="working-dir"></p><ul><li>暂存区</li></ul><p>工作区的隐藏目录<code>.git</code>是git的版本库，其中有暂存区(stage)</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919020037470528/0" alt="git-repo"></p><p><code>git add</code>：把要提交的所有修改放到暂存区</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919020074026336/0" alt="git-stage"></p><p><code>git commit</code>：一次性把暂存区的所有修改提交到分支</p><p><img src="https://www.liaoxuefeng.com/files/attachments/919020100829536/0" alt="git-stage-after-commit"></p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>降维观测器</title>
    <link href="/2022/04/06/%E9%99%8D%E7%BB%B4%E8%A7%82%E6%B5%8B%E5%99%A8/"/>
    <url>/2022/04/06/%E9%99%8D%E7%BB%B4%E8%A7%82%E6%B5%8B%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="降维观测器简介"><a href="#降维观测器简介" class="headerlink" title="降维观测器简介"></a>降维观测器简介</h1><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>对于系统</p><script type="math/tex; mode=display">\dot{x}=Ax+Bu \\y=Cx</script><p>假设其中x的维数为n，y的维数为m。</p><p>全维观测器对全部变量x进行重构。但是如果状态的某些线性组合可以直接作为输出被测量出来(这由矩阵C决定)，就不需要进行估计，则可以降低其维数，仅需要额外获得n-m个维度的信息，之后配合观测得到的m个维度的信息，通过线性组合，就可以获得状态x的信息，由此引入降维观测器。</p><p>若C矩阵秩为m，则只需要重构余下的n-m个状态分量。</p><span id="more"></span><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>给定线性系统$\sum(A,B,C):$</p><script type="math/tex; mode=display">\dot{x}=Ax+Bu \\y=Cx</script><p>其中C为$m\times n$矩阵，假定$rank(C)=m$，则一定存在线性变换</p><script type="math/tex; mode=display">\overline{x}=Tx,where\space T=[D\space C]^T</script><p>其中D为使得$T^{-1}$存在的任意$(n-m)\times n$阵。</p><p>通过这一线性变换，系统变换为：</p><script type="math/tex; mode=display">\dot{\overline{x} }=TAT^{-1}\overline{x}+TBu \\y=CT^{-1}\overline{x}=[0\space I_m][\overline{x}_1\space \overline{x}_2]^T=\overline{x}_2</script><p>其中$\overline{x}_2$为m维，可以直接量测，因此只需要观测$(n-m)$维状态变量$\overline{x}_1$。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>为避免输出量的微分，重新定义观测器的状态</p><script type="math/tex; mode=display">令W=\hat{x}_1+M_1\dot{y} \\=(A_{11}+M_1A_{21})w+(B_1+M_1B_2)u+ \\ (A_{12}+M_1A{22}-(A_{11}+M_1A_{21})M_1)y \\=(A_{11}+M_1A_{21})w+B_0u+Ey \\其中 \\B_0=B_1+M_1B_2 \\E=A_{12}+M_1A_{22}-(A_{11}+M_1A_{21})M_1 \\</script><p>上述称为Luenberger观测器。</p><p>由此得到原系统的状态重构：</p><script type="math/tex; mode=display">\hat{x}=\left[\matrix{  \hat{x} \\  y \\}\right]=\left[\matrix{  w-M_1 y \\  y \\}\right]=\left[\matrix{  I \\  0 \\}\right]w+\left[\matrix{  -M_1 \\  I \\}\right]y</script><h2 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h2><p>降维观测器的测量值y通过$M_1$直接反映在状态$\hat{x}_1$上，如图所示：</p><p><img src="https://s2.loli.net/2022/04/06/A2aGVTJFpSro4bB.png" alt="image-20220406100227560"></p><p>这样会将测量噪声带入，使得$M_1$的误差直接影响到$\hat{x}_1$稳态值，在全维观测器中则不存在这种误差。</p>]]></content>
    
    
    <categories>
      
      <category>Control</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Control</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kalman Filter</title>
    <link href="/2022/04/01/Kalman-Filter/"/>
    <url>/2022/04/01/Kalman-Filter/</url>
    
    <content type="html"><![CDATA[<h1 id="Kalman滤波算法简介"><a href="#Kalman滤波算法简介" class="headerlink" title="Kalman滤波算法简介"></a>Kalman滤波算法简介</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>卡尔曼滤波（也称为线性二次型估计），是一种最优化自回归数据处理算法，它的主要功能是：从一系列不完全且包含噪声的数据测量值序列中，估计出动态系统的状态。由于其效率高且所占空间较小，在雷达、计算机视觉、机器人导航等很多工程应用领域中都有应用。</p><p>卡尔曼滤波的一个典型实例是：现在有一组有限时间内、包含噪声的数据，记录了物体运动中若干时刻的位置和速度，通过卡尔曼滤波算法可以根据这些数据预测出物体不同时刻的位置以及速度。</p><p><img src="https://s2.loli.net/2022/04/01/VrKt98wXmGWlsJi.png" alt="image-20220401212609431"></p><span id="more"></span><h2 id="约定及说明"><a href="#约定及说明" class="headerlink" title="约定及说明"></a>约定及说明</h2><h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><p>卡尔曼滤波适合于<strong>线性系统</strong>，且要求误差满足<strong>高斯分布</strong>。</p><h3 id="状态空间表达式"><a href="#状态空间表达式" class="headerlink" title="状态空间表达式"></a>状态空间表达式</h3><p>本文中状态空间方程定义如下：</p><h4 id="状态方程"><a href="#状态方程" class="headerlink" title="状态方程"></a>状态方程</h4><script type="math/tex; mode=display">x_k=Ax_{k-1}+Bu_k+w_k</script><p>表示了由上一状态到当前状态的转移关系。其中$x_k$表示当前时刻状态量，$u_k$表示当前时刻输入量，A,B均为系数矩阵，$w_k$为<strong>过程噪声</strong>(即真实的运动与理论方程所不相符的部分)。</p><h4 id="观测方程"><a href="#观测方程" class="headerlink" title="观测方程"></a>观测方程</h4><script type="math/tex; mode=display">y_k=Cx_k+v_k</script><p>表示了当前时刻观测量的计算方式。其中$y_k$表示当前时刻的观测量，C为系数矩阵，$x_k$含义不变，$v_k$表示<strong>观测噪声</strong>(即由于观测仪器引起的噪声，如传感器带来的误差波动)。</p><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>上述噪声$w_k$和$v_k$均符合高斯分布，为高斯白噪声，即</p><script type="math/tex; mode=display">w_k \sim N(0;Q_k) \\v_k \sim N(0;R_k)</script><p><img src="https://s2.loli.net/2022/04/01/9KyuJGZdsEcfeNR.png" alt="image-20220401214819864"></p><p>约定：</p><script type="math/tex; mode=display">\hat{x}_{k}代表最优估计值 \\\hat{x}_{k}^-先验估计值(预测值) \\x_k观测值</script><h2 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h2><h3 id="宏观理解"><a href="#宏观理解" class="headerlink" title="宏观理解"></a>宏观理解</h3><p>卡尔曼滤波算法的实现过程是：使用上一次的最优结果（即先验估计值）预测当前的值，同时使用观测值（如通过传感器获得的数据）修正当前值，得到最优结果。</p><p>图解：</p><p><img src="https://s2.loli.net/2022/04/01/JnDyqAz5bcldRhs.png" alt="image-20220401215455064"></p><h3 id="具体公式"><a href="#具体公式" class="headerlink" title="具体公式"></a>具体公式</h3><p>本部分先逐个介绍各个公式的含义，最后再统一说明他们之间的关系。</p><h4 id="预测部分"><a href="#预测部分" class="headerlink" title="预测部分"></a>预测部分</h4><h5 id="先验估计"><a href="#先验估计" class="headerlink" title="先验估计"></a>先验估计</h5><script type="math/tex; mode=display">\hat{x}_t^- = F\hat{x-1} + Bu_{t-1}</script><p>仍考虑第一部分中提到的小车的例子，假定小车做匀加速直线运动：</p><p><img src="https://s2.loli.net/2022/04/01/G2Of8FBMZResJou.png" alt="image-20220401220002938">        预测模型可以写成</p><script type="math/tex; mode=display">P_i=P_{i-1}+v_{i-1}\Delta t+\frac{a}{2}\Delta t^2 \\v_i=v_{i-1}+a\Delta t</script><p>写成矩阵形式为</p><script type="math/tex; mode=display">\left[\matrix{  p_i  \\  v_i   }\right]=\left[\matrix{  1 & \Delta t \\  0 & 1  }\right]\left[\matrix{  p_{i-1}  \\  v_{i-1}   }\right]+\left[\matrix{  \frac{1}{2}\Delta t^2  \\  \Delta t  }\right]a_i</script><p>则已经化成了上面先验估计方程的形式。</p><h5 id="先验估计协方差"><a href="#先验估计协方差" class="headerlink" title="先验估计协方差"></a>先验估计协方差</h5><script type="math/tex; mode=display">P_t^-=FP_{t-1}F^T+Q</script><p>可根据先验估计方程推导，如下：</p><script type="math/tex; mode=display">根据协方差计算公式： \\cov(Ax+k,Ax+k)=Acov(x,x)A^T \\先验过程中补上过程噪声：\\\hat{x}_t^-=F\hat{x}_{t-1}+Bu_{t-1}+w_t \\\begin{align*}\Rightarrow P_t^- &=cov(\hat{x}_t^-,\hat{x}_t^-) \\&= cov(F\hat{x}_{t-1}+Bu_{t-1}+w_t,F\hat{x}_{t-1}+Bu_{t-1}+w_t) \\&= Fcov(\hat{x}_{t-1},\hat{x}_{t-1})F^T+cov(w_t,w_t) \\&= FP_{t-1}F^T+Q\end{align*}</script><h5 id="测量方程"><a href="#测量方程" class="headerlink" title="测量方程"></a>测量方程</h5><script type="math/tex; mode=display">z_t=Hx_t+V</script><p>沿用上面小车的例子，这里的测量方程可以写为</p><script type="math/tex; mode=display">z_P=P_t+\Delta P_t \\z_v=0 \\\Rightarrow\left[\matrix{  z_P  \\  z_v   }\right]=\left[\matrix{  1 & 0   }\right]\left[\matrix{  p_t  \\  v_t  }\right]+\left[\matrix{  1 & 0   }\right]\left[\matrix{  \Delta p_t  \\  \Delta v_t  }\right]</script><p>注意：<strong>$z_t$的维数未必与$\hat{x}_t$相同</strong></p><h4 id="状态更新部分"><a href="#状态更新部分" class="headerlink" title="状态更新部分"></a>状态更新部分</h4><h5 id="修正估计"><a href="#修正估计" class="headerlink" title="修正估计"></a>修正估计</h5><script type="math/tex; mode=display">\hat{x}_t=\hat{x}_t^-+K_t(z_t-H\hat{x}_t^-)</script><p>可以根据需求调整$K_t$的大小（如：更信任观测值还是估计值）</p><h5 id="卡尔曼增益"><a href="#卡尔曼增益" class="headerlink" title="卡尔曼增益"></a>卡尔曼增益</h5><script type="math/tex; mode=display">K_t=\frac{P_t^-H^T}{HP_t^-H^T+R}</script><p>一维情况下(F=1,H=1)可以化简为</p><script type="math/tex; mode=display">K_t=\frac{P_{t-1}+Q}{P_{t-1}+Q+R}</script><h5 id="更新后验估计协方差"><a href="#更新后验估计协方差" class="headerlink" title="更新后验估计协方差"></a>更新后验估计协方差</h5><script type="math/tex; mode=display">P_t=(I-K_tH)P_t^-</script><h4 id="关系图"><a href="#关系图" class="headerlink" title="关系图"></a>关系图</h4><p><img src="https://s2.loli.net/2022/04/01/6fPISNbgkZMAnuF.png" alt="image-20220401221540966"></p><h3 id="信号流图（转载）"><a href="#信号流图（转载）" class="headerlink" title="信号流图（转载）"></a>信号流图（转载）</h3><p><img src="https://s2.loli.net/2022/04/01/fpDdjO3LmWPV19X.jpg" alt="img"></p><h2 id="实例：小车匀加速运动"><a href="#实例：小车匀加速运动" class="headerlink" title="实例：小车匀加速运动"></a>实例：小车匀加速运动</h2><p>我们将上面所述的实例代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-comment">% 说明</span><br><span class="hljs-comment">% 模型：匀加速运动</span><br><span class="hljs-comment">% x_optimal 最优估计值</span><br><span class="hljs-comment">% x_observe 观测值</span><br><span class="hljs-comment">% x_predict 先验估计值（预测值）</span><br><br>total = <span class="hljs-number">300</span>;<br>delta = <span class="hljs-number">0.1</span>;<br>x_observe(<span class="hljs-number">1</span>) = <span class="hljs-number">0</span>;<br>w = <span class="hljs-built_in">randn</span>(<span class="hljs-number">1</span>, total);<br>Q = (std(w)).^<span class="hljs-number">2</span>;<br>v = <span class="hljs-built_in">randn</span>(<span class="hljs-number">1</span>, total);<br>R = (std(v)).^<span class="hljs-number">2</span>;<br>a = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span> n = <span class="hljs-number">2</span>:total<br>    REF(n) = <span class="hljs-number">1</span>/<span class="hljs-number">2</span>*a*(n*delta).^<span class="hljs-number">2</span>;<br>    x_observe(n) = x_observe(n<span class="hljs-number">-1</span>) + a*(n<span class="hljs-number">-1</span>/<span class="hljs-number">2</span>)*delta.^<span class="hljs-number">2</span>  + w(n);<br>    y(n) = x_observe(n) + v(n);<br><span class="hljs-keyword">end</span><br><br>p_observe(<span class="hljs-number">1</span>) = <span class="hljs-number">1</span>;  <br>x_optimal(<span class="hljs-number">1</span>) = <span class="hljs-number">0</span>;  <br><span class="hljs-keyword">for</span> n = <span class="hljs-number">2</span>:total<br>    <span class="hljs-comment">% 预测</span><br>    x_predict(n) = x_optimal(n<span class="hljs-number">-1</span>) + a*(n<span class="hljs-number">-1</span>/<span class="hljs-number">2</span>)*delta.^<span class="hljs-number">2</span>;<br>    p_predict(n) = p_observe(n<span class="hljs-number">-1</span>) + Q;<br>    <span class="hljs-comment">% 更新</span><br>    k(n) = p_predict(n) / (p_predict(n) + R);<br>    x_optimal(n) = x_predict(n) + k(n) * (y(n) - x_predict(n))<br>    p_observe(n) = (<span class="hljs-number">1</span> - k(n))*p_predict(n); <br><span class="hljs-keyword">end</span><br><br>n = <span class="hljs-number">1</span>:total;<br><span class="hljs-built_in">plot</span>(n, x_optimal, <span class="hljs-string">&#x27;r&#x27;</span>, n ,y, <span class="hljs-string">&#x27;g&#x27;</span>, n, REF, <span class="hljs-string">&#x27;b&#x27;</span>);<br><span class="hljs-built_in">legend</span>(<span class="hljs-string">&#x27;最优估计值&#x27;</span>, <span class="hljs-string">&#x27;实际观测值&#x27;</span>, <span class="hljs-string">&quot;理论值&quot;</span>)<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://s2.loli.net/2022/04/02/7OUPCQlzW6dREhg.jpg" alt=""></p><p><img src="https://s2.loli.net/2022/04/02/HuKPfpjh6TkEXwA.jpg" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Control</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Control</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPMV L4 Camera Calibration</title>
    <link href="/2022/03/27/IPMV-L4-Camera-Calibration/"/>
    <url>/2022/03/27/IPMV-L4-Camera-Calibration/</url>
    
    <content type="html"><![CDATA[<h1 id="04-Camera-Calibration"><a href="#04-Camera-Calibration" class="headerlink" title="04. Camera Calibration"></a>04. Camera Calibration</h1><h2 id="WCS-CCS-IPCS-PCS"><a href="#WCS-CCS-IPCS-PCS" class="headerlink" title="WCS. CCS. IPCS. PCS"></a>WCS. CCS. IPCS. PCS</h2><h3 id="坐标系变换关系汇总"><a href="#坐标系变换关系汇总" class="headerlink" title="坐标系变换关系汇总"></a>坐标系变换关系汇总</h3><p>WCS: World Coordinate System$(X^W,Y^W,Z^W)$</p><p>CCS: Camera Coordinate System$(X^C,Y^C,Z^C)$</p><p>IPCS/FCS: Image Plane Coordinate System/Film Coordinate System $(x,y)$</p><p>PCS: Pixel Coordinate System$(u,v)$</p><script type="math/tex; mode=display">WCS\leftrightarrow CCS\leftrightarrow IPCS\leftrightarrow PCS</script><span id="more"></span><p><img src="https://s2.loli.net/2022/03/27/vWAy7DkO9FI8lRN.png" alt="image-20220327215625379"></p><p><img src="https://s2.loli.net/2022/03/27/VcITkGpqD6OYjex.png" alt="image-20220327220812537"></p><h3 id="补充1：不同旋转平移方式"><a href="#补充1：不同旋转平移方式" class="headerlink" title="补充1：不同旋转平移方式"></a>补充1：不同旋转平移方式</h3><p><img src="https://s2.loli.net/2022/03/27/Uf9QO8XVSogTzFk.png" alt="image-20220327220020765"></p><h3 id="补充2：偏斜系数-skew-coefficient"><a href="#补充2：偏斜系数-skew-coefficient" class="headerlink" title="补充2：偏斜系数(skew coefficient)"></a>补充2：偏斜系数(skew coefficient)</h3><p><img src="https://s2.loli.net/2022/03/27/5yuzcZKhnESseCB.png" alt="image-20220327221019507"></p><h2 id="Affine-transformation"><a href="#Affine-transformation" class="headerlink" title="Affine transformation"></a>Affine transformation</h2><h3 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h3><p>通俗解释及动画演示参考：<a href="https://www.matongxue.com/madocs/244/">https://www.matongxue.com/madocs/244/</a></p><p><strong>Affine transformation = Linear transformation + Translation</strong></p><p>Linear transformation:</p><ul><li>变换前是直线的，变换后依然是直线</li><li>直线比例保持不变</li><li>变换前是原点的，变换后依然是原点</li></ul><p>Affine translation:</p><ul><li>变换前是直线的，变换后依然是直线</li><li>直线比例保持不变</li></ul><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><p><img src="https://s2.loli.net/2022/03/27/k1ZGfj9FhzcAQiS.png" alt="image-20220327222707615"></p><p><img src="https://s2.loli.net/2022/03/27/Czxt7oNIHdKwYka.png" alt="image-20220327222833156"></p><p><img src="https://s2.loli.net/2022/03/27/nMoYiRHgPJ8leGd.png" alt="image-20220327222735348"></p><p><img src="https://s2.loli.net/2022/03/27/6caKyoe52UASF8h.png" alt="image-20220327222803966"></p><p><img src="https://s2.loli.net/2022/03/27/EtlY7dZcxVf51Lm.png" alt="image-20220327222812465"></p><h2 id="Homogeneous-Coordinates进一步理解"><a href="#Homogeneous-Coordinates进一步理解" class="headerlink" title="Homogeneous Coordinates进一步理解"></a>Homogeneous Coordinates进一步理解</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p><strong>Homogeneous coordinates</strong>(Projective coordinates)$\leftrightarrow$<strong>Projective Geometry</strong></p><p>(类比:<strong>Cartesian coordinates</strong>$\leftrightarrow$<strong>Euclidean Geometry</strong>)</p><p>齐次坐标空间与普通坐标空间不同！</p><p><strong>Advantages</strong>: coordinates of points(including$\infty$) can be represented using finite coordinates</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p>Determine the line passing through a(2,0) and b(1,3).</p><p>转化为齐次坐标，作外积得到的向量三个分量即为直线方程的系数A,B,C.</p><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><p><img src="https://s2.loli.net/2022/03/27/O5PJGtvLVsFMR93.png" alt="image-20220327224923394"></p><h2 id="Vanishing-Point-消失点"><a href="#Vanishing-Point-消失点" class="headerlink" title="Vanishing Point(消失点)"></a>Vanishing Point(消失点)</h2><h3 id="Definition-1"><a href="#Definition-1" class="headerlink" title="Definition"></a>Definition</h3><p>2D perspective projections of mutually parallel in 3D space appear to converge.</p><p><img src="https://s2.loli.net/2022/03/27/PxYCygLRlX5eUam.png" alt="image-20220327225133290"></p><h3 id="Example1"><a href="#Example1" class="headerlink" title="Example1"></a>Example1</h3><p><img src="https://s2.loli.net/2022/03/27/vFHR8kPdDYBlhVO.png" alt="image-20220327230026540"></p><h3 id="Example-2-1"><a href="#Example-2-1" class="headerlink" title="Example 2"></a>Example 2</h3><p>How many vanishing points are there in the picture?</p><p><img src="https://s2.loli.net/2022/03/27/8I6jMyWYzCbPLwJ.png" alt="image-20220327230112716"></p><p>Ans: $\infty$</p><p><img src="https://s2.loli.net/2022/03/27/cAMYwS2fZ4kqC65.png" alt="image-20220327230243681"></p><h2 id="Lens-distortion"><a href="#Lens-distortion" class="headerlink" title="Lens distortion"></a>Lens distortion</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Deform the physically straight lines and makes them appear as curves in the images.</p><h3 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h3><h4 id="1-Radial-distortion-径向"><a href="#1-Radial-distortion-径向" class="headerlink" title="1. Radial distortion(径向)"></a>1. Radial distortion(径向)</h4><p>Reason: <strong>Lens’ geometric shape</strong> affects the straight line transformation.</p><p><img src="https://s2.loli.net/2022/03/27/zYVEoIcu3XjSnmf.png" alt="image-20220327231433108"></p><h4 id="2-Tangential-distortion-横向"><a href="#2-Tangential-distortion-横向" class="headerlink" title="2. Tangential distortion(横向)"></a>2. Tangential distortion(横向)</h4><p>Reason: Lens installed in front of the camera is not perfectly parallel to the image plane.</p><p>In practical experiments, the image geometry is affected to a much higher extent with <strong>radial distortion</strong> than with tangential distortion(<strong>sometimes neglected</strong>).</p><h3 id="Radial-distortion"><a href="#Radial-distortion" class="headerlink" title="Radial distortion"></a>Radial distortion</h3><h4 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h4><p><img src="https://s2.loli.net/2022/03/27/zCj1sncUGVgOPKZ.png" alt="image-20220327232506152"></p><h4 id="Calculation"><a href="#Calculation" class="headerlink" title="Calculation"></a>Calculation</h4><script type="math/tex; mode=display">x_{undist}=x_{dist}(1+k_1r^2+k_2r^4+k_3r^6) \\y_{undist}=y_{dist}(1+k_1r^2+k_2r^4+k_3r^6) \\where \\x_{dist}=\frac{x_c}{z_c}=\frac{u-u_o}{f_x} \\y_{dist}=\frac{y_c}{z_c}=\frac{v-v_o}{f_y} \\r^2=x_{dist}^2+y_{dist}^2 \\</script><p>​                                            $k_1,k_2,k_3$ are 3 intrinsic parameters used for radial distortion correction.</p><script type="math/tex; mode=display">P_{dist}=[x_{dist},y_{dist}]^T\rightarrow P_{undist}=[x_{undist},y_{undist}]^T</script><h3 id="Tangential-Distortion"><a href="#Tangential-Distortion" class="headerlink" title="Tangential Distortion"></a>Tangential Distortion</h3><p><img src="https://s2.loli.net/2022/03/28/wcLnq6eAzblNxvM.png" alt="image-20220328092312774"></p><h2 id="Camera-Calibration"><a href="#Camera-Calibration" class="headerlink" title="Camera Calibration"></a>Camera Calibration</h2><h3 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h3><p>Process of <strong>estimating camera parameters</strong> by <strong>using images that contain a calibration pattern</strong>. </p><p>Camera parameters includes:</p><ul><li>Intrinsic matrix</li><li>Distortion coefficients</li><li>Extrinsic matrix</li></ul><p>Applications:</p><ul><li>Remove lens distortion</li><li>Measure planar objects</li><li>Reconstruct 3D scenes from multiple cameras</li></ul><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><h4 id="Step-1-Define-real-world-coordinates-with-checkerboard-pattern"><a href="#Step-1-Define-real-world-coordinates-with-checkerboard-pattern" class="headerlink" title="Step 1. Define real world coordinates with checkerboard pattern."></a>Step 1. Define real world coordinates with checkerboard pattern.</h4><p><img src="https://s2.loli.net/2022/03/28/MV1zRuhYBs8GHS3.png" alt="image-20220328093327268"></p><h4 id="Step-2-Capture-multiple-images-of-the-checkerboard-from-different-viewpoints"><a href="#Step-2-Capture-multiple-images-of-the-checkerboard-from-different-viewpoints" class="headerlink" title="Step 2. Capture multiple images of the checkerboard from different viewpoints."></a>Step 2. Capture multiple images of the checkerboard from different viewpoints.</h4><p><img src="https://s2.loli.net/2022/03/28/fU5CAMmRslitGgp.png" alt="image-20220328093441682"></p><h4 id="Step-3-Find-2D-coordinates-of-the-checkerboard"><a href="#Step-3-Find-2D-coordinates-of-the-checkerboard" class="headerlink" title="Step 3. Find 2D coordinates of the checkerboard."></a>Step 3. Find 2D coordinates of the checkerboard.</h4><p><img src="https://s2.loli.net/2022/03/28/dsTGpbL1Ofz5rj8.png" alt="image-20220328093533228"></p><h4 id="Step-4-Calibrate-the-camera"><a href="#Step-4-Calibrate-the-camera" class="headerlink" title="Step 4. Calibrate the camera."></a>Step 4. Calibrate the camera.</h4><p><img src="https://s2.loli.net/2022/03/28/ZCIYJsixmn67Azt.png" alt="image-20220328093610674"></p><center>Left: Camera-centric</center><center>Right: Pattern-centric </center><h4 id="Step-5-Compute-the-re-projection-error-and-refine-精制，提炼-the-calibration"><a href="#Step-5-Compute-the-re-projection-error-and-refine-精制，提炼-the-calibration" class="headerlink" title="Step 5. Compute the re-projection error and refine(精制，提炼) the calibration."></a>Step 5. Compute the re-projection error and refine(精制，提炼) the calibration.</h4><p><img src="https://s2.loli.net/2022/03/28/eOqPHZUGk4CIasm.png" alt="image-20220328093812637"></p><h3 id="Re-projection-error"><a href="#Re-projection-error" class="headerlink" title="Re-projection error"></a>Re-projection error</h3><p><img src="https://s2.loli.net/2022/03/28/dWki3y89ojaAIhm.png" alt="image-20220328094401951"></p><p><img src="https://s2.loli.net/2022/03/28/LoSGP5Kz4yAaVhc.png" alt="image-20220328094451821"></p>]]></content>
    
    
    <categories>
      
      <category>IPMV courses</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IPMV lecture3 Perspective Transformation</title>
    <link href="/2022/03/08/IPMV-L3-Perspective-Transformation/"/>
    <url>/2022/03/08/IPMV-L3-Perspective-Transformation/</url>
    
    <content type="html"><![CDATA[<h1 id="03-Perspective-Transformation"><a href="#03-Perspective-Transformation" class="headerlink" title="03. Perspective Transformation"></a>03. Perspective Transformation</h1><h2 id="Preliminaries"><a href="#Preliminaries" class="headerlink" title="Preliminaries"></a>Preliminaries</h2><h3 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h3><h4 id="l-p-Norm-p范数"><a href="#l-p-Norm-p范数" class="headerlink" title="$l_p$-Norm (p范数)"></a>$l_p$-Norm (p范数)</h4><script type="math/tex; mode=display">||a||_p=(\sum_{k=1}^n |a_k|^p)^\frac{1}{p}</script><h4 id="Infinity-Norm-无穷范数"><a href="#Infinity-Norm-无穷范数" class="headerlink" title="Infinity Norm (无穷范数)"></a>Infinity Norm (无穷范数)</h4><script type="math/tex; mode=display">||a||_{+\infty}=\max_i |x_i| \\||a||_{-\infty}=\min_i |x_i|</script><span id="more"></span><p>证明：令</p><script type="math/tex; mode=display">a_{max}=max(|x_1|,|x_2|,...,|x_n|) \\\Rightarrow ||a||_p=a_{max}(\sum_{k=1}^n (\frac{|a_k|}{a_{max}})^p)^\frac{1}{p}</script><p>又</p><script type="math/tex; mode=display">1\leq \sum_{k=1}^n(\frac{|a_k|}{a_{max}})^p\leq n \\\Rightarrow 1^{\frac{1}{p}}\leq (\sum_{k=1}^n(\frac{|a_k|}{a_{max}})^p)^{\frac{1}{p}}\leq n^{\frac{1}{p}}</script><p>根据夹逼定理(Squeeze Theorem)</p><script type="math/tex; mode=display">\lim_{p\rightarrow\infty}||a||_p=\lim_{p\rightarrow\infty} a_{max}(\sum_{k=1}^n (\frac{|a_k|}{a_{max}})^p)^\frac{1}{p}=a_{max}</script><p>Q.E.D.</p><h3 id="斜对称矩阵-skew-symmetric-matrix"><a href="#斜对称矩阵-skew-symmetric-matrix" class="headerlink" title="斜对称矩阵(skew-symmetric matrix)"></a>斜对称矩阵(skew-symmetric matrix)</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>如果一个矩阵A是方阵，并且满足</p><script type="math/tex; mode=display">A^T=-A</script><p>则为斜对称矩阵。</p><p>例如：</p><script type="math/tex; mode=display">a=\left[\matrix{  a_1  \\  a_2  \\  a_3 }\right]</script><p>的斜对称矩阵为</p><script type="math/tex; mode=display">[a]_X=\left[\matrix{0 & -a_3 & a_2 \\a_3 & 0 & -a_1 \\-a_2 & a_1 & 0}\right]</script><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>1.基于定义</p><script type="math/tex; mode=display">[a]_X=-[a]_X^T</script><p>2.<strong>消消乐性质</strong>(自己和自己的外积=0)</p><script type="math/tex; mode=display">a^T[a]_X=0^T \\ [a]_Xa=0</script><p>3.叉积</p><script type="math/tex; mode=display">a\crossproduct b=[a]_Xb=-[b]_Xa</script><p>4.【还不会证明】</p><script type="math/tex; mode=display">det([a]_X^T)=(-1)^n det{[a]_X}</script><h3 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h3><h4 id="形式"><a href="#形式" class="headerlink" title="形式"></a>形式</h4><p>沿着三根轴旋转的旋转矩阵依次为</p><script type="math/tex; mode=display">[R]_\theta=\left[\matrix{cos\theta & sin\theta & 0 \\-sin\theta & cos\theta & 0 \\0 & 0 & 1}\right]</script><script type="math/tex; mode=display">[R]_\phi=\left[\matrix{1 & 0 & 0 \\0 & cos\phi & sin\phi \\0 & -sin\phi & cos\phi}\right]</script><script type="math/tex; mode=display">[R]_\Phi=\left[\matrix{-sin\Phi & 0 & cos\Phi \\0 & 1 & 0 \\cos\Phi & 0 & sin\Phi}\right]</script><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><script type="math/tex; mode=display">RR^T=I \\R^TR=I \\|det(R)|=1</script><p>所有旋转矩阵组成的群称为<strong>特殊正交群(special orthogonal group, SO3)</strong></p><h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>以下讨论中标量(scalar)表示：</p><script type="math/tex; mode=display">x</script><p>向量(Vector)表示：</p><script type="math/tex; mode=display">y=[y_1,y_2,...,y_m]^T</script><p>矩阵(Matrix)表示(懒，没有手打)：</p><p><img src="https://s2.loli.net/2022/03/27/U6tOaKjynPDqBWE.png" alt="image-20220327203450843"></p><p>各种求导的表示：</p><p>【待填坑】</p><h2 id="WCS-vs-CCS"><a href="#WCS-vs-CCS" class="headerlink" title="WCS vs. CCS"></a>WCS vs. CCS</h2><p>WCS(World Coordinate System)可以位于任何位置</p><p>CCS(Camera Coordinate System)必须设置在相机光心</p><p><img src="https://s2.loli.net/2022/03/27/j3GQ5i4PUlYoWp9.png" alt="image-20220327204022068"></p><p>变换关系：</p><script type="math/tex; mode=display">p_i^C=Rp_i^W+t</script><p>齐次坐标形式：</p><p><img src="https://s2.loli.net/2022/03/27/TCBovaF3kDuMlRt.png" alt="image-20220327204128088"></p><p><strong>special Euclidean group</strong>(SE3): The group containing all homogeneous transformation matrices.</p><h2 id="Pinhole-camera-model"><a href="#Pinhole-camera-model" class="headerlink" title="Pinhole camera model"></a>Pinhole camera model</h2><p><img src="https://s2.loli.net/2022/03/14/vqywfTEZB49HgKC.png" alt="image-20220314213506296"></p><p><img src="https://s2.loli.net/2022/03/27/WrYIKbByaq9QTFC.png" alt="image-20220327205301847"></p><p>IPCS系中的坐标</p><script type="math/tex; mode=display">\overline{p}=[x_i,y_i,f]^T</script><p>重要关系</p><script type="math/tex; mode=display">\overline{p}=f\widehat{p}^C=\frac{f}{z_i^C}p^C</script><p>其中</p><script type="math/tex; mode=display">\widehat{p}^C=[\frac{x_i^C}{z_i^C},\frac{y_i^C}{z_i^C},1]^T</script><p>是$p^C$的归一化表示(normalized).</p><h2 id="Intrinsic-matrix"><a href="#Intrinsic-matrix" class="headerlink" title="Intrinsic matrix"></a>Intrinsic matrix</h2><p>意义：连接<strong>image plane coordinate system</strong> &amp;&amp; <strong>pixel coordinate system</strong></p><script type="math/tex; mode=display">IPCS(x,y)\leftrightarrow PCS(u,v)</script><p><strong>Lens distortion does not exist in a perspective camera model</strong>.</p><h3 id="变换关系"><a href="#变换关系" class="headerlink" title="变换关系"></a>变换关系</h3><p><img src="https://s2.loli.net/2022/03/27/n4G7zZXCvK26YIp.png" alt="image-20220327210634917"></p><p>引入</p><p>$s_x,s_y$:effective size measured (in pixels per millimeter) in the horizontal and vertical directions, respectively.</p><script type="math/tex; mode=display">f_x=fs_x \\f_y=fs_y \\x_i=f\frac{x_i^C}{z_i^C} \\y_i=f\frac{y_i^C}{z_i^C}</script><p>可得</p><script type="math/tex; mode=display">u_i=u_o+s_x x_i \\v_i=v_o+s_y y_i</script><p>最终表达式</p><p><img src="https://s2.loli.net/2022/03/27/tqWVJy2gCcOu5kU.png" alt="image-20220327212615708"></p><p>或表达为</p><script type="math/tex; mode=display">\widetilde{p}=\frac{1}{z_i^C}Kp^C</script><p>说明：</p><p>1.$\widetilde{p}=[u_i,v_i,1]^T$是$p=[u_i,v_i]^T$的齐次坐标</p><p>2.intrinsic parameters:$u_o,v_o,f,s_x,s_y$</p><p>3.Intrinsic Matrix</p><p><img src="https://s2.loli.net/2022/03/27/DJd1v2ZxYj5CuaE.png" alt="image-20220327213004948"></p>]]></content>
    
    
    <categories>
      
      <category>IPMV courses</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-Ray-Tracing-Path Tracing-L16</title>
    <link href="/2022/03/06/Games101-Ray-Tracing-Path-Tracing-L16/"/>
    <url>/2022/03/06/Games101-Ray-Tracing-Path-Tracing-L16/</url>
    
    <content type="html"><![CDATA[<h1 id="Ray-Tracing-Path-Tracing"><a href="#Ray-Tracing-Path-Tracing" class="headerlink" title="Ray Tracing-Path Tracing"></a>Ray Tracing-Path Tracing</h1><h2 id="Monte-Carlo-Integration"><a href="#Monte-Carlo-Integration" class="headerlink" title="Monte Carlo Integration"></a>Monte Carlo Integration</h2><p><img src="https://s2.loli.net/2022/03/06/GtLEx1YyMX3gwiz.png" alt="image-20220306204532500"></p><p>引入：对难以解析求解的定积分求数值解。</p><p>基本思想：在区域内不断采样，并认为采样值=函数平均值</p><script type="math/tex; mode=display">\int f(X)dx=\frac{1}{N}\sum_{i=1}^N \frac{f(X_i)}{p(X_i)} \space \space X_i \sim p(x_i)</script><p>其中积分域已经在$p(X_i)$中体现。</p><span id="more"></span><h2 id="Path-Tracing"><a href="#Path-Tracing" class="headerlink" title="Path Tracing"></a>Path Tracing</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Whitted-style Ray Tracing 存在很多问题：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">- <span class="hljs-keyword">Always</span> <span class="hljs-keyword">perform</span> specular reflections / refractions <br>- Stop bouncing at diffuse surfaces<br></code></pre></td></tr></table></figure><p>问题1：无法处理glossy reflection</p><p><img src="https://s2.loli.net/2022/03/12/fnD2rUMHGVjYCOe.png" alt="image-20220312152618274"></p><center>The Utah teapot</center><p>问题2：漫反射无反射光</p><p><img src="https://s2.loli.net/2022/03/12/GP81pZEFjWc3MOm.png" alt="image-20220312152920081"></p><center>The Cornell box</center><p>PS:图中箱子内部立方体侧面为红色/绿色的现象称为Color Bleeding(可以理解为墙上的颜色“流血”到箱子上)</p><p>这一经典模型(The Cornell box)被广泛引用于测试全局光照效果。</p><p>但是<strong>Rendering Equation是对的！</strong> </p><script type="math/tex; mode=display">L_O(p,\omega_O)=L_e(p,\omega_O)+\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_O)(n\cdot\omega_i)d\omega_i</script><h3 id="A-Simple-Monte-Carlo-Solution-直接光照情形"><a href="#A-Simple-Monte-Carlo-Solution-直接光照情形" class="headerlink" title="A Simple Monte Carlo Solution(直接光照情形)"></a>A Simple Monte Carlo Solution(直接光照情形)</h3><p><img src="https://s2.loli.net/2022/03/12/2UokeiVdjZa1q9A.png" alt="image-20220312154809839"></p><p>考虑这一场景中特定点P的直接光照(即忽略所有多次反射)。</p><p>渲染方程简化为：</p><script type="math/tex; mode=display">L_O(p,\omega_O)=\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_O)(n\cdot\omega_i)d\omega_i</script><p>几何意义：在半球不同方向上的积分</p><p><img src="https://s2.loli.net/2022/03/12/P7CWK5eiyVwLJA2.png" alt="image-20220312155116645"></p><p>用Monte Carlo积分法写成</p><script type="math/tex; mode=display">L_O(p,\omega_O)=\frac{1}{N} \sum_{i=1}^N \frac{L_i(p,\omega_i)f_r(p,\omega_i,\omega_O)(n\cdot\omega_i)}{p(\omega_i)}</script><p>其中分母上的p表示概率密度函数，其余的p代表点。</p><p>$p(\omega_i)$可以取半球上的均匀分布$p(\omega_i)=\frac{1}{2\pi}$</p><p>算法伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">shade</span>(p, wo) <span class="hljs-comment">//计算p点向wo方向发出的光</span><br>Randomly choose N directions wi~pdf<br>Lo = <span class="hljs-number">0.0</span><br>For each wi<br>Trace a ray <span class="hljs-built_in">r</span>(p, wi)<br>If ray r hit the light<br>Lo += (<span class="hljs-number">1</span> / N) * L_i * f_r * cosine / <span class="hljs-built_in">pdf</span>(wi)<br>Return Lo<br></code></pre></td></tr></table></figure><p>通过递归加入全局光照(Global Illumination)</p><p><img src="https://s2.loli.net/2022/03/12/DPkiCxj6pKnWHdE.png" alt="image-20220312161649732"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">shade</span>(p, wo) <br>Randomly choose N directions wi~pdf<br>Lo = <span class="hljs-number">0.0</span><br>For each wi<br>Trace a ray <span class="hljs-built_in">r</span>(p, wi)<br>If ray r hit the light<br>Lo += (<span class="hljs-number">1</span> / N) * L_i * f_r * cosine / <span class="hljs-built_in">pdf</span>(wi)<br>Else If ray r hit an object at q <span class="hljs-comment">//考虑p点接受的反射光</span><br>Lo += (<span class="hljs-number">1</span> / N) * <span class="hljs-built_in">shade</span>(q, -wi) * f_r * cosine / <span class="hljs-built_in">pdf</span>(wi)<br>Return Lo<br></code></pre></td></tr></table></figure><h4 id="问题1：光线数目指数爆炸"><a href="#问题1：光线数目指数爆炸" class="headerlink" title="问题1：光线数目指数爆炸"></a>问题1：光线数目指数爆炸</h4><p><img src="https://s2.loli.net/2022/03/12/pdmTzuQS5wVfanY.png" alt="image-20220312162107711"></p><p>因此只能保留一根光线：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">shade</span>(p, wo)<br>Randomly choose ONE direction wi~<span class="hljs-built_in">pdf</span>(w)<br><span class="hljs-function">Trace a ray <span class="hljs-title">r</span><span class="hljs-params">(p, wi)</span></span><br><span class="hljs-function">If ray r hit the light</span><br><span class="hljs-function">Return L_i * f_r * cosine / <span class="hljs-title">pdf</span><span class="hljs-params">(wi)</span></span><br><span class="hljs-function">Else If ray r hit an object at q</span><br><span class="hljs-function">Return <span class="hljs-title">shade</span><span class="hljs-params">(q, -wi)</span> * f_r * cosine / <span class="hljs-title">pdf</span><span class="hljs-params">(wi)</span></span><br></code></pre></td></tr></table></figure><p>只保留一根光线，使用Monte Carlo积分的方式称为<strong>Path Tracing</strong>(直观理解；对于每一根光线实际上产生了一条从观察者到物体的路径并进行追踪，即为“路径追踪”)</p><h4 id="问题2：noisy"><a href="#问题2：noisy" class="headerlink" title="问题2：noisy"></a>问题2：noisy</h4><p>解决：对于一个像素计算多条path求平均值</p><p><img src="https://s2.loli.net/2022/03/12/Anh3BTiCReaS6FD.png" alt="image-20220312162457532"></p><p>算法：Ray Generation</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">ray_generation</span>(camPos, pixel)<br>Uniformly choose N sample positions within the pixel<br>pixel_radiance = <span class="hljs-number">0.0</span><br>For each sample in the pixel<br>Shoot a ray <span class="hljs-built_in">r</span>(camPos, cam_to_sample)<br>If ray r hit the scene at p<br>pixel_radiance += <span class="hljs-number">1</span> / N * <span class="hljs-built_in">shade</span>(p, sample_to_cam)<br>Return pixel_radiance<br></code></pre></td></tr></table></figure><h4 id="问题3：递归边界问题"><a href="#问题3：递归边界问题" class="headerlink" title="问题3：递归边界问题"></a>问题3：递归边界问题</h4><p>问题：以上算法中使用递归进行转移，但是没有给出边界条件(即停不下来)</p><p>dilema：自然界中的光反射本就是无数次，但是无法用计算机模拟；如果指定反射次数进行切断，又会带来能量损失（见下方对比图）</p><p><img src="https://s2.loli.net/2022/03/12/bH326ZfsLuSe9kE.png" alt="image-20220312163308511"></p><center>3 bounces</center><p><img src="https://s2.loli.net/2022/03/12/KkOxo9gB2EwHCUn.png" alt="image-20220312163339735"></p><center>17 bounces</center><p>解决方式：俄罗斯轮盘赌(Russian Roulette , RR)</p><p>即生成一个概率值P，对于特定点以概率P向外发射光线，以概率(1-P)不发射光线。</p><p>这样期望值</p><script type="math/tex; mode=display">E = P * (Lo / P) + (1 - P) * 0 = Lo</script><p>仍为$L_o$。</p><p>算法改动：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">shade</span>(p, wo)<br>Manually specify a probability P_RR<br>Randomly select ksi in a uniform dist. in [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br><span class="hljs-built_in">If</span> (ksi &gt; P_RR) <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br><br>Randomly choose ONE direction wi~<span class="hljs-built_in">pdf</span>(w)<br><span class="hljs-function">Trace a ray <span class="hljs-title">r</span><span class="hljs-params">(p, wi)</span></span><br><span class="hljs-function">If ray r hit the light</span><br><span class="hljs-function">Return L_i * f_r * cosine / <span class="hljs-title">pdf</span><span class="hljs-params">(wi)</span> / P_RR</span><br><span class="hljs-function">Else If ray r hit an object at q</span><br><span class="hljs-function">Return <span class="hljs-title">shade</span><span class="hljs-params">(q, -wi)</span> * f_r * cosine / <span class="hljs-title">pdf</span><span class="hljs-params">(wi)</span> / P_RR</span><br></code></pre></td></tr></table></figure><p>至此，已经完成了<strong>正确的Path Tracing</strong></p><h3 id="Efficiency"><a href="#Efficiency" class="headerlink" title="Efficiency"></a>Efficiency</h3><p>目前讨论的Path Tracing效率不高。</p><p><img src="https://s2.loli.net/2022/03/12/h37op68W9LxaCbf.png" alt="image-20220312164914218"></p><p>原因：采样选用半球面上均匀，导致很多光线“浪费”</p><p><img src="https://s2.loli.net/2022/03/12/fOZpeyBmAEuoVGj.png" alt="image-20220312165205732"></p><p>想法：如果采样可以直接在光源上进行，就可以避免光线浪费。但是光源上采样的变量和原先选取的点不同（积分域不同），需要变换，即寻求$d\omega$和$dA$之间的关系。</p><p><img src="https://s2.loli.net/2022/03/12/zn8jZWwqybL1HlP.png" alt="image-20220312170359426"></p><script type="math/tex; mode=display">d\omega = \frac{dA cos\theta'}{||x'-x||^2}</script><p>渲染方程重写为</p><script type="math/tex; mode=display">L_O(p,\omega_O)=\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_O)cos\theta d\omega_i \\=\int_{A}L_i(p,\omega_i)f_r(p,\omega_i,\omega_O)\frac{cos\theta cos\theta'}{||x'-x||^2}dA</script><p>至此积分域变换到光源。可以将一个点接受的Radiance分为两部分:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-number">1.</span> light source <span class="hljs-comment">(direct, no need to have RR)</span> <br><span class="hljs-number">2.</span> other reflectors <span class="hljs-comment">(indirect, RR)</span><br></code></pre></td></tr></table></figure><h3 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">shade</span>(p, wo)<br># Contribution from the light source.<br>Uniformly sample the light at x’ (pdf_light = <span class="hljs-number">1</span> / A)<br>L_dir = L_i * f_r * cos θ * cos θ’ / |x’ - p|^<span class="hljs-number">2</span> / pdf_light <br><br># Contribution from other reflectors.<br>    L_indir = <span class="hljs-number">0.0</span><br>    Test Russian Roulette with probability P_RR<br>    Uniformly sample the hemisphere toward <span class="hljs-built_in">wi</span> (pdf_hemi = <span class="hljs-number">1</span> / <span class="hljs-number">2</span>pi)<br>    Trace a ray <span class="hljs-built_in">r</span>(p, wi)<br>    If ray r hit a non-emitting object at q<br>    L_indir = <span class="hljs-built_in">shade</span>(q, -wi) * f_r * cos θ / pdf_hemi / P_RR<br>    <br>    Return L_dir + L_indir<br></code></pre></td></tr></table></figure><h3 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES:"></a>NOTES:</h3><h4 id="1-在前述进行积分域变换时，需要考虑光源与物体之间是否有遮挡情况"><a href="#1-在前述进行积分域变换时，需要考虑光源与物体之间是否有遮挡情况" class="headerlink" title="1.在前述进行积分域变换时，需要考虑光源与物体之间是否有遮挡情况"></a>1.在前述进行积分域变换时，需要考虑光源与物体之间是否有遮挡情况</h4><p><img src="https://s2.loli.net/2022/03/12/bIdLyCf8rGgZ4MT.png" alt="image-20220312171616075"></p><p>修改代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"># Contribution from the light source.<br>L_dir = <span class="hljs-number">0.0</span><br>Uniformly sample the light at x’ (pdf_light = <span class="hljs-number">1</span> / A)<br>Shoot a ray from p to x’<br>If the ray is <span class="hljs-keyword">not</span> blocked in the middle<br>L_dir = …<br></code></pre></td></tr></table></figure><h4 id="2-Pah-Tracing-难以处理点光源"><a href="#2-Pah-Tracing-难以处理点光源" class="headerlink" title="2.Pah Tracing 难以处理点光源"></a>2.Pah Tracing 难以处理点光源</h4><h4 id="3-Path-Tracing-的正确性"><a href="#3-Path-Tracing-的正确性" class="headerlink" title="3.Path Tracing 的正确性"></a>3.Path Tracing 的正确性</h4><p>可以实现<strong>PHOTO-REALISTIC</strong></p><p><img src="https://s2.loli.net/2022/03/12/kuvM5L4TVQoJOnX.png" alt="image-20220312171945678"></p><h4 id="4-现代光线追踪介绍"><a href="#4-现代光线追踪介绍" class="headerlink" title="4.现代光线追踪介绍"></a>4.现代光线追踪介绍</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs markdown">• Previous <br><span class="hljs-bullet">-</span> Ray tracing == Whitted-style ray tracing<br>• Modern<br><span class="hljs-bullet">    -</span> The general solution of light transport, including<br><span class="hljs-bullet">    -</span> (Unidirectional &amp; bidirectional) path tracing <br><span class="hljs-bullet">    -</span> Photon mapping <br><span class="hljs-bullet">    -</span> Metropolis light transport <br><span class="hljs-bullet">    -</span> VCM / UPBP…<br></code></pre></td></tr></table></figure><h4 id="5-未展开的话题"><a href="#5-未展开的话题" class="headerlink" title="5.未展开的话题"></a>5.未展开的话题</h4><p>(1)关于均匀采样的具体实现？</p><p>(2)对于不同的函数形式，Monte Carlo积分选取什么PDF？（重要性采样理论，importance sampling）</p><p>(3)随机数生成要求(low discrepancy sequences)</p><p>(4)对光源和对指定点采样的结合(multiple imp. sampling)</p><p>(5)像素的颜色就是选取path计算结果的平均吗?(pixel reconstruction filter)</p><p>(6)我们计算出的radiance和颜色直接的关系？(gamma correction, curves, color space)</p><h3 id="Fear-the-science-my-friends"><a href="#Fear-the-science-my-friends" class="headerlink" title="Fear the science, my friends."></a><strong>Fear the science, my friends.</strong></h3>]]></content>
    
    
    <categories>
      
      <category>Games101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graphics</tag>
      
      <tag>Ray Tracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-Ray-Tracing-Radiometry-L15</title>
    <link href="/2022/03/05/Games101-Ray-Tracing-Radiometry-L15/"/>
    <url>/2022/03/05/Games101-Ray-Tracing-Radiometry-L15/</url>
    
    <content type="html"><![CDATA[<h1 id="Ray-Tracing-Basic-radiometry（辐射度量学）"><a href="#Ray-Tracing-Basic-radiometry（辐射度量学）" class="headerlink" title="Ray Tracing -  Basic radiometry（辐射度量学）"></a>Ray Tracing -  Basic radiometry（辐射度量学）</h1><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>辐射度量学可以提供光线的物理参数。包括：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">• Measurement <span class="hljs-keyword">system</span> <span class="hljs-keyword">and</span> units <span class="hljs-keyword">for</span> illumination<br>• <span class="hljs-keyword">Perform</span> lighting calculations <span class="hljs-keyword">in</span> a physically correct manner<br>• <span class="hljs-built_in">New</span> terms: Radiant flux, intensity, irradiance, radiance（无准确中文翻译）<br></code></pre></td></tr></table></figure><h2 id="Basic-Concepts"><a href="#Basic-Concepts" class="headerlink" title="Basic Concepts"></a>Basic Concepts</h2><h3 id="Radiant-energy-（电磁辐射能量）"><a href="#Radiant-energy-（电磁辐射能量）" class="headerlink" title="Radiant energy （电磁辐射能量）"></a>Radiant energy （电磁辐射能量）</h3><p> Radiant energy is the <strong>energy of electromagnetic radiation.</strong> </p><script type="math/tex; mode=display">Q[J(Joule)]</script><p>(Barely used in CG.)</p><h3 id="Radiant-flux-power-（辐射功率）"><a href="#Radiant-flux-power-（辐射功率）" class="headerlink" title="Radiant flux (power) （辐射功率）"></a>Radiant flux (power) （辐射功率）</h3><p>Radiant flux (power) is the <strong>energy</strong> emitted, reflected, transmitted or received, <strong>per unit time.</strong></p><script type="math/tex; mode=display">\phi=\frac{dQ}{dT}[W(Watt)/lm(lumen)]</script><p>其中流明（lumen，符号lm）是光通量的国际单位。</p><p>另可以定义为：<strong>photons flowing through a sensor in unit time</strong>，见下图。</p><p><img src="https://s2.loli.net/2022/03/05/AR3Heb29a5Try7U.png" alt="image-20220211111945007"></p><span id="more"></span><h3 id="Radiant-Intensity"><a href="#Radiant-Intensity" class="headerlink" title="Radiant Intensity"></a>Radiant Intensity</h3><p>The radiant (luminous) intensity is the power per unit <strong>solid angle</strong> emitted by a point light source.</p><p>考虑的是光源在方向上的量度。</p><p><img src="https://s2.loli.net/2022/02/11/Or9AcZjHx8wQ31G.png" alt="image-20220211114908451"></p><p>即：<strong>单位立体角的功率</strong></p><script type="math/tex; mode=display">I(\omega)\equiv\frac{d\phi}{d\omega}</script><script type="math/tex; mode=display">[\frac{W}{sr} or \frac{lm}{sr}=cd=candela]</script><p>（单位的不同取决于是在热学范围内定义还是光学范围内定义）</p><hr><p>【复习：立体角 Solid angle】</p><p><img src="https://s2.loli.net/2022/03/05/1OQkV69FvhHPrt8.png" alt="image-20220211115144683"></p><script type="math/tex; mode=display">\Omega=\frac{A}{r^2}</script><p>Sphere has $4\pi$ steradians.</p><p>单位立体角的计算：</p><p><img src="https://s2.loli.net/2022/03/05/8rhkcvxQpXl9uqJ.png" alt="image-20220211135625265"></p><script type="math/tex; mode=display">dA=(rd\theta)(rsin\theta d\phi)r^2sin\theta d\theta d\phi</script><script type="math/tex; mode=display">\Rightarrow d\omega=\frac{dA}{r^2}=sin\theta d\theta d\phi</script><p>因此可以用单位向量$\omega$去表示一个立体角。</p><p>对于此公式的理解：</p><script type="math/tex; mode=display">1.微分立体角的大小和所处方位\theta有关，因此在极点和赤道处\theta和\phi的变化引起的立体角变化是不同的。 \\2.由上可知，\theta 和 \phi 对于球面面积的划分是不均匀的。</script><p><img src="https://s2.loli.net/2022/03/05/C359iRKLQjyw7Us.png" alt="image-20220211120155931"></p><hr><p>Intensity具有的性质（根据定义）：</p><script type="math/tex; mode=display">\phi= \int_{s^2} I {\rm d}\omega=4\pi I</script><script type="math/tex; mode=display">\Rightarrow I = \frac{\phi}{4\pi}</script><h3 id="Irradiance"><a href="#Irradiance" class="headerlink" title="Irradiance"></a>Irradiance</h3><p><strong>Power per unit area</strong> incident on a surface point.</p><script type="math/tex; mode=display">E(x)\equiv \frac{d\phi(x)}{dA} \\Unit: [\frac{W}{m^2}]/[\frac{lm}{m^2}=lux]</script><p>注意！此处的面积其实指<strong>投影之后的面积</strong>。</p><p>通过irradiance的衰减可以解释点光源的强度呈现平方反比律衰减。</p><p><img src="https://s2.loli.net/2022/03/05/xgqfIyCGWhnAsdV.png" alt="tempsnip"></p><h3 id="Radiance"><a href="#Radiance" class="headerlink" title="Radiance"></a>Radiance</h3><p>Power emitted, reflected, transmitted or received by a surface, <strong>per unit solid angle, per projected unit area</strong>.</p><script type="math/tex; mode=display">L(p,\omega)\equiv\frac{d^2 \Phi(p,\omega)}{d\omega dAcos\theta}</script><script type="math/tex; mode=display">Unit: [\frac{W}{sr \space m^2}][\frac{cd}{m^2}=\frac{lm}{sr\space m^2}=nit]</script><p>要点：功率局限于一个<strong>很小的面</strong>，一个<strong>很小的角度范围</strong></p><p><img src="https://s2.loli.net/2022/03/05/uxzTecoE4l9aWD1.png" alt="image-20220305214440845"></p><p>Radiance分为发出(Incident Radiance)和接受(Exiting Radiance)，实质相同</p><p>与之前概念的对比：</p><p>​    Radiance = <strong>Intensity per projected unit area</strong></p><p>​    Radiance = <strong>Irradiance per solid angle</strong></p><script type="math/tex; mode=display">L(p,\omega)=\frac{dE(p)}{d\omega cos\theta}</script><p>​    <img src="https://s2.loli.net/2022/03/06/KZ59iasXvpV1x8N.png" alt="image-20220306112623404"></p><p>Radiance和Irradiance的区别：<strong>方向性</strong></p><p>​    Irradiance: total power received by area $dA$</p><p>​    Radiance: power received by area $d A$ from “direction” $d \omega$</p><p>​    Irradiance可以理解为来自各个方向Radiance的积分</p><h2 id="Bidirectional-Reflectance-Distribution-Function-BRDF，双向反射分布函数"><a href="#Bidirectional-Reflectance-Distribution-Function-BRDF，双向反射分布函数" class="headerlink" title="Bidirectional Reflectance Distribution Function (BRDF，双向反射分布函数)"></a>Bidirectional Reflectance Distribution Function (BRDF，双向反射分布函数)</h2><p>BRDF告诉我们从某个方向来的光线如何反射到另一方向去（即各个方向的能量分布）</p><p><strong>Definition</strong>: Represents how much light is reflected into each outgoing direction from each incoming direction </p><p><img src="https://s2.loli.net/2022/03/05/JZNq37PS2gtHAIX.png" alt="image-20220305220700635"></p><script type="math/tex; mode=display">f_r(\omega_i\rightarrow\omega_r)=\frac{dL_r(\omega_r)}{dE_i(\omega_i)}=\frac{dL_r(\omega_r)}{L_i(\omega_i)cos\theta d\omega_i}[\frac{1}{sr}]</script><p>通过BRDF可以定义<strong>不同的材质</strong></p><h4 id="Reflection-Equation"><a href="#Reflection-Equation" class="headerlink" title="Reflection Equation"></a>Reflection Equation</h4><p><img src="https://s2.loli.net/2022/03/05/uAE9bJ3LO2prPmz.png" alt="image-20220305221540887"></p><script type="math/tex; mode=display">L_r(p,\omega_r)=\int_{H^2}f_r(p,\omega_i\rightarrow\omega_r)L_i(p,\omega_i)cos\theta_id\omega_i</script><p>解释：计算一个出射方向的Radiance，需要对所有入射方向的Radiance计算BRDF然后求和。</p><h4 id="Challenge：Recursive-Equation"><a href="#Challenge：Recursive-Equation" class="headerlink" title="Challenge：Recursive Equation"></a>Challenge：Recursive Equation</h4><p>​    Reflected radiance depends on incoming radiance, But incoming radiance depends on reflected radiance (at </p><p>another point in the scene).</p><p>​    即：由于光线在场景中反复弹射，会形成递归效应。</p><h4 id="Rendering-Equation"><a href="#Rendering-Equation" class="headerlink" title="Rendering Equation"></a>Rendering Equation</h4><p><img src="https://s2.loli.net/2022/03/06/Z5AjL9UEBN6ogwr.png" alt="image-20220306103302254"></p><script type="math/tex; mode=display">L_O(p,\omega_O)=L_e(p,\omega_O)+\int_{\Omega^+}L_i(p,\omega_i)f_r(p,\omega_i,\omega_O)(n\cdot\omega_i)d\omega_i</script><p>式子中假设所有向量都朝向外。</p><p>解释：某一点的光 = 自己辐射出的 + 其他地方反射过来的</p><p>地位：现代图形学（表面上的光线反射及传播）的基础</p><h5 id="方程简化及理解"><a href="#方程简化及理解" class="headerlink" title="方程简化及理解"></a>方程简化及理解</h5><p>经过很多的简化步骤最后可以得到（简化的具体过程尚不清楚）</p><script type="math/tex; mode=display">L=E+KL</script><p>形成了矩阵乘积（算子）的形式。</p><p>目的：利用矩阵求逆类似Taylor展开的性质得到：</p><script type="math/tex; mode=display">L=E+KE+K^2E+K^3E+...</script><p>右侧依次代表直接照射、弹射一次、弹射两次、…的光照效果。</p><h5 id="效果示意"><a href="#效果示意" class="headerlink" title="效果示意"></a>效果示意</h5><p><img src="https://s2.loli.net/2022/03/06/QxH35LcFPGgByZq.png" alt="image-20220306104450782"></p><p><img src="https://s2.loli.net/2022/03/06/iAm6pdWyvPtrxMz.png" alt="image-20220306111623993"></p><p><img src="https://s2.loli.net/2022/03/06/5ABmtyXKVMv1P8F.png" alt="image-20220306104518766"></p><h6 id="1-相较于2次反射，为什么4次反射时图片上方的灯突然变亮了？"><a href="#1-相较于2次反射，为什么4次反射时图片上方的灯突然变亮了？" class="headerlink" title="1.相较于2次反射，为什么4次反射时图片上方的灯突然变亮了？"></a>1.相较于2次反射，为什么4次反射时图片上方的灯突然变亮了？</h6><p>-有的物体需要光线在其中至少弹射若干次才能出来，如玻璃球至少弹射两次，此处的灯也是同理。</p><h6 id="2-如果反射次数可以到达-infty-，最后亮度会收敛还是发散？"><a href="#2-如果反射次数可以到达-infty-，最后亮度会收敛还是发散？" class="headerlink" title="2.如果反射次数可以到达$\infty$，最后亮度会收敛还是发散？"></a>2.如果反射次数可以到达$\infty$，最后亮度会收敛还是发散？</h6><p>-收敛。可从自然界和能量守恒的角度理解（自然界恒全局光照）</p><p>-但是如果考虑相机一直按住快门不放的情况，其亮度确实会不断增加而不收敛（这也印证了Radiometry中主要考虑单位时间内能量的想法是正确的）</p><h2 id="概率论回顾"><a href="#概率论回顾" class="headerlink" title="概率论回顾"></a>概率论回顾</h2><p>连续情况下：概率密度函数 Probability Distribution Function (PDF)</p><script type="math/tex; mode=display">Conditions\space on\space p(x):\space p(x)\geq0\space and \int p(x)dx=1 \\Expected\space value\space of\space x:E[X]=\int xp(x)dx \\Expected\space value\space of\space a\space function\space of\space a\space random\space variable: E[Y]=E[f(X)]=\int f(x)p(x)dx</script><hr>]]></content>
    
    
    <categories>
      
      <category>Games101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graphics</tag>
      
      <tag>Ray Tracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-Ray Tracing (Acceleration) -L14</title>
    <link href="/2022/03/02/Games101-Ray-Tracing-Acceleration-L14/"/>
    <url>/2022/03/02/Games101-Ray-Tracing-Acceleration-L14/</url>
    
    <content type="html"><![CDATA[<h1 id="Ray-Tracing-Acceleration"><a href="#Ray-Tracing-Acceleration" class="headerlink" title="Ray Tracing - Acceleration"></a>Ray Tracing - Acceleration</h1><h2 id="1-Uniform-Spatial-Partitions-Grids"><a href="#1-Uniform-Spatial-Partitions-Grids" class="headerlink" title="1.Uniform Spatial Partitions (Grids)"></a>1.Uniform Spatial Partitions (Grids)</h2><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ldif"><span class="hljs-attribute">Assumptions</span>:<br><span class="hljs-literal">-</span> 判断光线是否与物体相交是耗时的<br><span class="hljs-literal">-</span> 判断光线是否与bounding box相交是容易的<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/02/10/GyDajLnXSZsv9bu.png" alt="image-20220208214130374"></p><span id="more"></span><p>预处理结束后，求出光线穿过的每个盒子，判断盒子里是否有物体，如果有，则判断光线是否与物体相交，这样避免了和空间中所有物体计算是否相交。</p><p><img src="https://s2.loli.net/2022/03/02/HmiSj6QDGrZY1JF.png" alt="image-20220208214151307"></p><p>加速结构基本思想：多做光线和盒子求交，避免做光线和物体求交。</p><p>缺陷：仍需要计算所有光线走过的格子。</p><h2 id="2-Spatial-Partitions（空间划分）"><a href="#2-Spatial-Partitions（空间划分）" class="headerlink" title="2.Spatial Partitions（空间划分）"></a>2.Spatial Partitions（空间划分）</h2><p>基本想法：改进（1.）中的格子划分方式，对于空旷的地方少用一些格子（即格子设置更大），密集的地方多用一些格子（即格子设置更小），有利于处理下面这一经典案例（图中存在着大量空旷区域，用统一的格子划分方式会比较慢）</p><p><img src="https://s2.loli.net/2022/03/02/gsf8yZhT9rGzIAn.png" alt="image-20220211220424258"></p><center>San Miguel Scene(经典场景), 10.7M triangles</center><p>Examples：（<strong>重点：KD-Tree</strong>）</p><p><img src="https://s2.loli.net/2022/03/02/nRlI72OBU4ijeEc.png" alt="image-20220208222552071"></p><p><strong>场景的加速结构预处理要在光线追踪计算之前做完！</strong></p><p><img src="https://s2.loli.net/2022/03/02/lxs6AYJPXfOc2ST.png" alt="image-20220209164215429"></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livescript">执行流程：<br>对当前节点采用某种划分方式(x<span class="hljs-string">\y\z),得到两个子节点，然后对于子节点继续划分。</span><br>实际的物体<span class="hljs-string">\三角形只存放在叶子节点上</span><br></code></pre></td></tr></table></figure><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dos">问题：<br><span class="hljs-number">1</span>.一个物体可能出现在多个叶子节点中<br><span class="hljs-number">2</span>.KD-<span class="hljs-built_in">Tree</span>的建立需要考虑三角和盒子的求交（复杂）<br></code></pre></td></tr></table></figure><h2 id="3-Bounding-Volume-Hierarchy-BVH"><a href="#3-Bounding-Volume-Hierarchy-BVH" class="headerlink" title="3.Bounding Volume Hierarchy (BVH)"></a>3.Bounding Volume Hierarchy (BVH)</h2><p>属于Object Partitions（物体划分），应用广泛！</p><p><img src="https://s2.loli.net/2022/03/02/1J4kYbLnmyDjZ3w.png" alt="image-20220210221401987"></p><h3 id="3-1-基本流程"><a href="#3-1-基本流程" class="headerlink" title="3.1 基本流程"></a>3.1 基本流程</h3><p>BVH对物体进行划分，每次划分为两堆，然后分别求出bounding box，继续划分，再次重新计算bounding box，重复以上过程，划分方式可以竖直\水平等不做限制（如依次选择X轴，Y轴，Z轴），最终使得每个叶子节点中三角形数量较少，空间中物体的划分尽量均匀。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-symbol">Summary:</span> <span class="hljs-keyword">Building </span><span class="hljs-keyword">BVHs</span><br><span class="hljs-keyword"></span>• Find <span class="hljs-keyword">bounding </span><span class="hljs-keyword">box </span><br>找到当前节点物体的包围盒<br>• Recursively split set of objects in two <span class="hljs-keyword">subsets </span><br>递归地将当前物体分为两堆<br>• Recompute the <span class="hljs-keyword">bounding </span><span class="hljs-keyword">box </span>of the <span class="hljs-keyword">subsets </span><br>重新计算两堆物体的包围盒<br>• Stop when necessary <br>适合的时候停止（每个叶子节点中三角形数量较少，空间中物体的划分尽量均匀）<br>• Store objects in each leaf node<br>物体存储在叶子节点中<br></code></pre></td></tr></table></figure><h3 id="3-2-性能分析"><a href="#3-2-性能分析" class="headerlink" title="3.2 性能分析"></a>3.2 性能分析</h3><p>相较于KD-Tree的优势：<strong>每一个物体一定严格属于一个节点</strong>。因此省去了三角形和bounding box求交的问题。</p><p>存在的问题：并没有严格将空间”划分开“，即bounding box可能相交。因此在”划分”方面比较讲究。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Heuristics <span class="hljs-keyword">of</span> subdivision<br>Choose <span class="hljs-keyword">a</span> dimension <span class="hljs-built_in">to</span> <span class="hljs-built_in">split</span> <br>• Heuristic <span class="hljs-comment">#1: Always choose the longest axis in node </span><br>• Heuristic <span class="hljs-comment">#2: Split node at location of median object</span><br>即选定最长轴划分，划分界限为排序后位于中位的物体。<br></code></pre></td></tr></table></figure><hr><p>【补充：快速选择算法】</p><p>问题：对于n个无序数组成的序列，找出其中第i大的数。<br>时间复杂度：O(n)</p><hr><p>BVH中用这一算法实现对于大小居中物体的查找。</p><h3 id="3-3-存储结构"><a href="#3-3-存储结构" class="headerlink" title="3.3 存储结构"></a>3.3 存储结构</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">Data Structure for <span class="hljs-keyword">BVHs</span><br><span class="hljs-keyword"></span>[Internal nodes store]<br>• <span class="hljs-keyword">Bounding </span><span class="hljs-keyword">box </span><br>• Children: pointers to child nodes <br>[Leaf nodes store]<br>• <span class="hljs-keyword">Bounding </span><span class="hljs-keyword">box </span><br>• List of objects<br></code></pre></td></tr></table></figure><h3 id="3-4-伪代码"><a href="#3-4-伪代码" class="headerlink" title="3.4 伪代码"></a>3.4 伪代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">Intersect</span>(Ray ray, BVH node) <br>&#123;<br><span class="hljs-keyword">if</span> (ray misses node.bbox) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//若光线与bounding box不相交，结束</span><br><span class="hljs-comment">//若相交，分为是否是叶子节点</span><br> <span class="hljs-keyword">if</span> (node is a leaf node)<br> &#123;<br> test intersection with all objs;<br> <span class="hljs-keyword">return</span> closest intersection;<br> &#125; <span class="hljs-comment">//叶子节点，判断节点内部所有物体，返回最近的交点</span><br> hit1 = <span class="hljs-built_in">Intersect</span>(ray, node.child1);<br> hit2 = <span class="hljs-built_in">Intersect</span>(ray, node.child2);<br>    <span class="hljs-comment">//若节点不是叶子节点，返回两个子节点交点的最近值</span><br> <span class="hljs-keyword">return</span> the closer of hit1, hit2;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-加速结构的比较：Spatial-vs-Object-Partitions"><a href="#4-加速结构的比较：Spatial-vs-Object-Partitions" class="headerlink" title="4.加速结构的比较：Spatial vs Object Partitions"></a>4.加速结构的比较：Spatial vs Object Partitions</h2><h3 id="4-1-Spatial-partition-e-g-KD-tree"><a href="#4-1-Spatial-partition-e-g-KD-tree" class="headerlink" title="4.1 Spatial partition (e.g.KD-tree)"></a>4.1 Spatial partition (e.g.KD-tree)</h3><p><img src="https://s2.loli.net/2022/03/02/CFfDekQnwgAYahp.png" alt="image-20220210225343386"></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">• <span class="hljs-keyword">Partition</span> space <span class="hljs-keyword">into</span> non-overlapping regions <br>空间划分，划分的节点之间不重叠<br>• An <span class="hljs-keyword">object</span> can be contained <span class="hljs-keyword">in</span> multiple regions<br>缺点：一个物体可能被划分到多个区域中<br></code></pre></td></tr></table></figure><h3 id="4-2-Object-partition-e-g-BVH"><a href="#4-2-Object-partition-e-g-BVH" class="headerlink" title="4.2 Object partition (e.g. BVH)"></a>4.2 Object partition (e.g. BVH)</h3><p><img src="https://s2.loli.net/2022/03/02/Hno1iDxwtUMRY85.png" alt="image-20220210225528898"></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">• Partition <span class="hljs-built_in">set</span> <span class="hljs-keyword">of</span> objects <span class="hljs-keyword">into</span> disjoint subsets <br>优点：物体划分到不相交的子集，不会出现同一个物体被划分到不同的节点<br>• Bounding boxes <span class="hljs-keyword">for</span> <span class="hljs-keyword">each</span> <span class="hljs-built_in">set</span> may overlap <span class="hljs-keyword">in</span> <span class="hljs-literal">space</span><br>缺点：不同节点所占空间可能重叠<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Games101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graphics</tag>
      
      <tag>Ray Tracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-Ray Tracing (Introduction) -L13</title>
    <link href="/2022/03/02/Games101-Ray-Tracing-Introduction-L13/"/>
    <url>/2022/03/02/Games101-Ray-Tracing-Introduction-L13/</url>
    
    <content type="html"><![CDATA[<h1 id="Ray-Tracing-Introduction-（L13"><a href="#Ray-Tracing-Introduction-（L13" class="headerlink" title="Ray Tracing - Introduction （L13)"></a>Ray Tracing - Introduction （L13)</h1><h2 id="0-Introduction"><a href="#0-Introduction" class="headerlink" title="0.Introduction"></a>0.Introduction</h2><h3 id="0-1-光栅化无法处理的问题"><a href="#0-1-光栅化无法处理的问题" class="headerlink" title="0.1 光栅化无法处理的问题"></a>0.1 光栅化无法处理的问题</h3><p>Rasterization couldn’t handle <strong>global effects</strong> well.</p><p><img src="https://cdn.jsdelivr.net/gh/thunderbolt215/imagehosting@main/data/1.18x6t15o01uo.webp" alt="1"></p><center>1.Soft Shadows（软阴影）</center><p><img src="https://s2.loli.net/2022/02/10/cm4RWXGL9xKhbVC.png" alt="image-20220207102616490"></p><center> 2.light bounces more than once（多次反射）</center><span id="more"></span><h3 id="0-2-Rasterization-vs-Ray-Tracing"><a href="#0-2-Rasterization-vs-Ray-Tracing" class="headerlink" title="0.2 Rasterization vs. Ray Tracing"></a>0.2 Rasterization vs. Ray Tracing</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Rasterization<br>-fast, <span class="hljs-keyword">but</span> low-quality<br>-<span class="hljs-built_in">real</span>-<span class="hljs-built_in">time</span><br><br>Ray Tracing<br>-accurate, <span class="hljs-keyword">but</span> very slow<br>-offline<br>-~<span class="hljs-number">10</span>K CPU core hours <span class="hljs-keyword">to</span> render one frame <span class="hljs-keyword">in</span> production<br></code></pre></td></tr></table></figure><p>质量和时间为“Trade-off”</p><h2 id="1-Recursive-Whitted-Style-Ray-Tracing"><a href="#1-Recursive-Whitted-Style-Ray-Tracing" class="headerlink" title="1.Recursive (Whitted-Style) Ray Tracing"></a>1.Recursive (Whitted-Style) Ray Tracing</h2><h3 id="1-1-Light-Rays"><a href="#1-1-Light-Rays" class="headerlink" title="1.1 Light Rays"></a>1.1 Light Rays</h3><p>基本假设： 直线传播；不发生碰撞；<strong>光路可逆</strong></p><p>（将物体发射到观察者的光线等效成由观察者发向物体一道“感知光线”，光路仍成立，这也是光线<strong>“追踪“</strong>的命名由来）</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-number">1.</span> Light travels <span class="hljs-keyword">in</span> straight lines (though this <span class="hljs-keyword">is</span> wrong) <br><span class="hljs-number">2.</span> Light rays <span class="hljs-keyword">do</span> <span class="hljs-keyword">not</span> “collide” <span class="hljs-keyword">with</span> <span class="hljs-keyword">each</span> other <span class="hljs-keyword">if</span> they <span class="hljs-keyword">cross</span> (though this <span class="hljs-keyword">is</span> still wrong) <br><span class="hljs-number">3.</span> Light rays travel <span class="hljs-keyword">from</span> the light sources <span class="hljs-keyword">to</span> the eye (but the physics <span class="hljs-keyword">is</span> invariant under <span class="hljs-type">path</span> reversal - reciprocity[可逆性]).<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/02/jnWSJ2Hy4blI7kq.png" alt="image-20220211191805453"></p><center>Eyes send out feeling rays to the world</center><h3 id="1-2-Ray-Casting-光线投射：生成不同的光线"><a href="#1-2-Ray-Casting-光线投射：生成不同的光线" class="headerlink" title="1.2  Ray Casting(光线投射：生成不同的光线)"></a>1.2  Ray Casting(光线投射：生成不同的光线)</h3><h4 id="1-2-1-概述"><a href="#1-2-1-概述" class="headerlink" title="1.2.1 概述"></a>1.2.1 概述</h4><p><img src="https://s2.loli.net/2022/03/02/naDQ7JRlkxjXKe2.png" alt="image-20220211193001892"></p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">基本流程：<br><span class="hljs-number">1.</span> Generate <span class="hljs-keyword">an</span> image <span class="hljs-keyword">by</span> casting <span class="hljs-literal">one</span> ray per pixel <br><span class="hljs-number">2.</span> Check <span class="hljs-keyword">for</span> shadows <span class="hljs-keyword">by</span> sending <span class="hljs-keyword">a</span> ray <span class="hljs-built_in">to</span> <span class="hljs-keyword">the</span> light<br></code></pre></td></tr></table></figure><h4 id="1-2-2-An-Example："><a href="#1-2-2-An-Example：" class="headerlink" title="1.2 2 An Example："></a>1.2 2 An Example：</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">Assumptions</span><br><span class="hljs-number">1.</span>光源为点光源，眼睛为针孔摄像机（即忽略光源和相机的大小和尺寸）<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/02/Vj4cNBLhFGZWXeu.png" alt="image-20220211193740056"></p><center>Step 1</center><p><img src="https://s2.loli.net/2022/03/02/NQ2M7ge1rHYVB6u.png" alt="image-20220211193754261"></p><center>Step 2</center><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">基本步骤：<br><span class="hljs-number">1</span>.对于每个像素，与眼睛连线形成Ray，计算这条光线照亮的场景中最近的点<br><span class="hljs-number">2</span>.该点与光源连线<span class="hljs-selector-attr">[这条连线叫做Shadow Ray]</span>，判定是否被照亮以及计算颜色<br><span class="hljs-number">3</span>.将计算结果写回原像素<br></code></pre></td></tr></table></figure><h4 id="1-2-3-Recursive-Ray-Casting-Whitted-Style-概述"><a href="#1-2-3-Recursive-Ray-Casting-Whitted-Style-概述" class="headerlink" title="1.2.3 Recursive Ray Casting(Whitted-Style) 概述"></a>1.2.3 Recursive Ray Casting(Whitted-Style) 概述</h4><p><img src="https://s2.loli.net/2022/03/02/56F3LJ2yVGI1fZH.png" alt="image-20220211195529474"></p><p>模拟光线不断弹射的过程，<strong>将多次反射和折射的结果都加入到该点的像素值上</strong>。</p><p><strong>注意</strong>：多次反射和折射当然要考虑能量衰减。</p><p><img src="https://s2.loli.net/2022/03/02/d24Lyag1HJCf9Bo.png" alt="image-20220211195825708"></p><center>效果图</center><h3 id="1-3-Ray-surface-Intersection"><a href="#1-3-Ray-surface-Intersection" class="headerlink" title="1.3 Ray-surface Intersection"></a>1.3 Ray-surface Intersection</h3><h4 id="1-3-1-Ray-Equation"><a href="#1-3-1-Ray-Equation" class="headerlink" title="1.3.1 Ray Equation"></a>1.3.1 Ray Equation</h4><p>Ray is defined by its <strong>origin</strong> and a <strong>direction vector</strong>.</p><script type="math/tex; mode=display">\vec{r}(t)=\vec{o}+t\vec{d}(0\leq t<\infty)</script><p><strong>ATTENTION：图形学中一般不纠结边界条件（如t&gt;0还是t&gt;=0）</strong></p><p> <strong>Example: Ray Intersection With Sphere</strong></p><p><img src="https://s2.loli.net/2022/02/11/ZU5Q9JoA6NVIuht.png" alt="image-20220211212028153"></p><script type="math/tex; mode=display">Ray:\vec{r}(t)=\vec{o}+t\vec{d}(0\leq t<\infty) \\Sphere:(\vec{p}-\vec{c})^2-R^2=0 \\Solve\space for\space intersection:(\vec{o}+t\vec{d}-\vec{c})^2-R^2=0</script><p>最后可以化为二次方程进行求解，注意根据光线与球面的位置关系分类讨论。</p><p><img src="https://s2.loli.net/2022/03/02/6YLoH19dVSg5NrE.png" alt="image-20220211212559675"></p><h4 id="1-3-2-For-implicit-surface"><a href="#1-3-2-For-implicit-surface" class="headerlink" title="1.3.2 For implicit surface"></a>1.3.2 <strong>For implicit surface</strong></h4><script type="math/tex; mode=display">General\space implicit\space surface:f(\vec{p})=0 \\Substitute\space ray\space equation:f(\vec{o}+t\vec{d})=0 \\[Solve\space for\space positive\space roots.]</script><p><img src="https://s2.loli.net/2022/02/11/oH25ahMSsBVdGXz.png" alt="image-20220211213140679"></p><center>Examples of implicit surfaces</center><h4 id="1-3-3-For-Triangle-Mesh-Explicit-surfaces"><a href="#1-3-3-For-Triangle-Mesh-Explicit-surfaces" class="headerlink" title="1.3.3 For  Triangle Mesh(Explicit surfaces)"></a>1.3.3 For  Triangle Mesh(Explicit surfaces)</h4><p>(作为显式表示的最重要代表，选用三角形面)</p><hr><p><strong>[Point in polygon Test]</strong></p><p>检查一点是否在多边形之内，可作一射线从该点开始往任意方向投射，如果射线与多边形边的交点个数为奇数，则该点位于多边形内部。</p><p><img src="https://s2.loli.net/2022/03/02/4esKFxDCm6BQNn5.png" alt="img"></p><hr><p>但是直接按此方法判定光线和三角形面的位置关系计算量过大。</p><p>改进：问题转化为<strong>求出光线和三角形所在平面的交点，再判断交点是否在三角形内部</strong>。</p><p><img src="https://s2.loli.net/2022/03/02/tHLlbFUOyMpPm2f.png" alt="image-20220207193014512"></p><center>示意</center><p>定义平面：<strong>法线</strong>+<strong>平面上任意一点P’</strong></p><p><img src="https://s2.loli.net/2022/03/02/fHhBOosKaiNEkpA.png" alt="image-20220207194031126"></p><script type="math/tex; mode=display">Plane\space Equation:(\vec{p}-\vec{p'})\cdot \vec{N}=0 \\可以写成\space ax+by+cz+d=0</script><p>至此已经可以解出光线与平面的交点，再判定是否在三角形内部。</p><p>改进：（可以直接解出光线和三角形的交点，并验证其解的合理性）</p><p><img src="https://s2.loli.net/2022/02/10/47ngwolWMQjtZxS.png" alt="image-20220207200051961"></p><center>重心坐标均非负，则交点在三角形内</center><h3 id="1-4-Accelerating-Ray-Surface-Intersection"><a href="#1-4-Accelerating-Ray-Surface-Intersection" class="headerlink" title="1.4 Accelerating Ray-Surface Intersection"></a>1.4 Accelerating Ray-Surface Intersection</h3><p>在像素数过多、光线弹射情况复杂时，上述方法效率过低。</p><p><img src="https://s2.loli.net/2022/03/02/gsf8yZhT9rGzIAn.png" alt="image-20220211220424258"></p><center>San Miguel Scene(经典场景), 10.7M triangles</center><h5 id="1-4-1-Bounding-Volumes"><a href="#1-4-1-Bounding-Volumes" class="headerlink" title="1.4.1 Bounding Volumes"></a>1.4.1 Bounding Volumes</h5><p>引入”包围盒“Bounding Volumes，即<strong>光线如果不会碰到Bounding Volumes，则它一定不会碰到物体</strong>。</p><p><img src="https://s2.loli.net/2022/03/02/ezKqXG8gYIDV2R3.png" alt="image-20220207202144038"></p><p>对于Bounding Volumes的进一步定义：<strong>Bounding Box is the intersection of 3 pairs of slabs</strong></p><p>即：<strong>包围盒是三组平面的交集</strong>。</p><p>常用包围盒：<strong>Axis-Aligned Bounding Box(AABB，轴对齐包围盒)</strong></p><p><img src="https://s2.loli.net/2022/02/11/3tIAwFzyGkCJpBv.png" alt="image-20220211220932624"></p><h5 id="1-4-2-Ray-Intersection-with-AABB"><a href="#1-4-2-Ray-Intersection-with-AABB" class="headerlink" title="1.4.2 Ray Intersection with AABB"></a>1.4.2 Ray Intersection with AABB</h5><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">KEY ideas<br>The ray enters <span class="hljs-keyword">the</span> box only when <span class="hljs-keyword">it</span> enters all pairs <span class="hljs-keyword">of</span> slabs <br>The ray exits <span class="hljs-keyword">the</span> box <span class="hljs-keyword">as</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">it</span> exits <span class="hljs-keyword">any</span> pair <span class="hljs-keyword">of</span> slabs<br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/02/7ThdrcLwoyNjGaC.png" alt="image-20220211223237789"></p><p>即：进入任何一对平面即认为进入box，离开所有平面才认为离开box。</p><p>因此对于每一对平面计算$t_{min}$和$t_{max}$，求出进入时间和离开时间：</p><script type="math/tex; mode=display">For\space 3D\space box, \\ t_{enter}=max\{t_{min}\} \\t_{exit}=min\{t_{max}\} \\</script><p>再考虑由于光线实际为射线带来的正负号问题。</p><script type="math/tex; mode=display">若t_{exit}<0,\space则box在光线后方\Rightarrow无交点 \\若t_{exit}\geq0,t_{enter}<0,\space则光线起点位于box内部\Rightarrow有交点</script><p>综上，得到结论：</p><script type="math/tex; mode=display">Ray\space and\space AABB\space intersect\space iff (if\space and\space only\space if) \\t_{enter}<t_{exit} \\t_{exit}\geq0</script><h5 id="1-4-3-Why-Axis-Aligned"><a href="#1-4-3-Why-Axis-Aligned" class="headerlink" title="1.4.3 Why Axis-Aligned?"></a>1.4.3 Why Axis-Aligned?</h5><p>因为计算更方便。</p><p><img src="https://s2.loli.net/2022/03/02/oYpn68VjlRMWdxb.png" alt="image-20220207212226703"></p>]]></content>
    
    
    <categories>
      
      <category>Games101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graphics</tag>
      
      <tag>Ray Tracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Games101-hw6</title>
    <link href="/2022/03/02/Games101-hw6/"/>
    <url>/2022/03/02/Games101-hw6/</url>
    
    <content type="html"><![CDATA[<h1 id="Assignment-6"><a href="#Assignment-6" class="headerlink" title="Assignment 6"></a>Assignment 6</h1><h2 id="1-Basic"><a href="#1-Basic" class="headerlink" title="1. Basic"></a>1. Basic</h2><h3 id="1-1-Render-in-Renderer-cpp"><a href="#1-1-Render-in-Renderer-cpp" class="headerlink" title="1.1 Render() in Renderer.cpp"></a>1.1 <strong>Render()</strong> in Renderer.cpp</h3><p>这一部分直接按照作业5即可，在使用castRay函数时需要进行改动。</p><p>注意：记得对dir向量归一化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Renderer::Render</span><span class="hljs-params">(<span class="hljs-type">const</span> Scene&amp; scene)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::vector&lt;Vector3f&gt; <span class="hljs-title">framebuffer</span><span class="hljs-params">(scene.width * scene.height)</span></span>;<br><br>    <span class="hljs-type">float</span> scale = <span class="hljs-built_in">tan</span>(<span class="hljs-built_in">deg2rad</span>(scene.fov * <span class="hljs-number">0.5</span>));<br>    <span class="hljs-type">float</span> imageAspectRatio = scene.width / (<span class="hljs-type">float</span>)scene.height;<br>    <span class="hljs-function">Vector3f <span class="hljs-title">eye_pos</span><span class="hljs-params">(<span class="hljs-number">-1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-type">int</span> m = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> j = <span class="hljs-number">0</span>; j &lt; scene.height; ++j) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">uint32_t</span> i = <span class="hljs-number">0</span>; i &lt; scene.width; ++i) &#123;<br>            <span class="hljs-comment">// generate primary ray direction</span><br>            <span class="hljs-type">float</span> x = (<span class="hljs-number">2</span> * (i + <span class="hljs-number">0.5</span>) / (<span class="hljs-type">float</span>)scene.width - <span class="hljs-number">1</span>) *<br>                      imageAspectRatio * scale;<br>            <span class="hljs-type">float</span> y = (<span class="hljs-number">1</span> - <span class="hljs-number">2</span> * (j + <span class="hljs-number">0.5</span>) / (<span class="hljs-type">float</span>)scene.height) * scale;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Find the x and y positions of the current pixel to get the</span><br>            <span class="hljs-comment">// direction</span><br>            <span class="hljs-comment">//  vector that passes through it.</span><br>            <span class="hljs-comment">// Also, don&#x27;t forget to multiply both of them with the variable</span><br>            <span class="hljs-comment">// *scale*, and x (horizontal) variable with the *imageAspectRatio*</span><br>            <span class="hljs-comment">// x = (2 * (i + 0.5f) / (float)(scene.width-1) - 1) * imageAspectRatio * scale;</span><br>            <span class="hljs-comment">// y = (1 - 2 * (j + 0.5f) / (float)(scene.height-1)) * scale;</span><br><br>            <span class="hljs-comment">/*作业6添加部分*/</span><br>            Vector3f dir = <span class="hljs-built_in">Vector3f</span>(x, y, <span class="hljs-number">-1</span>); <span class="hljs-comment">// Don&#x27;t forget to normalize this direction!</span><br>            <span class="hljs-function">Ray <span class="hljs-title">ray</span><span class="hljs-params">(eye_pos, normalize(dir))</span></span>;<br>            framebuffer[m++] = scene.<span class="hljs-built_in">castRay</span>(ray, <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">/*作业6添加部分*/</span>          <br><br>            <span class="hljs-comment">// Don&#x27;t forget to normalize this direction!</span><br><br>        &#125;<br>        <span class="hljs-built_in">UpdateProgress</span>(j / (<span class="hljs-type">float</span>)scene.height);<br>    &#125;<br>    <span class="hljs-built_in">UpdateProgress</span>(<span class="hljs-number">1.f</span>);<br><br>    <span class="hljs-comment">// save framebuffer to file</span><br>    FILE* fp = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;binary.ppm&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>);<br>    (<span class="hljs-type">void</span>)<span class="hljs-built_in">fprintf</span>(fp, <span class="hljs-string">&quot;P6\n%d %d\n255\n&quot;</span>, scene.width, scene.height);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = <span class="hljs-number">0</span>; i &lt; scene.height * scene.width; ++i) &#123;<br>        <span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> color[<span class="hljs-number">3</span>];<br>        color[<span class="hljs-number">0</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)(<span class="hljs-number">255</span> * <span class="hljs-built_in">clamp</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, framebuffer[i].x));<br>        color[<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)(<span class="hljs-number">255</span> * <span class="hljs-built_in">clamp</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, framebuffer[i].y));<br>        color[<span class="hljs-number">2</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>)(<span class="hljs-number">255</span> * <span class="hljs-built_in">clamp</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, framebuffer[i].z));<br>        <span class="hljs-built_in">fwrite</span>(color, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, fp);<br>    &#125;<br>    <span class="hljs-built_in">fclose</span>(fp);    <br>&#125;<br></code></pre></td></tr></table></figure><span id="more"></span><h3 id="1-2-Triangle-getIntersection-in-Triangle-hpp"><a href="#1-2-Triangle-getIntersection-in-Triangle-hpp" class="headerlink" title="1.2 Triangle::getIntersection in Triangle.hpp"></a>1.2 <strong>Triangle::getIntersection</strong> in Triangle.hpp</h3><p>这一部分出错较多。首先需要阅读一下框架中的计算，将其中参与运算的变量对应上之前作业5中的计算中间变量。需要编写的部分其实很简单，但是需要注意要把inter的各个成员变量都进行赋值，尤其注意不能漏掉m,normal,obj这些，同时赋值时需要注意参看上面的类的定义。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inline Intersection Triangle::get<span class="hljs-constructor">Intersection(Ray <span class="hljs-params">ray</span>)</span><br>&#123;<br>    Intersection inter;<br><br>    <span class="hljs-keyword">if</span> (dot<span class="hljs-constructor">Product(<span class="hljs-params">ray</span>.<span class="hljs-params">direction</span>, <span class="hljs-params">normal</span>)</span> &gt; <span class="hljs-number">0</span>)<br>        return inter;<br>    double u, v, t_tmp = <span class="hljs-number">0</span>;<br>    Vector3f pvec = cross<span class="hljs-constructor">Product(<span class="hljs-params">ray</span>.<span class="hljs-params">direction</span>, <span class="hljs-params">e2</span>)</span>;  <span class="hljs-comment">//s1</span><br>    double det = dot<span class="hljs-constructor">Product(<span class="hljs-params">e1</span>, <span class="hljs-params">pvec</span>)</span>;  <span class="hljs-comment">//dotProduct(s1, e1)</span><br>    <span class="hljs-keyword">if</span> (fabs(det) &lt; EPSILON)<br>        return inter;<br><br>    double det_inv = <span class="hljs-number">1.</span><span class="hljs-operator"> / </span>det;<br>    Vector3f tvec = ray.origin - v0;  <span class="hljs-comment">//s</span><br>    u = dot<span class="hljs-constructor">Product(<span class="hljs-params">tvec</span>, <span class="hljs-params">pvec</span>)</span><span class="hljs-operator"> * </span>det_inv; <span class="hljs-comment">//b1</span><br>    <span class="hljs-keyword">if</span> (u &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>u &gt; <span class="hljs-number">1</span>)<br>        return inter;<br>    Vector3f qvec = cross<span class="hljs-constructor">Product(<span class="hljs-params">tvec</span>, <span class="hljs-params">e1</span>)</span>;  <span class="hljs-comment">//s2</span><br>    v = dot<span class="hljs-constructor">Product(<span class="hljs-params">ray</span>.<span class="hljs-params">direction</span>, <span class="hljs-params">qvec</span>)</span><span class="hljs-operator"> * </span>det_inv;  <span class="hljs-comment">//b2</span><br>    <span class="hljs-keyword">if</span> (v &lt; <span class="hljs-number">0</span><span class="hljs-operator"> || </span>u + v &gt; <span class="hljs-number">1</span>)<br>        return inter;<br>    t_tmp = dot<span class="hljs-constructor">Product(<span class="hljs-params">e2</span>, <span class="hljs-params">qvec</span>)</span><span class="hljs-operator"> * </span>det_inv;<br><br>    <span class="hljs-comment">// TODO find ray triangle intersection</span><br>    <span class="hljs-keyword">if</span> (t_tmp&gt;<span class="hljs-number">0.0</span>f)<br>    &#123;<br>        inter.distance = t_tmp;<br>        <span class="hljs-comment">// inter.coords = Vector3f(u, v, 1.0); //**Wrong. </span><br>        <span class="hljs-comment">// inter.coords = ray(t_tmp);</span><br>        inter.coords = ray.origin + ray.direction<span class="hljs-operator"> * </span>t_tmp;  <br>        inter.happened = <span class="hljs-literal">true</span>;<br>        inter.m = m;   <span class="hljs-comment">//**Missed. Pay attention to the &quot;m&quot; above!(int class definition)</span><br>        inter.normal = normal;  <span class="hljs-comment">//*Missed. But what is &quot;normal&quot; referring to ?</span><br>        inter.obj = this;       <span class="hljs-comment">//*Missed. obj?  this?</span><br>    &#125;<br>    <br><br>    return inter;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-3-IntersectP-const-Ray-amp-ray-const-Vector3f-amp-invDir-const-std-array-amp-dirIsNeg-in-the-Bounds3-hpp"><a href="#1-3-IntersectP-const-Ray-amp-ray-const-Vector3f-amp-invDir-const-std-array-amp-dirIsNeg-in-the-Bounds3-hpp" class="headerlink" title="1.3 IntersectP(const Ray&amp; ray, const Vector3f&amp; invDir,const std::array&amp; dirIsNeg) in the Bounds3.hpp"></a>1.3 IntersectP(const Ray&amp; ray, const Vector3f&amp; invDir,const std::array<int, 3>&amp; dirIsNeg) in the Bounds3.hpp</h3><p>这部分没出什么问题，只需要注意一下eigen库的使用，不要把中括号和小括号搞反。</p><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs zephir">inline <span class="hljs-keyword">bool</span> Bounds3::IntersectP(<span class="hljs-keyword">const</span> Ray&amp; ray, <span class="hljs-keyword">const</span> Vector3f&amp; invDir,<br>                                <span class="hljs-keyword">const</span> std::array&lt;<span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>&gt;&amp; dirIsNeg) <span class="hljs-keyword">const</span><br>&#123;<br>    <span class="hljs-comment">// invDir: ray direction(x,y,z), invDir=(1.0/x,1.0/y,1.0/z), use this because Multiply </span><br>    <span class="hljs-comment">// is faster that Division</span><br>    <span class="hljs-comment">// dirIsNeg: ray direction(x,y,z), dirIsNeg=[int(x&gt;0),int(y&gt;0),int(z&gt;0)], </span><br>    <span class="hljs-comment">// use this to simplify your logic</span><br>    <span class="hljs-comment">// TODO test if ray bound intersects</span><br>    <span class="hljs-keyword">double</span> tenter, texit, tmin, tmax;<br>    texit = std::numeric_limits&lt;<span class="hljs-keyword">double</span>&gt;::max();<br>    tenter = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">3</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">double</span> tmin = std::min((pMin[i] - ray.origin[i]) * invDir[i], <br>                                (pMax[i] - ray.origin[i]) * invDir[i]);<br>        <span class="hljs-keyword">double</span> tmax = std::max((pMin[i] - ray.origin[i]) * invDir[i], <br>                                (pMax[i] - ray.origin[i]) * invDir[i]);<br>        tenter = std::max(tenter, tmin);<br>        texit = std::min(texit, tmax);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (tenter&lt;texit &amp;&amp; texit&gt;<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-4-getIntersection-BVHBuildNode-node-const-Ray-ray-in-BVH-cpp"><a href="#1-4-getIntersection-BVHBuildNode-node-const-Ray-ray-in-BVH-cpp" class="headerlink" title="1.4 getIntersection(BVHBuildNode* node, const Ray ray)in BVH.cpp"></a>1.4 <strong>getIntersection(BVHBuildNode* node, const Ray ray)</strong>in BVH.cpp</h3><p>这部分也相对简单，出错的地方是对于叶子节点返回其中所有物体表面与光线相交的最近点时没写对，这也需要注意相关类的定义。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Intersection BVHAccel::get<span class="hljs-constructor">Intersection(BVHBuildNode<span class="hljs-operator">*</span> <span class="hljs-params">node</span>, <span class="hljs-params">const</span> Ray&amp; <span class="hljs-params">ray</span>)</span> const<br>&#123;<br>    <span class="hljs-comment">// TODO Traverse the BVH to find intersection</span><br>    Intersection isect;<br>    std::<span class="hljs-built_in">array</span>&lt;<span class="hljs-built_in">int</span>, <span class="hljs-number">3</span>&gt; dirIsNeg;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">3</span>;i++)<br>        dirIsNeg<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = <span class="hljs-built_in">int</span>(ray.direction<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>&gt;<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (!node-&gt;bounds.<span class="hljs-constructor">IntersectP(<span class="hljs-params">ray</span>, <span class="hljs-params">ray</span>.<span class="hljs-params">direction_inv</span>, <span class="hljs-params">dirIsNeg</span>)</span>) <br>        return isect; <span class="hljs-comment">//若光线与bounding box不相交，结束</span><br>    <span class="hljs-comment">//若相交</span><br>    <span class="hljs-comment">//叶子节点，判断节点内部所有物体，返回最近的交点</span><br>    <span class="hljs-keyword">if</span> (node-&gt;left<span class="hljs-operator"> == </span>nullptr<span class="hljs-operator"> &amp;&amp; </span>node-&gt;right<span class="hljs-operator"> == </span>nullptr)<br>        <span class="hljs-comment">// return Intersect(ray);    *Wrong.</span><br>        return node-&gt;<span class="hljs-keyword">object</span>-&gt;get<span class="hljs-constructor">Intersection(<span class="hljs-params">ray</span>)</span>;  <span class="hljs-comment">//Pay attention.</span><br>    Intersection hit1 = get<span class="hljs-constructor">Intersection(<span class="hljs-params">node</span>-&gt;<span class="hljs-params">left</span>, <span class="hljs-params">ray</span>)</span>;<br>    Intersection hit2 = get<span class="hljs-constructor">Intersection(<span class="hljs-params">node</span>-&gt;<span class="hljs-params">right</span>, <span class="hljs-params">ray</span>)</span>;<br>    <span class="hljs-comment">//若节点不是叶子节点，返回两个子节点交点的最近值</span><br>    <span class="hljs-keyword">if</span> (hit1.distance &lt; hit2.distance)<br>        return hit1;<br>    <span class="hljs-keyword">else</span> <br>        return hit2;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-5-基础部分实现效果"><a href="#1-5-基础部分实现效果" class="headerlink" title="1.5 基础部分实现效果"></a>1.5 基础部分实现效果</h3><p><img src="https://s2.loli.net/2022/02/27/tlxA9inKOyM27ZL.png" alt="image-20220227222351813"></p>]]></content>
    
    
    <categories>
      
      <category>Games101</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graphics</tag>
      
      <tag>Ray Tracing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Image relief effect</title>
    <link href="/2022/03/02/Image-relief-effect/"/>
    <url>/2022/03/02/Image-relief-effect/</url>
    
    <content type="html"><![CDATA[<h1 id="图像浮雕效果实现"><a href="#图像浮雕效果实现" class="headerlink" title="图像浮雕效果实现"></a>图像浮雕效果实现</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="浮雕效果定义"><a href="#浮雕效果定义" class="headerlink" title="浮雕效果定义"></a>浮雕效果定义</h3><p>浮雕效果：指计算每个像素点与其周围像素的差值，差别较大的像素点在灰度图像中表现较为亮，边缘凸起，成浮雕形状。效果如下：</p><p><img src="https://s2.loli.net/2022/04/02/lTZ53GdSmavW86I.jpg" alt="test1"></p><center>原图</center><p><img src="https://s2.loli.net/2022/04/02/eG1hOUksz9IHpMq.jpg" alt=""></p><center>浮雕效果图</center><span id="more"></span><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>本作业中采用二维傅里叶变换实现浮雕效果。</p><p>二维傅里叶变换（离散）是一种将图像从空间域转换到频域的变换方法。图像可看作二维矩阵，本作业中的图像为彩色，包含RGB三个通道的灰度信息。利用二维离散傅里叶变换可以将图像从空间域（即二维灰度数表）转换到频域（即频率数表），便于进行频域滤波等操作。</p><p>变换具体公式为：</p><script type="math/tex; mode=display">f(x,y)=\frac{1}{MN}\sum_{u=0}^{M-1}\sum_{v=0}^{N-1}F(u,v)e^{j2\pi(\frac{ux}{M}+\frac{vy}{N})}</script><p>其中$f(x,y)$ 代表大小为 M x N 的图像矩阵(其中$ x = 0,1,2,···,M-1$ 和 $y = 0,1,2,···,N-1$)；$F(u,v)$ 表示 $f(x,y)$ 的傅里叶变换。</p><p>变换完成后，在时域上分别对x、y方向上进行差分叠加，然后借助不同的灰度等级逐步调节矩阵，即可得到浮雕效果。</p><h2 id="Matlab源代码"><a href="#Matlab源代码" class="headerlink" title="Matlab源代码"></a>Matlab源代码</h2><h3 id="relief函数"><a href="#relief函数" class="headerlink" title="relief函数"></a>relief函数</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">result</span> = <span class="hljs-title">relief</span><span class="hljs-params">(image, num)</span>     % <span class="hljs-title">num</span>为通道数</span><br>    [h, w, ~]=<span class="hljs-built_in">size</span>(image);       <br>    <span class="hljs-comment">% 生成每一列对应的jw_x和jw_y</span><br>    fx = <span class="hljs-built_in">linspace</span>(<span class="hljs-built_in">floor</span>(-w/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>, <span class="hljs-built_in">floor</span>(w/<span class="hljs-number">2</span>), w);               <br>    fx = fx / w * <span class="hljs-number">2</span> * <span class="hljs-built_in">pi</span> * <span class="hljs-number">1</span><span class="hljs-built_in">i</span>;                                   <br>    fy = <span class="hljs-built_in">linspace</span>(<span class="hljs-built_in">floor</span>(-h/<span class="hljs-number">2</span>)+<span class="hljs-number">1</span>, <span class="hljs-built_in">floor</span>(h/<span class="hljs-number">2</span>), h);<br>    fy = fy&#x27; / h * <span class="hljs-number">2</span> * <span class="hljs-built_in">pi</span> * <span class="hljs-number">1</span><span class="hljs-built_in">i</span>;<br>    <span class="hljs-comment">% 结果初始化</span><br>    result = <span class="hljs-built_in">zeros</span>(<span class="hljs-built_in">size</span>(image));<br>    <span class="hljs-comment">% 逐个通道处理</span><br>    <span class="hljs-keyword">for</span> channel = <span class="hljs-number">1</span>:num                <br>        s = double(image(:, :, channel));<br>        f = fftshift(fft2(s));          <br>        <span class="hljs-comment">% 求差分并叠加</span><br>        df = f.*(<span class="hljs-number">1</span> - <span class="hljs-built_in">exp</span>(-fx)) + f.*(<span class="hljs-number">1</span> - <span class="hljs-built_in">exp</span>(-fy));    <br>        result(:, :, channel)=<span class="hljs-built_in">real</span>(ifft2(ifftshift(df)));<br>    <span class="hljs-keyword">end</span><br>    <span class="hljs-comment">% 中心化与规范化</span><br>    result = double(result)./(<span class="hljs-built_in">max</span>(result) - <span class="hljs-built_in">min</span>(result))*<span class="hljs-number">255.0</span> + <span class="hljs-number">128.0</span>; <br>    result = uint8(result);<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><h3 id="主程序-调用relief函数"><a href="#主程序-调用relief函数" class="headerlink" title="主程序(调用relief函数)"></a>主程序(调用relief函数)</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs matlab">image_input = imread(<span class="hljs-string">&quot;test.jpg&quot;</span>);<br>image_output = relief(image_input, <span class="hljs-number">3</span>);<br>imshow(image_output);<br></code></pre></td></tr></table></figure><h2 id="测试图片"><a href="#测试图片" class="headerlink" title="测试图片"></a>测试图片</h2><h3 id="测试1-1024-683"><a href="#测试1-1024-683" class="headerlink" title="测试1(1024*683)"></a>测试1(1024*683)</h3><p><img src="https://s2.loli.net/2022/04/02/lTZ53GdSmavW86I.jpg" alt="test"></p><p><img src="https://s2.loli.net/2022/04/02/nHGCoA21lM6Dc5R.jpg" alt="result1"></p><h3 id="测试2-532-300"><a href="#测试2-532-300" class="headerlink" title="测试2(532*300)"></a>测试2(532*300)</h3><p><img src="https://s2.loli.net/2022/04/02/HphNCwv2LRuBdSU.jpg" alt="test2"></p><p><img src="https://s2.loli.net/2022/04/02/lTJCcNjK7GYLuHi.jpg" alt="res2"></p><h3 id="测试3-3840-2160"><a href="#测试3-3840-2160" class="headerlink" title="测试3(3840*2160)"></a>测试3(3840*2160)</h3><p><img src="https://s2.loli.net/2022/04/02/TFGp5gWCBHMIqos.jpg" alt="test4"></p><p><img src="https://s2.loli.net/2022/04/02/43efsyhF5lck9H2.jpg" alt="res4"></p><h3 id="测试4-681-517"><a href="#测试4-681-517" class="headerlink" title="测试4(681*517)"></a>测试4(681*517)</h3><p><img src="https://s2.loli.net/2022/04/02/iFZemb2G38ty5Ld.jpg" alt="test3"></p><p><img src="https://s2.loli.net/2022/04/02/zUSytTfIqwJHjFE.jpg" alt="res3"></p>]]></content>
    
    
    <categories>
      
      <category>courses</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Image Processing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pytorch入门</title>
    <link href="/2022/02/27/pytorch-intro-1/"/>
    <url>/2022/02/27/pytorch-intro-1/</url>
    
    <content type="html"><![CDATA[<h1 id="pytorch入门"><a href="#pytorch入门" class="headerlink" title="pytorch入门"></a>pytorch入门</h1><h2 id="视频链接"><a href="#视频链接" class="headerlink" title="视频链接"></a>视频链接</h2><p><a href="https://www.bilibili.com/video/BV1hE411t7RN?p=12&amp;spm_id_from=pageDriver">https://www.bilibili.com/video/BV1hE411t7RN?p=12&amp;spm_id_from=pageDriver</a></p><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><p>shift+enter 换行（可以在console中换行）</p><p>ctrl+p 看到当前函数需要哪些参数</p><h2 id="基本说明"><a href="#基本说明" class="headerlink" title="基本说明"></a>基本说明</h2><p>jupyter适合于查看帮助文档等</p><span id="more"></span><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h3><p>windows下文件路径使用\\\\</p><p>尽量使用相对路径，绝对路径在windows下可能被当成转义符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># absolute path = &quot;E:\coding\torch_test\images\5e233a14c9334a84a879795ee679d2c1.jpg&quot;</span><br><span class="hljs-comment"># relative path = &quot;images/5e233a14c9334a84a879795ee679d2c1.jpg&quot;</span><br>img_path = <span class="hljs-string">&quot;images/5e233a14c9334a84a879795ee679d2c1.jpg&quot;</span><br>img_path_abs = <span class="hljs-string">&quot;E:\coding\torch_test\images\5e233a14c9334a84a879795ee679d2c1.jpg&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/03/28/gih2H698MoN1ElB.png" alt="image-20220328105947199"></p><hr><h2 id="2022-3-27"><a href="#2022-3-27" class="headerlink" title="2022.3.27"></a>2022.3.27</h2><h2 id="PyCharm控制台python-shell与IPython-shell的切换"><a href="#PyCharm控制台python-shell与IPython-shell的切换" class="headerlink" title="PyCharm控制台python shell与IPython shell的切换"></a>PyCharm控制台python shell与IPython shell的切换</h2><p>详见<a href="https://www.cnblogs.com/miaoning/p/11069224.html">https://www.cnblogs.com/miaoning/p/11069224.html</a></p><p>但是要注意需要在conda的环境中安装IPython</p><h2 id="Anaconda-Prompt-切换工作路径"><a href="#Anaconda-Prompt-切换工作路径" class="headerlink" title="Anaconda Prompt 切换工作路径"></a>Anaconda Prompt 切换工作路径</h2><p>首先切到C盘根目录下，然后直接输入对应盘符号即可</p><p><img src="https://s2.loli.net/2022/03/27/2MnYlUpbsi51FzG.png" alt="image-20220327100336654"></p><h2 id="Tensorboard"><a href="#Tensorboard" class="headerlink" title="Tensorboard"></a>Tensorboard</h2><p>打开log文件并指定端口(此处为 <a href="http://localhost:6007/">http://localhost:6007/</a>)</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">tensorboard <span class="hljs-attribute">--logdir</span>=logs <span class="hljs-attribute">--port</span>=6007<br></code></pre></td></tr></table></figure><p>demo1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;logs&quot;</span>)<br><br><span class="hljs-comment"># writer.add_image()</span><br><span class="hljs-comment"># y=x</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    writer.add_scalar(<span class="hljs-string">&quot;y=2x&quot;</span>,<span class="hljs-number">2</span>*i,i)<br><br>writer.close()<br></code></pre></td></tr></table></figure><p>效果图</p><p><img src="https://s2.loli.net/2022/03/27/OePvM3taE5UxznY.png" alt="image-20220327124109596"></p><hr><h2 id="2022-3-28"><a href="#2022-3-28" class="headerlink" title="2022.3.28"></a>2022.3.28</h2><h2 id="Transforms"><a href="#Transforms" class="headerlink" title="Transforms"></a>Transforms</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p><img src="https://s2.loli.net/2022/03/28/c2sz5tXZdorIQAe.png" alt="image-20220328110649328"> </p><p>关注官方文档，函数的输入输出，使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>())<br></code></pre></td></tr></table></figure><p>等方式尝试了解数据类型。</p><p>demo：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><br><span class="hljs-comment"># absolute path = &quot;E:\coding\torch_test\images\5e233a14c9334a84a879795ee679d2c1.jpg&quot;</span><br><span class="hljs-comment"># relative path = &quot;images/5e233a14c9334a84a879795ee679d2c1.jpg&quot;</span><br>img_path = <span class="hljs-string">&quot;images/5e233a14c9334a84a879795ee679d2c1.jpg&quot;</span><br><span class="hljs-comment"># img_path_abs = &quot;E:\coding\torch_test\images\5e233a14c9334a84a879795ee679d2c1.jpg&quot;</span><br>img = Image.<span class="hljs-built_in">open</span>(img_path)<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;cslogs&quot;</span>)<br><br><span class="hljs-comment"># ToTensor</span><br>tensor_ToTensor = transforms.ToTensor()  <span class="hljs-comment"># 创建ToTensor对象</span><br>img_tensor = tensor_ToTensor(img)        <span class="hljs-comment"># 这里其实调用了ToTensor的内置函数</span><br>writer.add_image(<span class="hljs-string">&quot;ToTensor&quot;</span>, img_tensor)<br><br><span class="hljs-comment"># Normalize</span><br>tensor_norm = transforms.Normalize([<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])<br>img_norm = tensor_norm(img_tensor)<br>writer.add_image(<span class="hljs-string">&quot;Normalize&quot;</span>, img_norm)<br><br><span class="hljs-comment"># Resize</span><br>tensor_resize = transforms.Resize([<span class="hljs-number">512</span>, <span class="hljs-number">512</span>])<br><span class="hljs-comment"># PIL --&gt;Resize--&gt; resize PIL --&gt;ToTensor--&gt; resize tensor</span><br>img_resize = tensor_ToTensor(tensor_resize(img))<br>writer.add_image(<span class="hljs-string">&quot;Resize&quot;</span>, img_resize, <span class="hljs-number">0</span>)<br><span class="hljs-comment"># Compose style</span><br>tensor_resize_2 = transforms.Resize(<span class="hljs-number">512</span>)<br>tensor_compose = transforms.Compose([tensor_resize_2, tensor_ToTensor])<br>img_resize_compose = tensor_compose(img)<br>writer.add_image(<span class="hljs-string">&quot;Resize&quot;</span>, img_resize_compose, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># RandomCrop</span><br>tensor_random = transforms.RandomCrop(<span class="hljs-number">512</span>)<br>tensor_compose_2 = transforms.Compose([tensor_random, tensor_ToTensor])<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">25</span>):<br>    img_crop = tensor_compose_2(img)<br>    writer.add_image(<span class="hljs-string">&quot;RamdomCrop&quot;</span>, img_crop, i)<br><br>writer.close()<br></code></pre></td></tr></table></figure><h2 id="Torchvision数据集使用"><a href="#Torchvision数据集使用" class="headerlink" title="Torchvision数据集使用"></a>Torchvision数据集使用</h2><p>以<a href="https://pytorch.org/vision/stable/generated/torchvision.datasets.CIFAR10.html#torchvision.datasets.CIFAR10"><code>CIFAR10</code></a>为例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br>dataset_transform = torchvision.transforms.Compose([<br>    torchvision.transforms.ToTensor()<br>])<br><span class="hljs-comment"># 一般download选项都设置为true</span><br>train_set = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./dataset&quot;</span>, train=<span class="hljs-literal">True</span>, transform=dataset_transform, download=<span class="hljs-literal">True</span>)<br>test_set = torchvision.datasets.CIFAR10(root=<span class="hljs-string">&quot;./dataset&quot;</span>, train=<span class="hljs-literal">False</span>, transform=dataset_transform, download=<span class="hljs-literal">True</span>)<br><br>writer = SummaryWriter(<span class="hljs-string">&quot;P10&quot;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    img, tatget = train_set[i]<br>    writer.add_image(<span class="hljs-string">&quot;Train Images&quot;</span>, img, i)<br><br>writer.close()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Deeplearning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pytorch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OOP-1</title>
    <link href="/2022/02/20/OOP-1/"/>
    <url>/2022/02/20/OOP-1/</url>
    
    <content type="html"><![CDATA[<h1 id="02-What-is-Object-Oriented"><a href="#02-What-is-Object-Oriented" class="headerlink" title="02 What is Object-Oriented"></a>02 What is Object-Oriented</h1><h2 id="Objects-Attributes-Services"><a href="#Objects-Attributes-Services" class="headerlink" title="Objects=Attributes+Services"></a>Objects=Attributes+Services</h2><p><img src="https://s2.loli.net/2022/03/20/ha4mFAnYDUMuBlE.png" alt="image-20220320213015024"></p><h3 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h3><p>​    properties or status</p><h3 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h3><p>​     functions</p><span id="more"></span><h2 id="Comparision-C-amp-amp-C"><a href="#Comparision-C-amp-amp-C" class="headerlink" title="Comparision: C &amp;&amp; C++"></a>Comparision: C &amp;&amp; C++</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//C style</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">point3d</span>&#123;</span><br>    <span class="hljs-type">float</span> x;<br>    <span class="hljs-type">float</span> y;<br>    <span class="hljs-type">float</span> z;<br>&#125;Point3d;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Point3d_print</span><span class="hljs-params">(<span class="hljs-type">const</span> Point3d* pd)</span>;<br>Point3d a;<br>a.x = <span class="hljs-number">1</span>;<br>a.y = <span class="hljs-number">2</span>;<br>a.z = <span class="hljs-number">3</span>;<br>Point3d_print(&amp;a);<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//C++ style</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point3d</span>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Point3d</span>(<span class="hljs-type">float</span> x, <span class="hljs-type">float</span> y, <span class="hljs-type">float</span> z);<br><span class="hljs-built_in">print</span>();<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">float</span> x;<br><span class="hljs-type">float</span> y;<br><span class="hljs-type">float</span> z;<br>&#125;;<br><br><span class="hljs-function">Point3d <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span>;<br>a.<span class="hljs-built_in">print</span>();<br></code></pre></td></tr></table></figure><h2 id="What-is-object-oriented"><a href="#What-is-object-oriented" class="headerlink" title="What is object-oriented"></a>What is object-oriented</h2><p>A way to organize <strong>Designs</strong> and <strong>Implementations</strong></p><p>To focus on things, not operations.</p><h1 id="03-Fundamental-of-OOP"><a href="#03-Fundamental-of-OOP" class="headerlink" title="03 Fundamental of OOP"></a>03 Fundamental of OOP</h1><h2 id="Objects-send-and-receive-messages"><a href="#Objects-send-and-receive-messages" class="headerlink" title="Objects send and receive messages"></a>Objects send and receive messages</h2><p><img src="https://s2.loli.net/2022/03/20/kMynmbp56TcXoJC.png" alt="image-20220320215335376"><strong>Messages</strong> are:<br>    -Composed by the sender<br>    -<strong>Interperted by the receiver</strong>(重点：让接收者自己决定执行什么动作，不接触类的data)<br>    -Implemented by the methods </p><h2 id="Object-vs-Class"><a href="#Object-vs-Class" class="headerlink" title="Object vs. Class"></a>Object vs. Class</h2><p><img src="https://s2.loli.net/2022/03/20/CU7JmPDhMLqAyNp.png" alt="image-20220320220933094"></p><h2 id="OOP-Characteristics"><a href="#OOP-Characteristics" class="headerlink" title="OOP Characteristics"></a>OOP Characteristics</h2><ol><li>Everything is an object.</li><li>A program is a brunch of objects telling each other <strong>what</strong> to do by sending messages.(<strong>WHAT, not HOW!</strong>)</li><li>Each object has its own memory made up of other objects.</li><li>Every object has a type.</li><li>All objects of a particular type can receive the same messages.(<strong>反过来也成立，即可以接受相同消息的对象属于相同类型</strong>)</li></ol><h2 id="Functions-of-the-Interface"><a href="#Functions-of-the-Interface" class="headerlink" title="Functions of the Interface"></a>Functions of the Interface</h2><p><strong>-communication</strong></p><p><strong>-protection</strong></p><p>OOP程序设计中希望实现<strong>松耦合</strong></p><h2 id="Encapsulation-封装"><a href="#Encapsulation-封装" class="headerlink" title="Encapsulation(封装)"></a>Encapsulation(封装)</h2><p>Bundle <strong>data</strong> and <strong>methods</strong> dealing with these data together in an object.</p><p><strong>Hide</strong> the details of the data and the actions.</p><p>Restrict only access to the <strong>publicized methods</strong>. </p><h1 id="04-Example-Ticket-Machine"><a href="#04-Example-Ticket-Machine" class="headerlink" title="04 Example: Ticket Machine"></a>04 Example: Ticket Machine</h1><h2 id="规范"><a href="#规范" class="headerlink" title="[规范]"></a>[规范]</h2><p>project: 使用全小写字母，如 ticketmachine</p><p>class: 首字母大写，如 TicketMachine</p><h2 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h2><p>每个类都应当包含<strong>.h</strong>和<strong>.cpp</strong>两个文件</p><p>.h中声明，.cpp中定义</p><p>:: 称为域解析符</p>]]></content>
    
    
    <categories>
      
      <category>OOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Signals &amp; Systems Review-CH1</title>
    <link href="/2022/02/03/Signals-Systems-Review-CH1/"/>
    <url>/2022/02/03/Signals-Systems-Review-CH1/</url>
    
    <content type="html"><![CDATA[<h1 id="Signals-and-Systems-Review-CH1"><a href="#Signals-and-Systems-Review-CH1" class="headerlink" title="Signals and Systems Review - CH1"></a>Signals and Systems Review - CH1</h1><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h2><h3 id="信息-消息-信号"><a href="#信息-消息-信号" class="headerlink" title="信息.消息.信号"></a>信息.消息.信号</h3><p>例子：<strong>电信号</strong>传递<strong>声音、图像、文字</strong></p><p>信号是消息的表现形式，消息是信号的具体内容</p><h3 id="系统"><a href="#系统" class="headerlink" title="系统"></a>系统</h3><p>包括变换器、处理器等</p><p>$\Leftrightarrow$网络$\Leftrightarrow$电路</p><h3 id="信号分析"><a href="#信号分析" class="headerlink" title="信号分析"></a>信号分析</h3><p>目的：揭示信号特性及其改变方式</p><p>思想：分解成<strong>简单基本单元信号</strong></p><h3 id="系统分析"><a href="#系统分析" class="headerlink" title="系统分析"></a>系统分析</h3><p>对指定输入激励的输出响应</p><span id="more"></span><h2 id="1-2-信号描述"><a href="#1-2-信号描述" class="headerlink" title="1.2 信号描述"></a>1.2 信号描述</h2><h3 id="确定性信号-amp-随机信号"><a href="#确定性信号-amp-随机信号" class="headerlink" title="确定性信号&amp;随机信号"></a>确定性信号&amp;随机信号</h3><p>确定性信号：对于指定的某一时刻t，可确定一相应的函数值f(t)，<strong>若干不连续点除外</strong></p><h3 id="连续信号-amp-离散信号"><a href="#连续信号-amp-离散信号" class="headerlink" title="连续信号&amp;离散信号"></a>连续信号&amp;离散信号</h3><p>连续时间信号：自变量的取值范围是连续的（实数域），用t表示连续时间变量</p><p><img src="https://s2.loli.net/2022/04/03/4n1XgovF9skeYxf.png" alt="image-20220403145759285"></p><p>离散时间信号：自变量只取整数值的信号，用n表示离散时间变量</p><p><img src="https://s2.loli.net/2022/04/03/AT9Lcu6gwNjzt5n.png" alt="image-20220403145826087"></p><h3 id="周期信号-amp-非周期信号"><a href="#周期信号-amp-非周期信号" class="headerlink" title="周期信号&amp;非周期信号"></a>周期信号&amp;非周期信号</h3><p>周期信号：满足$x(t+T)=x(t)\space or\space x(n+N)=x(n)$</p><p><img src="https://s2.loli.net/2022/04/03/BSGRMUk9y7hz3qv.png" alt="image-20220403150009283"></p><h3 id="模拟、量化、抽样"><a href="#模拟、量化、抽样" class="headerlink" title="模拟、量化、抽样"></a>模拟、量化、抽样</h3><p>模拟信号：时间和幅值均连续</p><p><img src="https://s2.loli.net/2022/04/03/FzBOlVEjmLMw6UI.png" alt="image-20220403150055042"></p><p>抽样信号：时间离散，幅值连续</p><p><img src="https://s2.loli.net/2022/04/03/ydisMXkzvrFhPAE.png" alt="image-20220403150125448"></p><p>数字信号：时间和幅值均为离散</p><p><img src="https://s2.loli.net/2022/04/03/ewizHKBP49g5Dh2.png" alt="image-20220403150143318"></p><p>【模拟】$\rightarrow$抽样$\rightarrow$【抽样】$\rightarrow$量化$\rightarrow$【数字】</p><p>时间离散性$\Rightarrow$连续、离散</p><p>幅度离散型$\Rightarrow$(离散)抽样、数字</p><h3 id="能量信号-amp-功率信号"><a href="#能量信号-amp-功率信号" class="headerlink" title="能量信号&amp;功率信号"></a>能量信号&amp;功率信号</h3><p><strong>周期信号为功率信号</strong>，通常用它的平均功率来表征；</p><p>非周期信号可能为能量信号，也可能为功率信号，与函数形式有关。</p><h3 id="典型确定性信号"><a href="#典型确定性信号" class="headerlink" title="典型确定性信号"></a>典型确定性信号</h3><h4 id="指数信号"><a href="#指数信号" class="headerlink" title="指数信号"></a>指数信号</h4><script type="math/tex; mode=display">f(t)=e^{\alpha t}</script><p><img src="https://s2.loli.net/2022/04/03/rMvd6plFLuqRQJj.png" alt="image-20220403150704589"></p><p>单边指数信号</p><p><img src="https://s2.loli.net/2022/04/03/lmI4JewqxkBbhE2.png" alt="image-20220403150841141"></p><p>时间常数：$\tau = \frac{1}{|\alpha|}$，量纲为时间，代表衰减速度</p><p>重要特性：积分、微分仍是指数形式</p><h4 id="复指数信号"><a href="#复指数信号" class="headerlink" title="复指数信号"></a>复指数信号</h4><script type="math/tex; mode=display">f(t)=Ke^{st}</script><p>其中$s=\sigma + j\omega$为复数，称为<strong>复频率</strong></p><script type="math/tex; mode=display">f(t)=Ke^{\sigma t}cos(\omega t)+jKe^{\sigma t}sin{\omega t}</script><p><img src="https://s2.loli.net/2022/04/03/RzL5ltykH7YdSZn.png" alt="image-20220403152631396"></p><p><img src="https://s2.loli.net/2022/04/03/Xif2SUOuL5jtaQc.png" alt="image-20220403152644234"></p><p><img src="https://s2.loli.net/2022/04/03/qjpdZNm9OWzU8iv.png" alt="image-20220403152650531"></p><p><img src="https://s2.loli.net/2022/04/03/B6sfcMivy7NUCFQ.png" alt="image-20220403152712908"></p><h4 id="抽样信号"><a href="#抽样信号" class="headerlink" title="抽样信号"></a>抽样信号</h4><script type="math/tex; mode=display">Sa(t)=\frac{sin t}{t}</script><p><img src="https://s2.loli.net/2022/04/03/2IPsxX4wRUOe713.png" alt="image-20220403152927876"></p><p>性质：</p><script type="math/tex; mode=display">Sa(t)=Sa(-t)\space (偶函数)\\lim_{t\rightarrow0}Sa(t)=1 \\lim_{t\rightarrow \pm \infty}Sa(t)=0 \space(正负无穷都满足)\\Sa(\pm n\pi)=0\space,n=1,2,3,...(没有0！注意！) \\\int_0^{\infty}Sa(t)dt=\frac{\pi}{2} \\</script><p>sinc函数</p><script type="math/tex; mode=display">sinc(t)=\frac{sin(\pi t)}{\pi t}</script><p>钟形信号(高斯函数)</p><script type="math/tex; mode=display">f(t)=Ee^{-(\frac{t}{\tau})^2}</script><p><img src="https://s2.loli.net/2022/04/03/iqmZwhFfMn24Dgb.png" alt="image-20220403153806039"></p><h2 id="1-3-信号运算"><a href="#1-3-信号运算" class="headerlink" title="1.3 信号运算"></a>1.3 信号运算</h2><h3 id="宗量"><a href="#宗量" class="headerlink" title="宗量"></a>宗量</h3><p>宗量：可以理解为广义的自变量。这里的“广义”是指：自变量突破高中数学中的限制，可以是狭义的自变量，可以是函数，也可以是代数式……</p><p>可以依据<strong>宗量相同，函数值相同</strong>，求新坐标<strong>（！！！！）</strong></p><h3 id="移位"><a href="#移位" class="headerlink" title="移位"></a>移位</h3><p>f(t)沿着t轴平移$\tau$得到</p><script type="math/tex; mode=display">f(t)\rightarrow f(t-\tau) \\\tau>0，右移（滞后） \\\tau<0，左移（超前）</script><p>可以依据<strong>宗量相同，函数值相同</strong>，求新坐标</p><p><img src="https://s2.loli.net/2022/04/03/Z2e4LncSRoWdwDI.png" alt="image-20220403165602982"></p><h3 id="反褶"><a href="#反褶" class="headerlink" title="反褶"></a>反褶</h3><script type="math/tex; mode=display">f(t)\rightarrow f(-t)</script><p>以纵轴为轴折叠，把信号的过去与未来对调。</p><p><strong>没有可实现此功能的实际器件</strong>。</p><p>数字信号处理中可以实现此概念，例如堆栈中的“后进先出”。</p><h3 id="尺度"><a href="#尺度" class="headerlink" title="尺度"></a>尺度</h3><script type="math/tex; mode=display">f(t)\rightarrow f(at)</script><p><img src="https://s2.loli.net/2022/04/03/TlmWDrZyvCXLOxH.png" alt="image-20220403165916331"></p><p><img src="https://s2.loli.net/2022/04/03/wH2BiVhy6JCURcr.png" alt="image-20220403165931513"></p><h3 id="一般情况"><a href="#一般情况" class="headerlink" title="一般情况"></a>一般情况</h3><script type="math/tex; mode=display">f(t)\rightarrow f(at\pm b)=f(a(t\pm \frac{b}{a})) \space (a,b>0)</script><p><strong>Steps:</strong></p><p>1.尺度：a&gt;1，压缩a倍；a&lt;1，扩展1/a倍</p><p>2.移位：+，左移b/a；-，右移b/a</p><p>3.反褶：</p><script type="math/tex; mode=display">f(a(t+\frac{b}{a}))\rightarrow f(-a(t+\frac{b}{a}))=f(-at- b)</script><p>1.平移量t0是自变量t净增减的量，即以f(t-t0)为标准形式来确定t0</p><p>2.反转时以被变换的宗量$\lambda=0$( 可以是t的复合函数）的直线为轴，即以f(-$\lambda$)为标准形式确定反转轴</p><p>3.尺度变换应以被变换的宗量$\lambda=0$(的直线为展缩中心线，即以f(a $\lambda$)为标准形式确定展缩中心线</p>]]></content>
    
    
    <categories>
      
      <category>courses</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Signals</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
